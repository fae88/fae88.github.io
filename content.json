{"pages":[{"title":"About Me","date":"2017-11-26T03:42:51.000Z","updated":"2018-10-02T12:59:31.889Z","comments":true,"path":"about/index.html","permalink":"http://www.fufan.me/about/index.html","excerpt":"","text":"I AM WHAT I AM ……"},{"title":"tags","date":"2017-11-16T09:08:20.000Z","updated":"2018-10-02T07:52:02.919Z","comments":true,"path":"tags/index.html","permalink":"http://www.fufan.me/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-11-14T05:59:36.000Z","updated":"2018-10-02T07:50:02.801Z","comments":true,"path":"categories/index.html","permalink":"http://www.fufan.me/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"常用的vim命令整理（持续更新）","slug":"常用的vim命令整理（持续更新）","date":"2018-10-02T12:58:26.000Z","updated":"2018-10-02T12:58:29.733Z","comments":true,"path":"2018/10/02/常用的vim命令整理（持续更新）/","link":"","permalink":"http://www.fufan.me/2018/10/02/常用的vim命令整理（持续更新）/","excerpt":"","text":"1. 插入模式 (command mode)命令模式切换至插入状态i光标前插入I行首插入a光标后插入A行尾插入o行上新行O行下新行2. 命令模式 (insert mode)ESC从插入状态切换至命令模式光标移动h左移j下移k上移l右移H到屏幕顶部M到屏幕中央L到屏幕底部0到行首$到行尾Ctrl+f向前翻屏Ctrl+b向后翻屏Ctrl+d向前翻半屏Ctrl+u向后翻半屏定位gg回到文件首行,G回到文件尾行:n和nG光标定位到文件第n行(:20或20G表示光标定位到第20行):set nu 或:set number显示行号,:set nonu 取消显示行号ctrl+g删除x删除光标所在字符(与Delete键相同的方向),X删除光标所在字符(与Backspace键相同的方向)nx删除光标后n个字符dd删除光标所在行ndd删除光标所在行以后的n行D删除光标到行尾的内容dG删除光标所在行到文件末尾的内容n1,n2d删除行n1到行n2的内容，包括第n1和n2行都被删除s删除一个字符来插入模式S删除当前行以插入模式复制、剪切、粘贴、替换yy或Y复制当前行nyy或nY从当前行开始赋值n行ggVG全选剪切使用dd和ndd，相当于删除p在光标所在行之后粘贴P在光标所在行之前粘贴r替换当前字符后回到命令模式R一直替换知道通过ESC回到命令模式查找、替换\\KeyWord回车，n查找下一处?KeyWord回车，n查找上一处n重复相同方向N重复反向方向·:s/old/new/g替换整个文件，不确认:s/old/new/gc替换整个文件，确认:n1,n2s/old/new/g替换n1-n2行中匹配内容，不确认撤销u保存及离开:w保存文件:w!强制保存:w file将修改另外保存到file:wq保存文件并退出:wq!强制保存文件并退出:q不保存退出:q!不保存强制退出:e!放弃所有修改，从上次保存文件开始再编辑","categories":[],"tags":[]},{"title":"ssh免密码登录步骤及别名设置","slug":"ssh免密码登录步骤及别名设置","date":"2018-10-02T05:23:00.000Z","updated":"2018-10-02T05:45:00.655Z","comments":true,"path":"2018/10/02/ssh免密码登录步骤及别名设置/","link":"","permalink":"http://www.fufan.me/2018/10/02/ssh免密码登录步骤及别名设置/","excerpt":"","text":"ssh免密码登录步骤及别名设置1. 生成本机的公私钥ssh-keygen -t rsa2. 将公钥复制到目标机器上ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.1003. 设置别名登录vim ~/.ssh/config添加如下内容123456Host 100HostName 192.168.0.100Port 22User rootIdentityFile ~/.ssh/id_rsa.pubIdentitiesOnly yes4. 登录ssh 100","categories":[{"name":"linux","slug":"linux","permalink":"http://www.fufan.me/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.fufan.me/tags/linux/"}]},{"title":"Java面试总结积累（基础篇）之集合问题","slug":"Java面试总结积累（基础篇）之集合问题","date":"2017-01-12T16:35:00.000Z","updated":"2018-10-02T16:38:58.285Z","comments":true,"path":"2017/01/13/Java面试总结积累（基础篇）之集合问题/","link":"","permalink":"http://www.fufan.me/2017/01/13/Java面试总结积累（基础篇）之集合问题/","excerpt":"","text":"这里通过收集网上一些比较好的博客对集合的总结做一下记录和积累。List, Set, Map三者的区别及总结List：对付顺序的好帮手List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象Set:注重独一无二的性质不允许重复的集合。不会有多个元素引用相同的对象。Map:用Key来搜索的专家使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。Arraylist 与 LinkedList 区别Arraylist底层使用的是数组（存读数据效率高，插入删除特定位置效率低），LinkedList底层使用的是双向循环链表数据结构（插入，删除效率特别高）。学过数据结构这门课后我们就知道采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n），因此当数据特别多，而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了，因为一般数据量都不会蛮大，Arraylist是使用最多的集合类。ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector ，代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要同步时建议使用Arraylist。HashMap 和 Hashtable 的区别HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。因为线程安全的问题，HashMap要比HashTable效率高一点，HashTable基本被淘汰。HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。TIPS: Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java5或以上的话，请使用ConcurrentHashMap吧HashMap 和 ConcurrentHashMap 的区别ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。HashSet如何检查重复当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。==与equals的区别如果两个对象相等，则hashcode一定也是相同的两个对象相等,对两个equals方法返回true两个对象有相同的hashcode值，它们也不一定是相等的综上，equals方法被覆盖过，则hashCode方法也必须被覆盖hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同comparable 和 comparator的区别？comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().如何对Object的list排序？对objects数组进行排序，我们可以用Arrays.sort()方法对objects的集合进行排序，需要使用Collections.sort()方法如何实现数组与List的相互转换？List转数组:toArray(arraylist.size()方法数组转List:Arrays的asList(a)方法1234567891011121314151617181920212223List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(&quot;s&quot;); arrayList.add(&quot;e&quot;); arrayList.add(&quot;n&quot;); /** * ArrayList转数组 */ int size=arrayList.size(); String[] a = arrayList.toArray(new String[size]); //输出第二个元素 System.out.println(a[1]);//结果：e //输出整个数组 System.out.println(Arrays.toString(a));//结果：[s, e, n] /** * 数组转list */ List&lt;String&gt; list=Arrays.asList(a); /** * list转Arraylist */ List&lt;String&gt; arrayList2 = new ArrayList&lt;String&gt;(); arrayList2.addAll(list); System.out.println(list);如何求ArrayList集合的交集 并集 差集 去重复并集需要用到List接口中定义的几个方法：addAll(Collection&lt;? extends E&gt; c) :按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾retainAll(Collection&lt;?&gt; c): 仅保留此列表中包含在指定集合中的元素。removeAll(Collection&lt;?&gt; c) :从此列表中删除指定集合中包含的所有元素。TIPS: JAVA8中提供了通过lambda方式处理集合，如Collections类中好多工具方法用stream流方式处理，方便了我们在处理集合时的各种情况，JAVA8集合这块再后面的blog中会单独拿出来总结。HashMap 的工作原理及代码实现集合框架源码学习之HashMap(JDK1.8)ConcurrentHashMap 的工作原理及代码实现ConcurrentHashMap实现原理及源码分析集合框架底层数据结构总结CollectionListArraylist：数组（查询快,增删慢 线程不安全,效率高 ）Vector：数组（查询快,增删慢 线程安全,效率低 ）LinkedList：链表（查询慢,增删快 线程不安全,效率高 ）SetHashSet（无序，唯一）:哈希表或者叫散列集(hash table)LinkedHashSet：链表和哈希表组成 。 由链表保证元素的排序 ， 由哈希表证元素的唯一性TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树。)MapHashMap：基于哈希表的Map接口实现（哈希表对键进行散列，Map结构即映射表存放键值对）LinkedHashMap:HashMap 的基础上加上了链表数据结构HashTable:哈希表TreeMap:红黑树（自平衡的排序二叉树）集合的选用主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。","categories":[{"name":"面试","slug":"面试","permalink":"http://www.fufan.me/categories/面试/"}],"tags":[{"name":"java base","slug":"java-base","permalink":"http://www.fufan.me/tags/java-base/"},{"name":"面试","slug":"面试","permalink":"http://www.fufan.me/tags/面试/"},{"name":"collection","slug":"collection","permalink":"http://www.fufan.me/tags/collection/"}]},{"title":"Java面试总结积累（基础篇）之语法问题","slug":"Java面试总结积累（基础篇）之语法问题","date":"2017-01-02T16:34:00.000Z","updated":"2018-10-02T16:38:22.275Z","comments":true,"path":"2017/01/03/Java面试总结积累（基础篇）之语法问题/","link":"","permalink":"http://www.fufan.me/2017/01/03/Java面试总结积累（基础篇）之语法问题/","excerpt":"","text":"java开发经验固然很重要，但是有很多面试当中会遇到一些基础问题，需要自己来进行总结归类，也算是扫盲和回归吧。 面向对象和面向过程的区别面向过程：优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。缺点：没有面向对象易维护、易复用、易扩展面向对象：优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护缺点：性能比面向过程低Java语言有哪些特点？1，简单易学；2，面向对象（封装，继承，多态）；3，平台无关性（Java虚拟机实现平台无关性）；4，可靠性；5，安全性；6，支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；7，支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；8，编译与解释并存；什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？先看下java中的编译器和解释器：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。采用字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。什么是Java虚拟机任何一种可以运行Java字节码的软件均可看成是Java的虚拟机（JVM）字符型常量和字符串常量的区别形式上:字符常量是单引号引起的一个字符字符串常量是双引号引起的若干个字符含义上:字符常量相当于一个整形值(ASCII值),可以参加表达式运算字符串常量代表一个地址值(该字符串在内存中存放位置)占内存大小字符常量只占一个字节字符串常量占若干个字节(至少一个字符结束标志)Java语言采用何种编码方案？有何特点？Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。构造器Constructor是否可被override在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override,但是可以overload,所以你可以看到一个类中有多个构造函数的情况。重载和重写的区别重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。java 面向对象编程三大特性封装、继承、多态String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的可变性String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。线程安全性String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。性能每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。对于三者使用的总结：如果要操作少量的数据用 = String单线程操作字符串缓冲区 下操作大量数据 = StringBuilder多线程操作字符串缓冲区 下操作大量数据 = StringBuffer在一个静态方法内调用一个非静态成员为什么是非法的？由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。在Java中定义一个不做事且没有参数的构造方法的作用Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。接口和抽象类的区别是什么？接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法接口中的实例变量默认是final类型的，而抽象类中则不一定一个类可以实现多个接口，但最多只能实现一个抽象类一个类实现接口的话要实现接口的所有方法，而抽象类不一定接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。成员变量与局部变量的区别有那些？从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。创建一个对象用什么运算符？对象实体与对象引用有何不同？new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）什么是方法的返回值？返回值在类的方法里的作用是什么方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。构造方法有哪些特性？名字与类名相同；没有返回值，但不能用void声明构造函数；生成类的对象时自动执行，无需调用。静态方法和实例方法有何不同？静态方法和实例方法的区别主要体现在两个方面：在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制对象的相等与指向他们的引用相等，两者有什么不同？对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？帮助子类做初始化工作。equals 和 == 的区别？通俗点讲：==是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，==：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。术语来讲的区别：==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同","categories":[{"name":"面试相关","slug":"面试相关","permalink":"http://www.fufan.me/categories/面试相关/"}],"tags":[{"name":"java base","slug":"java-base","permalink":"http://www.fufan.me/tags/java-base/"},{"name":"面试","slug":"面试","permalink":"http://www.fufan.me/tags/面试/"}]},{"title":"（绪）设计模式之架构中的设计原则","slug":"（绪）设计模式之架构中的设计原则","date":"2016-10-11T10:51:00.000Z","updated":"2018-10-02T13:04:49.525Z","comments":true,"path":"2016/10/11/（绪）设计模式之架构中的设计原则/","link":"","permalink":"http://www.fufan.me/2016/10/11/（绪）设计模式之架构中的设计原则/","excerpt":"","text":"在进行软件架构工作时，需要遵循面向对象原则，这些原则同样在各类设计模式、架构模式之中，在学习过程中可以通过类图、时序图、示例代码等形式，不断体会这些原则在解决“依赖”和变化中的效果。当然，这些“原则”的队伍也在变化。不断有新的“原则加入，也有被淘汰掉的，真正沉淀下来的通用的”原则“其实并不多在使用面向对象的思想进行系统设计时，前任总结出了7条原则，分别是单一职责原则、开闭原则、里氏替换原则、依赖注入原则、接口分离原则、迪米特原则和有限使用组合而不是继承原则。下面来介绍下这几种原则的含义，也为后面学习设计模式打下基础。原则一：单一职责原则但以职责原则的核心思想就是：系统中的每一个对象都应该只有一个单独的职责，而所有对象所关注的就是自身职责的完成，全称即Single Responsibility Principle。其实单一职责的意思就是开发人员经常说的”高内聚、低耦合“。也就是说，每一个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都要遵守这个原则。”单一职责“也就是”单一变化原因“。通常一个类的职责越多，导致的变化因素也与阿朵，我们在设计的时候可能会把该类的有关的操作都组合在这个类中，这样做的后果就有可能将多个职责“耦合”到一起。解决这个问题的方法就是“分耦”，将不同的职责分别进行封装，不要将组合在一个类中。例如将用户的属性和用户的行为放在一个接口中声明，如下：12345678910interface User&#123; //身高 public double getHeight(); //体重 public double getWeight(); //吃饭 public void eat(); //玩游戏 public void gaming();&#125;上面的例子就存在这个问题，身高和体重属于业务对象，与之对应的方法主要负责用户的属性，而吃饭和玩游戏是相应的业务逻辑，主要负责用户的行为，这会给人一种不知道这个接口到底是做什么的感觉，职责不清晰，后期维护的时候会造成各种各样的问题。可以将这个接口分为两个。123456interface UserPro&#123; //身高 public double getHeight(); //体重 public double getWeight();&#125;123456interface UserAct&#123; //吃饭 public void eat(); //玩游戏 public void gaming();&#125;然后分别实现这两个接口，这里的实现我就不详细写了，主要通过这种方式可以做到当需要修改用户属性的时候，只需要对UserPro这个接口进行修改，而不会影响到其他类。另外，SRP原则的好处是可以消除耦合，减小因需求变化引起代码僵化的难堪局面。需要注意：一个合理的类，应该仅有一个引起他变化的原因，即单一职责。在没有变化征兆的情况下，应用SRP或其他原则是不明智的。在需求实际发生变化时就应该应用SRP等原则来重构代码。使用测试驱动开发会迫使我们在设计出现劣质趋势之前分离不合理代码如果测试不能迫使职责分离，僵化性和脆弱性的腐朽味会变得很浓烈，那就应该用Facade或者Proxy模式对代码重构原则二：里氏替换原则（LSP）里氏替换原则的核心思想就是：在任何父类出现的地方都可以用他的自雷来替代。它的英文缩写为LSP，全称是Liskov Subsitituition Principle。通俗点讲，就是同一个继承体系中的对象应该有果农共同的行为特征。里氏替换原则关注的是怎样良好地使用继承，也就是说不要滥用继承，它是继承复用的基石。在里氏替换原则中，所有引用基类的地方必须能够透明地使用其子类对象，也就是说，只要父类出现的地方，子类就能出现，而且替换为子类不会产生任何错误或者异常。但是反过来，子类出现的地方，替换为父类就可能出现问题了。主要抓住以下四层含义（子类的范围大于等于父类的范围）：子类必须完全实现父类的方法子类可以有自己的特性覆盖或者实现父类的方法时输入参数可以被放大覆写或者实现父类的方法时输出结果可以被缩小原则三：依赖注入原则（DIP）依赖注入原则的核心思想就是：要依赖于抽象，不要依赖于具体的实现。英文全称就是Dependence Inversion Principle。通俗的讲：在应用程序中，所有的类如果使用或者依赖于其他的类，则都应该依赖于这些其他类的抽象类，而不是这些其他类的具体实现。即要求开发人员在编程时针对接口编程，而不是针对实现编程。依赖注入原则有三点要注意的：高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）。抽象（抽象类或接口）不应该依赖于细节（具体实现类）。细节（具体实现类）应该依赖抽象这里的抽象指的是不能被实例化的抽象类或接口，具体的实现则是可以通过new直接实例化的。这个原则是开闭原则的基础（对扩展开放，对修改关闭）。三种实现方式：通过构造函数传递依赖对象通过setter方法传递依赖对象接口声明实现依赖对象原则四：接口分离原则（ISP）接口分离原则的核心思想就是：不应该强迫客户程序依赖它们不需要使用的方法。它的全称是Interface Segregation Principle。其实接口分离原则的意思就是一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该吧所有的操作都封装到一个接口中。这里的接口不仅是interface关键字的实例，接口分为以下两种：对象接口（object Interface）java中声明一个类，通过new出一个实例，它是对一个类型的事务的描述，这也是一种接口。例如：1Phone phone = new Phone(); //这里的类Phone就是实例Phone的一个接口类接口（Class Interface）这种接口就是通过关键字Interface定义的接口。接口分离原则要求的是在一个模块中应该只依赖它需要的接口，以保证接口的纯洁。切勿定义太臃肿的接口。接口分离原则与但以职责原则有点类似，都是说如何设计接口，不过不同在于单一职责原则要求的是类和接口职责单一，注重的是职责，是业务逻辑上的划分。而接口分离原则要求的是接口的方法尽量少，针对一个模块尽量有用。如何做到该原则：接口尽量小：小的概念是保证一个接口之服务于一个子模块或者业务逻辑接口高内聚：指的是对内高度依赖，对外尽可能隔离。即一个接口内部声明的方法相互之间都与某一个子模块相关，且这个子模块必需的。接口设计是有限度的：话说回来，如果过度地遵循该原则，会使得接口数量剧增，复杂度正价，这并不是我们想要的结果。原则五：迪米特原则（LOD）全称是Law of Demeter。核心思想就是：一个对象应当对其他对象尽可能少地了解。意思就是降低各个对象之间的耦合，提高系统的可维护性。在模块之间，应该只通过接口来通信，而不理会模块的内部工作原理，它可以使各个模块偶和程度降到最低，促进软件的复用。它的核心观念还是类间解耦，弱耦合。举个例子，监狱的犯人是不能随便和外面的人打交道，除非探亲，所以狱警就是这个迪米特法则的执行者，监狱就是类，犯人就是类的内部信息。总结下这个原则要注意的地方：在类的划分上，因可更改创建有弱耦合的类。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。在类的设计上，只要有可能，一个类应当设计成不变类在对其他类的引用上，一个对象对其他对象的引用应当降到最低尽量降低类的访问权限谨慎使用序列化功能不要暴露类成员，而应该提供相应的访问方法（属性getter）原则六：开闭原则（OCP）开闭原则的核心思想：一个对象对扩展开放，对修改关闭。其实开闭原则就是：对类的改动是通过增加代码进行的，而不是改动现有的代码。也就是说，软件开发人员一旦写出了可以运行的代码，就不应该去改变它，而是要保证他一直能运行下去，这就需要借助java的抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现层则是可以改变和扩展的。注意：这些设计原则并不是绝对的，而是应根据项目的实际需求来定夺。","categories":[{"name":"framework","slug":"framework","permalink":"http://www.fufan.me/categories/framework/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://www.fufan.me/tags/design-pattern/"}]},{"title":"JAVA基本数据结构","slug":"JAVA基本数据结构","date":"2016-09-12T15:18:00.000Z","updated":"2018-10-02T13:11:46.149Z","comments":true,"path":"2016/09/12/JAVA基本数据结构/","link":"","permalink":"http://www.fufan.me/2016/09/12/JAVA基本数据结构/","excerpt":"","text":"java基本数据结构其实学一门语言，基础很重要，现在很多java程序员只是对jdk和各种框架特别熟悉，能熟练地使用各种包和api组件，包括现在很多培训都是灌输这些所谓的实际应用。这会导致学到最后只会照葫芦画瓢。java数据结构的只是体系包括线性表、树、数组、集合、矩阵、排序、查找、哈希表，并将java的设计思想、方法及一些常见的算法、设计模式贯穿其中。其中线性表、链表、哈希表是最为常用的数据结构，在进行java开发时，jdk已经为我们提供了一系列相应的类，如下图。来实现基本的数据结构。这些类均在java.util包中。CollectionListLinkedListArrayListVector(Stack)SetQueueMapHashtableHashMapWeakHashMapCollection接口接口Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。主要分为两类，LIst和Set，它们是以是否允许有相同元素来区分。当然其结构也不同。所有实现Collection接口的类都必须提供两个标准的构造函数。无参为空，有参则可复制一个传入的Collection。如何遍历？可以通过迭代器iterator()方法，注意访问Collection中的每一个元素，这种方式也是所有继承于它的类都可以使用的遍历方式。12345Collection collection = new ArrayList&lt;String&gt;();Iterator i = collection.iterator();while(i.hasNext())&#123; Object s = i.next();&#125;它的派生类包括List和Set，以下是他接口中的主要方法：boolean add(Object o)：用于添加对象到集合boolean remove(Object o)：用于删除指定的对象int size()：用于返回当前集合中元素的个数boolean isEmpty()：用于判断集合是否为空。Iterator iterator()：返回一个迭代器boolean contains(Object o)：用于查找集合中是否有指定的对象boolean containsAll(Collection c)：用于查找集合中是否有集合c中的元素boolean addAll（Collection c）：用于将集合c中的元素全部添加到该集合中void clear()：用于清空该集合void removeAll(Collection c)：用于从集合中删除从集合中所有的元素void retainAll(Collection c)：从集合中删除集合c中不包含的元素List接口List是有序的Collection，用户能够使用索引来访问List中的元素，类似数组。LIst包括以下几种子类ArrayList:：是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。LinkedList：是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率高，但随机插入、随机删除效率低。Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。(01) 对于需要快速插入，删除元素，应该使用LinkedList。(02) 对于需要快速随机访问元素，应该使用ArrayList。(03)对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。通过下面的测试程序，我们来验证上面的(01)和(02)结论。参考代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.*;import java.lang.Class;/* * @desc 对比ArrayList和LinkedList的插入、随机读取效率、删除的效率 * * @author skywang */public class ListCompareTest &#123; private static final int COUNT = 100000; private static LinkedList linkedList = new LinkedList(); private static ArrayList arrayList = new ArrayList(); private static Vector vector = new Vector(); private static Stack stack = new Stack(); public static void main(String[] args) &#123; // 换行符 System.out.println(&quot;插入元素&quot;); // 插入 insertByPosition(stack) ; insertByPosition(vector) ; insertByPosition(linkedList) ; insertByPosition(arrayList) ; // 换行符 System.out.println(&quot;随机读取&quot;); // 随机读取 readByPosition(stack); readByPosition(vector); readByPosition(linkedList); readByPosition(arrayList); // 换行符 System.out.println(&quot;删除元素&quot;); // 删除 deleteByPosition(stack); deleteByPosition(vector); deleteByPosition(linkedList); deleteByPosition(arrayList); &#125; // 获取list的名称 private static String getListName(List list) &#123; if (list instanceof LinkedList) &#123; return &quot;LinkedList&quot;; &#125; else if (list instanceof ArrayList) &#123; return &quot;ArrayList&quot;; &#125; else if (list instanceof Stack) &#123; return &quot;Stack&quot;; &#125; else if (list instanceof Vector) &#123; return &quot;Vector&quot;; &#125; else &#123; return &quot;List&quot;; &#125; &#125; // 向list的指定位置插入COUNT个元素，并统计时间 private static void insertByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 向list的位置0插入COUNT个数 for (int i=0; i&lt;COUNT; i++) list.add(0, i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot; : insert &quot;+COUNT+&quot; elements into the 1st position use time：&quot; + interval+&quot; ms&quot;); &#125; // 从list的指定位置删除COUNT个元素，并统计时间 private static void deleteByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 删除list第一个位置元素 for (int i=0; i&lt;COUNT; i++) list.remove(0); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot; : delete &quot;+COUNT+&quot; elements from the 1st position use time：&quot; + interval+&quot; ms&quot;); &#125; // 根据position，不断从list中读取元素，并统计时间 private static void readByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 读取list元素 for (int i=0; i&lt;COUNT; i++) list.get(i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot; : read &quot;+COUNT+&quot; elements by position use time：&quot; + interval+&quot; ms&quot;); &#125;&#125;运行结果如下：插入元素Stack : insert 100000 elements into the 1st position use time：1544 msVector : insert 100000 elements into the 1st position use time：1520 msLinkedList : insert 100000 elements into the 1st position use time：17 msArrayList : insert 100000 elements into the 1st position use time：1519 ms随机读取Stack : read 100000 elements by position use time：7 msVector : read 100000 elements by position use time：7 msLinkedList : read 100000 elements by position use time：8023 msArrayList : read 100000 elements by position use time：2 ms删除元素Stack : delete 100000 elements from the 1st position use time：1553 msVector : delete 100000 elements from the 1st position use time：1525 msLinkedList : delete 100000 elements from the 1st position use time：9 msArrayList : delete 100000 elements from the 1st position use time：1547 ms这里只是对性能做了大致的测试，如果需要研究为何产生如此差异，需要看下数据结构的相关资料。Set接口Set接口是一种不包含重复元素的Collection，也就是说任何两个在Set里面的元素都存在以下e1.equals(e2) == false关系，且Set最多只有一个NULL元素。很明显，Set的构造函数有一个约束条件，就是传入的Collection参数不能包含重复的元素。Queue接口Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Queue接 口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。BlockingQueue 继承了Queue接口。队列是一种数据结构．它有两个基本操作：在队列尾部加人一个元素，和从队列头部移除一个元素就是说，队列以一种先进先出的方式管理数据，如果你试图向一个 已经满了的阻塞队列中添加一个元素或者是从一个空的阻塞队列中移除一个元索，将导致线程阻塞．在多线程进行合作时，阻塞队列是很有用的工具。工作者线程可 以定期地把中间结果存到阻塞队列中而其他工作者线线程把中间结果取出并在将来修改它们。队列会自动平衡负载。如果第一个线程集运行得比第二个慢，则第二个 线程集在等待结果时就会阻塞。如果第一个线程集运行得快，那么它将等待第二个线程集赶上来。下表显示了jdk1.5中的阻塞队列的操作：add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常offer 添加一个元素并返回true 如果队列已满，则返回falsepoll 移除并返问队列头部的元素 如果队列为空，则返回nullpeek 返回队列头部的元素 如果队列为空，则返回nullput 添加一个元素 如果队列满，则阻塞take 移除并返回队列头部的元素 如果队列为空，则阻塞remove、element、offer 、poll、peek 其实是属于Queue接口。Map接口Map接口没有继承于接口Collection，Map提供key到value的映射。键值对key-value，主要方法如下：boolean equals(Object o)：用于比较对象boolean remove(Object o)：用于删除一个对象void put(Object key, Object value)：用于添加key和valueMap可分为HashMap、HashTable、WeakHashMap、ConcurrentHashMap等。但是我们常用的主要是HashMap和HashTable，下面比较下两者区别：HashMap是非线程安全的，HashTable是线程安全的。HashMap的键和值都允许有null值存在，而HashTable则不行。因为线程安全的问题，HashMap效率比HashTable的要高。能答出上面的三点，简单的面试，算是过了，但是如果再问：Java中的另一个线程安全的与HashMap及其类似的类是什么？(ConcurrentHashMap)同样是线程安全，它与HashTable在线程同步上有什么不同？(synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，锁住的都是对象整体，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象)能把第二个问题完整的答出来，说明你的基础算是不错的了。下面浅析更多区别。HashMap1) hashmap的数据结构Hashmap是一个数组和链表的结合体（在数据结构称“链表散列“），如下图示：当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。2)使用和遍历1234567891011Map map = new HashMap();map.put(&quot;Rajib Sarma&quot;,&quot;100&quot;);map.put(&quot;Rajib Sarma&quot;,&quot;200&quot;);//The value &quot;100&quot; is replaced by &quot;200&quot;.map.put(&quot;Sazid Ahmed&quot;,&quot;200&quot;);Iterator iter = map.entrySet().iterator();while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue();&#125;HashTable和HashMap区别继承不同。public class Hashtable extends Dictionary implements Mappublic class HashMap extends AbstractMap implements MapHashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。","categories":[{"name":"java base","slug":"java-base","permalink":"http://www.fufan.me/categories/java-base/"}],"tags":[{"name":"java 数据结构","slug":"java-数据结构","permalink":"http://www.fufan.me/tags/java-数据结构/"}]},{"title":"JAVA的Reflection反射机制","slug":"JAVA的Reflection反射机制","date":"2016-09-11T06:55:00.000Z","updated":"2018-10-02T13:09:10.315Z","comments":true,"path":"2016/09/11/JAVA的Reflection反射机制/","link":"","permalink":"http://www.fufan.me/2016/09/11/JAVA的Reflection反射机制/","excerpt":"","text":"反射即reflectionjava反射运用了代理模式，代理模式在之后学习的设计模式中可以了解反射主要用了以下几点：在运行时判断任意一个对象所属的类。在运行时构造任意一个类的对象。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法Class首先要搞清楚Class这个类，每个类在创建的时候都会有Class这个类伴随产生，这个Class是JVM产生的，由于是JVM产生的，所以我们一般获取Class的方法是：object.getClass()Class.forName(“java.lang.String”)Class.getSuperClass()运用.class语法,如java.lang.String.classprimitive wrapper classes的TYPE语法,如：Boolean.TYPE，类似Boolean.class12345Class&lt;?&gt; clazz = s.getClass();Class&lt;?&gt; clazz2 = Class.forName(&quot;com.fufan.reflection.Son&quot;);Class&lt;?&gt; clazz3 = clazz2.getSuperclass();Class&lt;?&gt; clazz4 = com.fufan.reflection.Son.class;Class&lt;?&gt; clazz5 = Boolean.class;Class是Reflection起源。针对任何您想探勘的class，唯有先为它产生一个Class object，接下来才能经由后者唤起为数十多个的Reflection APIs接下来就可以通过Class调用衍生出的一系列API：getName()：获得类的完整名字。getFields()：获得类的public类型的属性。getDeclaredFields()：获得类的所有属性。getMethods()：获得类的public类型的方法。getDeclaredMethods()：获得类的所有方法。getConstructors()：获得类的public类型的构造方法。getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。getConstructors()：获得类的public类型的构造方法。getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。FieldFiled类：代表类的成员变量（成员变量也称为类的属性）。1String fieldName = field.getName();MethodMethod类：代表类的方法，invoke1Object value = getMethod.invoke(object, new Object[] &#123;&#125;);ConstructorConstructor类：代表类的构造方法，调用有参和无参newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。newInstance(new Object[]{value})：当调用有参构造函数时使用。12345//无参构造方法Constructor constructor1 = classType.getConstructor();//有参构造方法Constructor constructor2 = classType.getConstructor(new Class[] &#123;int.class, String.class&#125;);代码示例11234567891011121314151617181920212223242526272829// 获得对象的类型 Class&lt;?&gt; classType = object.getClass(); System.out.println(&quot;Class:&quot; + classType.getName()); // 通过默认构造方法创建一个新的对象 Object objectCopy = classType.getConstructor(new Class[] &#123;&#125;).newInstance(new Object[] &#123;&#125;); // 获得对象的所有属性 Field fields[] = classType.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; String fieldName = field.getName(); String firstLetter = fieldName.substring(0, 1).toUpperCase(); // 获得和属性对应的getXXX()方法的名字 String getMethodName = &quot;get&quot; + firstLetter + fieldName.substring(1); // 获得和属性对应的setXXX()方法的名字 String setMethodName = &quot;set&quot; + firstLetter + fieldName.substring(1); // 获得和属性对应的getXXX()方法 Method getMethod = classType.getMethod(getMethodName, new Class[] &#123;&#125;); // 获得和属性对应的setXXX()方法 Method setMethod = classType.getMethod(setMethodName, new Class[] &#123; field.getType() &#125;); // 调用原对象的getXXX()方法 Object value = getMethod.invoke(object, new Object[] &#123;&#125;); System.out.println(fieldName + &quot;:&quot; + value); // 调用拷贝对象的setXXX()方法 setMethod.invoke(objectCopy, new Object[] &#123; value &#125;);&#125;ArrayArray类：提供了动态创建数组，以及访问数组的元素的静态方法代码示例2123456789101112131415161718//一维数组的使用Object array = Array.newInstance(Integer.TYPE, 10);System.out.println(Integer.TYPE);for(int index=1; index&lt;10; index ++)&#123; Array.set(array, index, index);&#125;System.out.println(Array.get(array, 4));//多维数组的使用Object arrays = Array.newInstance(String.class, 3,5);Object array1 = Array.get(arrays, 2);Array.set(array1, 3, &quot;fufan&quot;);String[][] arrayInt = (String[][]) arrays; System.out.println(arrayInt[1][3]);","categories":[{"name":"java base","slug":"java-base","permalink":"http://www.fufan.me/categories/java-base/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.fufan.me/tags/java/"}]}]}