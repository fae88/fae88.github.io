<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Gemini Boy</title>
  
  <subtitle>welcome to my site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fufan.me/"/>
  <updated>2018-10-02T12:58:29.733Z</updated>
  <id>http://www.fufan.me/</id>
  
  <author>
    <name>fae88</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的vim命令整理（持续更新）</title>
    <link href="http://www.fufan.me/2018/10/02/%E5%B8%B8%E7%94%A8%E7%9A%84vim%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://www.fufan.me/2018/10/02/常用的vim命令整理（持续更新）/</id>
    <published>2018-10-02T12:58:26.000Z</published>
    <updated>2018-10-02T12:58:29.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --><h2 id="1-插入模式-command-mode"><a href="#1-插入模式-command-mode" class="headerlink" title="1. 插入模式 (command mode)"></a>1. 插入模式 (command mode)</h2><p>命令模式切换至插入状态</p><ul><li>i光标前插入</li><li>I行首插入</li><li>a光标后插入</li><li>A行尾插入</li><li>o行上新行</li><li>O行下新行</li></ul><h2 id="2-命令模式-insert-mode"><a href="#2-命令模式-insert-mode" class="headerlink" title="2. 命令模式 (insert mode)"></a>2. 命令模式 (insert mode)</h2><p>ESC从插入状态切换至命令模式</p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li>h左移</li><li>j下移</li><li>k上移</li><li>l右移</li><li>H到屏幕顶部</li><li>M到屏幕中央</li><li>L到屏幕底部</li><li>0到行首</li><li>$到行尾</li><li>Ctrl+f向前翻屏</li><li>Ctrl+b向后翻屏</li><li>Ctrl+d向前翻半屏</li><li>Ctrl+u向后翻半屏</li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul><li>gg回到文件首行,</li><li>G回到文件尾行</li><li>:n和nG光标定位到文件第n行(:20或20G表示光标定位到第20行)</li><li>:set nu 或:set number显示行号,</li><li>:set nonu 取消显示行号</li><li>ctrl+g</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>x删除光标所在字符(与Delete键相同的方向),</li><li>X删除光标所在字符(与Backspace键相同的方向)</li><li>nx删除光标后n个字符</li><li>dd删除光标所在行</li><li>ndd删除光标所在行以后的n行</li><li>D删除光标到行尾的内容</li><li>dG删除光标所在行到文件末尾的内容</li><li>n1,n2d删除行n1到行n2的内容，包括第n1和n2行都被删除</li><li>s删除一个字符来插入模式</li><li>S删除当前行以插入模式</li></ul><h3 id="复制、剪切、粘贴、替换"><a href="#复制、剪切、粘贴、替换" class="headerlink" title="复制、剪切、粘贴、替换"></a>复制、剪切、粘贴、替换</h3><ul><li>yy或Y复制当前行</li><li>nyy或nY从当前行开始赋值n行</li><li>ggVG全选</li><li>剪切使用dd和ndd，相当于删除</li><li>p在光标所在行之后粘贴</li><li>P在光标所在行之前粘贴</li><li>r替换当前字符后回到命令模式</li><li>R一直替换知道通过ESC回到命令模式</li></ul><h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ul><li>\KeyWord回车，n查找下一处</li><li>?KeyWord回车，n查找上一处</li><li>n重复相同方向</li><li>N重复反向方向·</li><li>:s/old/new/g替换整个文件，不确认</li><li>:s/old/new/gc替换整个文件，确认</li><li>:n1,n2s/old/new/g替换n1-n2行中匹配内容，不确认</li></ul><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>u</p><h3 id="保存及离开"><a href="#保存及离开" class="headerlink" title="保存及离开"></a>保存及离开</h3><ul><li>:w保存文件</li><li>:w!强制保存</li><li>:w file将修改另外保存到file</li><li>:wq保存文件并退出</li><li>:wq!强制保存文件并退出</li><li>:q不保存退出</li><li>:q!不保存强制退出</li><li>:e!放弃所有修改，从上次保存文件开始再编辑</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;1-插入模式-command-mode&quot;&gt;&lt;a href=&quot;#1-插入模式-command-mode&quot; class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ssh免密码登录步骤及别名设置</title>
    <link href="http://www.fufan.me/2018/10/02/ssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%88%AB%E5%90%8D%E8%AE%BE%E7%BD%AE/"/>
    <id>http://www.fufan.me/2018/10/02/ssh免密码登录步骤及别名设置/</id>
    <published>2018-10-02T05:23:00.000Z</published>
    <updated>2018-10-02T05:45:00.655Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --><h2 id="ssh免密码登录步骤及别名设置"><a href="#ssh免密码登录步骤及别名设置" class="headerlink" title="ssh免密码登录步骤及别名设置"></a>ssh免密码登录步骤及别名设置</h2><h5 id="1-生成本机的公私钥"><a href="#1-生成本机的公私钥" class="headerlink" title="1. 生成本机的公私钥"></a>1. 生成本机的公私钥</h5><p><code>ssh-keygen -t rsa</code></p><h5 id="2-将公钥复制到目标机器上"><a href="#2-将公钥复制到目标机器上" class="headerlink" title="2. 将公钥复制到目标机器上"></a>2. 将公钥复制到目标机器上</h5><p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.100</code></p><h5 id="3-设置别名登录"><a href="#3-设置别名登录" class="headerlink" title="3. 设置别名登录"></a>3. 设置别名登录</h5><p><code>vim ~/.ssh/config</code></p><p>添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host 100</span><br><span class="line">HostName 192.168.0.100</span><br><span class="line">Port 22</span><br><span class="line">User root</span><br><span class="line">IdentityFile ~/.ssh/id_rsa.pub</span><br><span class="line">IdentitiesOnly yes</span><br></pre></td></tr></table></figure><h5 id="4-登录"><a href="#4-登录" class="headerlink" title="4. 登录"></a>4. 登录</h5><p><code>ssh 100</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;ssh免密码登录步骤及别名设置&quot;&gt;&lt;a href=&quot;#ssh免密码登录步骤及别名设置&quot; class=&quot;header
      
    
    </summary>
    
      <category term="linux" scheme="http://www.fufan.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.fufan.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>（绪）设计模式之架构中的设计原则</title>
    <link href="http://www.fufan.me/2016/10/11/%EF%BC%88%E7%BB%AA%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://www.fufan.me/2016/10/11/（绪）设计模式之架构中的设计原则/</id>
    <published>2016-10-11T10:51:00.000Z</published>
    <updated>2018-10-02T13:04:49.525Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --><p>在进行软件架构工作时，需要遵循面向对象原则，这些原则同样在各类设计模式、架构模式之中，在学习过程中可以通过类图、时序图、示例代码等形式，不断体会这些原则在解决“依赖”和变化中的效果。当然，这些“原则”的队伍也在变化。不断有新的“原则加入，也有被淘汰掉的，真正沉淀下来的通用的”原则“其实并不多</p><p>在使用面向对象的思想进行系统设计时，前任总结出了7条原则，分别是单一职责原则、开闭原则、里氏替换原则、依赖注入原则、接口分离原则、迪米特原则和有限使用组合而不是继承原则。下面来介绍下这几种原则的含义，也为后面学习设计模式打下基础。</p><h4 id="原则一：单一职责原则"><a href="#原则一：单一职责原则" class="headerlink" title="原则一：单一职责原则"></a>原则一：单一职责原则</h4><p>但以职责原则的核心思想就是：系统中的每一个对象都应该只有一个单独的职责，而所有对象所关注的就是自身职责的完成，全称即Single Responsibility Principle。</p><p>其实单一职责的意思就是开发人员经常说的”<strong>高内聚、低耦合</strong>“。也就是说，每一个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都要遵守这个原则。</p><p>”单一职责“也就是”单一变化原因“。通常一个类的职责越多，导致的变化因素也与阿朵，我们在设计的时候可能会把该类的有关的操作都组合在这个类中，这样做的后果就有可能将多个职责“<strong>耦合</strong>”到一起。解决这个问题的方法就是“分耦”，将不同的职责分别进行封装，不要将组合在一个类中。例如将用户的属性和用户的行为放在一个接口中声明，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface User&#123;</span><br><span class="line">//身高</span><br><span class="line">public double getHeight();</span><br><span class="line">//体重</span><br><span class="line">public double getWeight();</span><br><span class="line">//吃饭</span><br><span class="line">public void eat();</span><br><span class="line">//玩游戏</span><br><span class="line">public void gaming();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子就存在这个问题，身高和体重属于业务对象，与之对应的方法主要负责用户的属性，而吃饭和玩游戏是相应的业务逻辑，主要负责用户的行为，这会给人一种不知道这个接口到底是做什么的感觉，职责不清晰，后期维护的时候会造成各种各样的问题。可以将这个接口分为两个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UserPro&#123;</span><br><span class="line">//身高</span><br><span class="line">public double getHeight();</span><br><span class="line">//体重</span><br><span class="line">public double getWeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UserAct&#123;</span><br><span class="line">//吃饭</span><br><span class="line">public void eat();</span><br><span class="line">//玩游戏</span><br><span class="line">public void gaming();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后分别实现这两个接口，这里的实现我就不详细写了，主要通过这种方式可以做到当需要修改用户属性的时候，只需要对UserPro这个接口进行修改，而不会影响到其他类。</p><p>另外，SRP原则的好处是可以消除耦合，减小因需求变化引起代码僵化的难堪局面。需要注意：</p><ul><li>一个合理的类，应该仅有一个引起他变化的原因，即单一职责。</li><li>在没有变化征兆的情况下，应用SRP或其他原则是不明智的。</li><li>在需求实际发生变化时就应该应用SRP等原则来重构代码。</li><li>使用测试驱动开发会迫使我们在设计出现劣质趋势之前分离不合理代码</li><li>如果测试不能迫使职责分离，僵化性和脆弱性的腐朽味会变得很浓烈，那就应该用Facade或者Proxy模式对代码重构</li></ul><h4 id="原则二：里氏替换原则（LSP）"><a href="#原则二：里氏替换原则（LSP）" class="headerlink" title="原则二：里氏替换原则（LSP）"></a>原则二：里氏替换原则（LSP）</h4><p>里氏替换原则的核心思想就是：在任何父类出现的地方都可以用他的自雷来替代。它的英文缩写为LSP，全称是Liskov Subsitituition Principle。</p><p>通俗点讲，就是同一个继承体系中的对象应该有果农共同的行为特征。里氏替换原则关注的是怎样良好地使用继承，也就是说不要滥用继承，它是继承复用的基石。在里氏替换原则中，所有引用基类的地方必须能够透明地使用其子类对象，也就是说，只要父类出现的地方，子类就能出现，而且替换为子类不会产生任何错误或者异常。但是反过来，子类出现的地方，替换为父类就可能出现问题了。</p><p>主要抓住以下四层含义（子类的范围大于等于父类的范围）：</p><ol><li>子类必须完全实现父类的方法</li><li>子类可以有自己的特性</li><li>覆盖或者实现父类的方法时输入参数可以被放大</li><li>覆写或者实现父类的方法时输出结果可以被缩小</li></ol><h4 id="原则三：依赖注入原则（DIP）"><a href="#原则三：依赖注入原则（DIP）" class="headerlink" title="原则三：依赖注入原则（DIP）"></a>原则三：依赖注入原则（DIP）</h4><p>依赖注入原则的核心思想就是：要依赖于抽象，不要依赖于具体的实现。英文全称就是Dependence Inversion Principle。</p><p>通俗的讲：在应用程序中，所有的类如果使用或者依赖于其他的类，则都应该依赖于这些其他类的抽象类，而不是这些其他类的具体实现。即要求开发人员在编程时针对接口编程，而不是针对实现编程。</p><p>依赖注入原则有三点要注意的：</p><ol><li>高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）。</li><li>抽象（抽象类或接口）不应该依赖于细节（具体实现类）。</li><li>细节（具体实现类）应该依赖抽象</li></ol><p>这里的抽象指的是不能被实例化的抽象类或接口，具体的实现则是可以通过new直接实例化的。这个原则是开闭原则的基础（对扩展开放，对修改关闭）。</p><p>三种实现方式：</p><ol><li>通过构造函数传递依赖对象</li><li>通过setter方法传递依赖对象</li><li>接口声明实现依赖对象</li></ol><h4 id="原则四：接口分离原则（ISP）"><a href="#原则四：接口分离原则（ISP）" class="headerlink" title="原则四：接口分离原则（ISP）"></a>原则四：接口分离原则（ISP）</h4><p>接口分离原则的核心思想就是：不应该强迫客户程序依赖它们不需要使用的方法。它的全称是Interface Segregation Principle。其实接口分离原则的意思就是一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该吧所有的操作都封装到一个接口中。<br>这里的接口不仅是interface关键字的实例，接口分为以下两种：</p><ol><li>对象接口（object Interface）<br>java中声明一个类，通过new出一个实例，它是对一个类型的事务的描述，这也是一种接口。例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Phone phone = new Phone(); //这里的类Phone就是实例Phone的一个接口</span><br></pre></td></tr></table></figure><ol start="2"><li>类接口（Class Interface）<br>这种接口就是通过关键字Interface定义的接口。</li></ol><p>接口分离原则要求的是在一个模块中应该只依赖它需要的接口，以保证接口的纯洁。切勿定义太臃肿的接口。<br>接口分离原则与但以职责原则有点类似，都是说如何设计接口，不过不同在于单一职责原则要求的是类和接口职责单一，注重的是职责，是业务逻辑上的划分。而接口分离原则要求的是接口的方法尽量少，针对一个模块尽量有用。</p><p>如何做到该原则：</p><ol><li>接口尽量小：小的概念是保证一个接口之服务于一个子模块或者业务逻辑</li><li>接口高内聚：指的是对内高度依赖，对外尽可能隔离。即一个接口内部声明的方法相互之间都与某一个子模块相关，且这个子模块必需的。</li><li>接口设计是有限度的：话说回来，如果过度地遵循该原则，会使得接口数量剧增，复杂度正价，这并不是我们想要的结果。</li></ol><h4 id="原则五：迪米特原则（LOD）"><a href="#原则五：迪米特原则（LOD）" class="headerlink" title="原则五：迪米特原则（LOD）"></a>原则五：迪米特原则（LOD）</h4><p>全称是Law of Demeter。核心思想就是：一个对象应当对其他对象尽可能少地了解。意思就是降低各个对象之间的耦合，提高系统的可维护性。在模块之间，应该只通过接口来通信，而不理会模块的内部工作原理，它可以使各个模块偶和程度降到最低，促进软件的复用。</p><p>它的核心观念还是类间解耦，弱耦合。举个例子，监狱的犯人是不能随便和外面的人打交道，除非探亲，所以狱警就是这个迪米特法则的执行者，监狱就是类，犯人就是类的内部信息。</p><p>总结下这个原则要注意的地方：</p><ul><li>在类的划分上，因可更改创建有弱耦合的类。</li><li>在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</li><li>在类的设计上，只要有可能，一个类应当设计成不变类</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</li><li>尽量降低类的访问权限</li><li>谨慎使用序列化功能</li><li>不要暴露类成员，而应该提供相应的访问方法（属性getter）</li></ul><h4 id="原则六：开闭原则（OCP）"><a href="#原则六：开闭原则（OCP）" class="headerlink" title="原则六：开闭原则（OCP）"></a>原则六：开闭原则（OCP）</h4><p>开闭原则的核心思想：一个对象对扩展开放，对修改关闭。<br>其实开闭原则就是：对类的改动是通过增加代码进行的，而不是改动现有的代码。也就是说，软件开发人员一旦写出了可以运行的代码，就不应该去改变它，而是要保证他一直能运行下去，这就需要借助java的抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现层则是可以改变和扩展的。</p><p>注意：这些设计原则并不是绝对的，而是应根据项目的实际需求来定夺。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在进行软件架构工作时，需要遵循面向对象原则，这些原则同样在各类设计模式、架构模式之中，在学习过程中可以通过类图、时序图、示例
      
    
    </summary>
    
      <category term="framework" scheme="http://www.fufan.me/categories/framework/"/>
    
    
      <category term="design pattern" scheme="http://www.fufan.me/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基本数据结构</title>
    <link href="http://www.fufan.me/2016/09/12/JAVA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.fufan.me/2016/09/12/JAVA基本数据结构/</id>
    <published>2016-09-12T15:18:00.000Z</published>
    <updated>2018-10-02T13:11:46.149Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --><h2 id="java基本数据结构"><a href="#java基本数据结构" class="headerlink" title="java基本数据结构"></a>java基本数据结构</h2><p>其实学一门语言，基础很重要，现在很多java程序员只是对jdk和各种框架特别熟悉，能熟练地使用各种包和api组件，包括现在很多培训都是灌输这些所谓的实际应用。这会导致学到最后只会照葫芦画瓢。</p><p>java数据结构的只是体系包括线性表、树、数组、集合、矩阵、排序、查找、哈希表，并将java的设计思想、方法及一些常见的算法、设计模式贯穿其中。</p><p>其中线性表、链表、哈希表是最为常用的数据结构，在进行java开发时，jdk已经为我们提供了一系列相应的类，如下图。来实现基本的数据结构。这些类均在java.util包中。</p><p><strong>Collection</strong></p><ul><li>List<ul><li>LinkedList</li><li>ArrayList</li><li>Vector(Stack)</li></ul></li><li>Set</li><li>Queue</li></ul><p><strong>Map</strong></p><ul><li>Hashtable</li><li>HashMap</li><li>WeakHashMap</li></ul><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>接口Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。主要分为两类，LIst和Set，它们是以是否允许有相同元素来区分。当然其结构也不同。</p><p>所有实现Collection接口的类都必须提供两个标准的构造函数。无参为空，有参则可复制一个传入的Collection。</p><p>如何遍历？可以通过迭代器iterator()方法，注意访问Collection中的每一个元素，这种方式也是所有继承于它的类都可以使用的遍历方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection collection = new ArrayList&lt;String&gt;();</span><br><span class="line">Iterator i = collection.iterator();</span><br><span class="line">while(i.hasNext())&#123;</span><br><span class="line">Object s = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的派生类包括List和Set，以下是他接口中的主要方法：</p><ul><li>boolean add(Object o)：用于添加对象到集合</li><li>boolean remove(Object o)：用于删除指定的对象</li><li>int size()：用于返回当前集合中元素的个数</li><li>boolean isEmpty()：用于判断集合是否为空。</li><li>Iterator iterator()：返回一个迭代器</li><li>boolean contains(Object o)：用于查找集合中是否有指定的对象</li><li>boolean containsAll(Collection c)：用于查找集合中是否有集合c中的元素</li><li>boolean addAll（Collection c）：用于将集合c中的元素全部添加到该集合中</li><li>void clear()：用于清空该集合</li><li>void removeAll(Collection c)：用于从集合中删除从集合中所有的元素</li><li>void retainAll(Collection c)：从集合中删除集合c中不包含的元素</li></ul><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>List是有序的Collection，用户能够使用索引来访问List中的元素，类似数组。</p><p>LIst包括以下几种子类</p><ol><li>ArrayList:：是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。</li><li>LinkedList：是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率高，但随机插入、随机删除效率低。</li><li>Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。</li><li>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</li></ol><p>如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。<br>(01) 对于需要快速插入，删除元素，应该使用LinkedList。<br>(02) 对于需要快速随机访问元素，应该使用ArrayList。<br>(03)<br>对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。<br>对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。<br>通过下面的测试程序，我们来验证上面的(01)和(02)结论。参考代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Class;</span><br><span class="line">/*</span><br><span class="line"> * @desc 对比ArrayList和LinkedList的插入、随机读取效率、删除的效率</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> */</span><br><span class="line">public class ListCompareTest &#123;</span><br><span class="line">    private static final int COUNT = 100000;</span><br><span class="line">    private static LinkedList linkedList = new LinkedList();</span><br><span class="line">    private static ArrayList arrayList = new ArrayList();</span><br><span class="line">    private static Vector vector = new Vector();</span><br><span class="line">    private static Stack stack = new Stack();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 换行符</span><br><span class="line">        System.out.println(&quot;插入元素&quot;);</span><br><span class="line">        // 插入</span><br><span class="line">        insertByPosition(stack) ;</span><br><span class="line">        insertByPosition(vector) ;</span><br><span class="line">        insertByPosition(linkedList) ;</span><br><span class="line">        insertByPosition(arrayList) ;</span><br><span class="line">        // 换行符</span><br><span class="line">        System.out.println(&quot;随机读取&quot;);</span><br><span class="line">        // 随机读取</span><br><span class="line">        readByPosition(stack);</span><br><span class="line">        readByPosition(vector);</span><br><span class="line">        readByPosition(linkedList);</span><br><span class="line">        readByPosition(arrayList);</span><br><span class="line">        // 换行符</span><br><span class="line">        System.out.println(&quot;删除元素&quot;);</span><br><span class="line">        // 删除 </span><br><span class="line">        deleteByPosition(stack);</span><br><span class="line">        deleteByPosition(vector);</span><br><span class="line">        deleteByPosition(linkedList);</span><br><span class="line">        deleteByPosition(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取list的名称</span><br><span class="line">    private static String getListName(List list) &#123;</span><br><span class="line">        if (list instanceof LinkedList) &#123;</span><br><span class="line">            return &quot;LinkedList&quot;;</span><br><span class="line">        &#125; else if (list instanceof ArrayList) &#123;</span><br><span class="line">            return &quot;ArrayList&quot;;</span><br><span class="line">        &#125; else if (list instanceof Stack) &#123;</span><br><span class="line">            return &quot;Stack&quot;;</span><br><span class="line">        &#125; else if (list instanceof Vector) &#123;</span><br><span class="line">            return &quot;Vector&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;List&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 向list的指定位置插入COUNT个元素，并统计时间</span><br><span class="line">    private static void insertByPosition(List list) &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        // 向list的位置0插入COUNT个数</span><br><span class="line">        for (int i=0; i&lt;COUNT; i++)</span><br><span class="line">            list.add(0, i);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        long interval = endTime - startTime;</span><br><span class="line">        System.out.println(getListName(list) + &quot; : insert &quot;+COUNT+&quot; elements into the 1st position use time：&quot; + interval+&quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 从list的指定位置删除COUNT个元素，并统计时间</span><br><span class="line">    private static void deleteByPosition(List list) &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        // 删除list第一个位置元素</span><br><span class="line">        for (int i=0; i&lt;COUNT; i++)</span><br><span class="line">            list.remove(0);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        long interval = endTime - startTime;</span><br><span class="line">        System.out.println(getListName(list) + &quot; : delete &quot;+COUNT+&quot; elements from the 1st position use time：&quot; + interval+&quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据position，不断从list中读取元素，并统计时间</span><br><span class="line">    private static void readByPosition(List list) &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        // 读取list元素</span><br><span class="line">        for (int i=0; i&lt;COUNT; i++)</span><br><span class="line">            list.get(i);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        long interval = endTime - startTime;</span><br><span class="line">        System.out.println(getListName(list) + &quot; : read &quot;+COUNT+&quot; elements by position use time：&quot; + interval+&quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br>插入元素<br>Stack : insert 100000 elements into the 1st position use time：1544 ms<br>Vector : insert 100000 elements into the 1st position use time：1520 ms<br>LinkedList : insert 100000 elements into the 1st position use time：17 ms<br>ArrayList : insert 100000 elements into the 1st position use time：1519 ms<br>随机读取<br>Stack : read 100000 elements by position use time：7 ms<br>Vector : read 100000 elements by position use time：7 ms<br>LinkedList : read 100000 elements by position use time：8023 ms<br>ArrayList : read 100000 elements by position use time：2 ms<br>删除元素<br>Stack : delete 100000 elements from the 1st position use time：1553 ms<br>Vector : delete 100000 elements from the 1st position use time：1525 ms<br>LinkedList : delete 100000 elements from the 1st position use time：9 ms<br>ArrayList : delete 100000 elements from the 1st position use time：1547 ms</p><p>这里只是对性能做了大致的测试，如果需要研究为何产生如此差异，需要看下数据结构的相关资料。</p><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>Set接口是一种不包含重复元素的Collection，也就是说任何两个在Set里面的元素都存在以下e1.equals(e2) == false关系，且Set最多只有一个NULL元素。很明显，Set的构造函数有一个约束条件，就是传入的Collection参数不能包含重复的元素。</p><h4 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h4><p>Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Queue接 口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。BlockingQueue 继承了Queue接口。</p><p>队列是一种数据结构．它有两个基本操作：在队列尾部加人一个元素，和从队列头部移除一个元素就是说，队列以一种先进先出的方式管理数据，如果你试图向一个 已经满了的阻塞队列中添加一个元素或者是从一个空的阻塞队列中移除一个元索，将导致线程阻塞．在多线程进行合作时，阻塞队列是很有用的工具。工作者线程可 以定期地把中间结果存到阻塞队列中而其他工作者线线程把中间结果取出并在将来修改它们。队列会自动平衡负载。如果第一个线程集运行得比第二个慢，则第二个 线程集在等待结果时就会阻塞。如果第一个线程集运行得快，那么它将等待第二个线程集赶上来。下表显示了jdk1.5中的阻塞队列的操作：</p><ul><li>add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li><li>remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</li><li>element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</li><li>offer 添加一个元素并返回true 如果队列已满，则返回false</li><li>poll 移除并返问队列头部的元素 如果队列为空，则返回null</li><li>peek 返回队列头部的元素 如果队列为空，则返回null</li><li>put 添加一个元素 如果队列满，则阻塞</li><li>take 移除并返回队列头部的元素 如果队列为空，则阻塞</li></ul><p>remove、element、offer 、poll、peek 其实是属于Queue接口。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map接口没有继承于接口Collection，Map提供key到value的映射。键值对key-value，主要方法如下：</p><ul><li>boolean equals(Object o)：用于比较对象</li><li>boolean remove(Object o)：用于删除一个对象</li><li>void put(Object key, Object value)：用于添加key和value</li></ul><p>Map可分为HashMap、HashTable、WeakHashMap、ConcurrentHashMap等。但是我们常用的主要是HashMap和HashTable，下面比较下两者区别：</p><ol><li>HashMap是非线程安全的，HashTable是线程安全的。</li><li>HashMap的键和值都允许有null值存在，而HashTable则不行。</li><li>因为线程安全的问题，HashMap效率比HashTable的要高。</li></ol><p>能答出上面的三点，简单的面试，算是过了，但是如果再问：Java中的另一个线程安全的与HashMap及其类似的类是什么？(ConcurrentHashMap)同样是线程安全，它与HashTable在线程同步上有什么不同？(synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，锁住的都是对象整体，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象)能把第二个问题完整的答出来，说明你的基础算是不错的了。下面浅析更多区别。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>1) hashmap的数据结构</p><p>Hashmap是一个数组和链表的结合体（在数据结构称“链表散列“），如下图示：<br><img src="/image/1473689948894.png" alt="img"><br>当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。</p><p>2)使用和遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;Rajib Sarma&quot;,&quot;100&quot;);</span><br><span class="line">map.put(&quot;Rajib Sarma&quot;,&quot;200&quot;);//The value &quot;100&quot; is replaced by &quot;200&quot;.</span><br><span class="line">map.put(&quot;Sazid Ahmed&quot;,&quot;200&quot;);</span><br><span class="line"></span><br><span class="line">Iterator iter = map.entrySet().iterator();</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">    Object key = entry.getKey();</span><br><span class="line">    Object val = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashTable和HashMap区别"><a href="#HashTable和HashMap区别" class="headerlink" title="HashTable和HashMap区别"></a>HashTable和HashMap区别</h3><ul><li>继承不同。<br>public class Hashtable extends Dictionary implements Map<br>public class HashMap extends AbstractMap implements Map</li><li>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</li><li>Hashtable中，key和value都不允许出现null值。<br>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</li><li>两个遍历方式的内部实现上不同。<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</li><li>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</li><li>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;java基本数据结构&quot;&gt;&lt;a href=&quot;#java基本数据结构&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="java base" scheme="http://www.fufan.me/categories/java-base/"/>
    
    
      <category term="java 数据结构" scheme="http://www.fufan.me/tags/java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA的Reflection反射机制</title>
    <link href="http://www.fufan.me/2016/09/11/JAVA%E7%9A%84Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.fufan.me/2016/09/11/JAVA的Reflection反射机制/</id>
    <published>2016-09-11T06:55:00.000Z</published>
    <updated>2018-10-02T13:09:10.315Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --><h3 id="反射即reflection"><a href="#反射即reflection" class="headerlink" title="反射即reflection"></a><strong>反射即reflection</strong></h3><p>java反射运用了代理模式，代理模式在之后学习的设计模式中可以了解</p><p>反射主要用了以下几点：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法</li></ul><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>首先要搞清楚Class这个类，每个类在创建的时候都会有Class这个类伴随产生，这个Class是JVM产生的，<br>由于是JVM产生的，所以我们一般获取Class的方法是：</p><ol><li>object.getClass()</li><li>Class.forName(“java.lang.String”)</li><li>Class.getSuperClass()</li><li>运用.class语法,如java.lang.String.class</li><li>primitive wrapper classes的TYPE语法,如：Boolean.TYPE，类似Boolean.class</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = s.getClass();</span><br><span class="line">Class&lt;?&gt; clazz2 = Class.forName(&quot;com.fufan.reflection.Son&quot;);</span><br><span class="line">Class&lt;?&gt; clazz3 = clazz2.getSuperclass();</span><br><span class="line">Class&lt;?&gt; clazz4 = com.fufan.reflection.Son.class;</span><br><span class="line">Class&lt;?&gt; clazz5 = Boolean.class;</span><br></pre></td></tr></table></figure><p>Class是Reflection起源。针对任何您想探勘的class，唯有先为它产生一个Class object，接下来才能经由后者唤起为数十多个的Reflection APIs<br>接下来就可以通过Class调用衍生出的一系列API：</p><ul><li>getName()：获得类的完整名字。</li><li>getFields()：获得类的public类型的属性。</li><li>getDeclaredFields()：获得类的所有属性。</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</li></ul><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p>Filed类：代表类的成员变量（成员变量也称为类的属性）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fieldName = field.getName();</span><br></pre></td></tr></table></figure><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method类：代表类的方法，invoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = getMethod.invoke(object, new Object[] &#123;&#125;);</span><br></pre></td></tr></table></figure><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>Constructor类：代表类的构造方法，调用有参和无参</p><ul><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li><li>newInstance(new Object[]{value})：当调用有参构造函数时使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//无参构造方法</span><br><span class="line">Constructor constructor1 = classType.getConstructor();</span><br><span class="line"></span><br><span class="line">//有参构造方法</span><br><span class="line">Constructor constructor2 = classType.getConstructor(new Class[] &#123;int.class, String.class&#125;);</span><br></pre></td></tr></table></figure><h4 id="代码示例1"><a href="#代码示例1" class="headerlink" title="代码示例1"></a>代码示例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 获得对象的类型</span><br><span class="line"> Class&lt;?&gt; classType = object.getClass();</span><br><span class="line"> System.out.println(&quot;Class:&quot; + classType.getName());</span><br><span class="line"></span><br><span class="line"> // 通过默认构造方法创建一个新的对象</span><br><span class="line"> Object objectCopy = classType.getConstructor(new Class[] &#123;&#125;).newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line"> // 获得对象的所有属性</span><br><span class="line"> Field fields[] = classType.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"> for (int i = 0; i &lt; fields.length; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     Field field = fields[i];</span><br><span class="line">     String fieldName = field.getName();</span><br><span class="line">     String firstLetter = fieldName.substring(0, 1).toUpperCase();</span><br><span class="line">     // 获得和属性对应的getXXX()方法的名字</span><br><span class="line">     String getMethodName = &quot;get&quot; + firstLetter + fieldName.substring(1);</span><br><span class="line">     // 获得和属性对应的setXXX()方法的名字</span><br><span class="line">     String setMethodName = &quot;set&quot; + firstLetter + fieldName.substring(1);</span><br><span class="line">     // 获得和属性对应的getXXX()方法</span><br><span class="line">     Method getMethod = classType.getMethod(getMethodName, new Class[] &#123;&#125;);</span><br><span class="line">     // 获得和属性对应的setXXX()方法</span><br><span class="line">     Method setMethod = classType.getMethod(setMethodName, new Class[] &#123; field.getType() &#125;);</span><br><span class="line">     // 调用原对象的getXXX()方法</span><br><span class="line">     Object value = getMethod.invoke(object, new Object[] &#123;&#125;);</span><br><span class="line">     System.out.println(fieldName + &quot;:&quot; + value);</span><br><span class="line">     // 调用拷贝对象的setXXX()方法</span><br><span class="line">     setMethod.invoke(objectCopy, new Object[] &#123; value &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</p><h4 id="代码示例2"><a href="#代码示例2" class="headerlink" title="代码示例2"></a>代码示例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//一维数组的使用</span><br><span class="line">Object array = Array.newInstance(Integer.TYPE, 10);</span><br><span class="line">System.out.println(Integer.TYPE);</span><br><span class="line">for(int index=1; index&lt;10; index ++)&#123;</span><br><span class="line">Array.set(array, index, index);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Array.get(array, 4));</span><br><span class="line"></span><br><span class="line">//多维数组的使用</span><br><span class="line"></span><br><span class="line">Object arrays = Array.newInstance(String.class, 3,5);</span><br><span class="line"></span><br><span class="line">Object array1 = Array.get(arrays, 2);</span><br><span class="line"></span><br><span class="line">Array.set(array1, 3, &quot;fufan&quot;);</span><br><span class="line"></span><br><span class="line">String[][] arrayInt = (String[][]) arrays; </span><br><span class="line">System.out.println(arrayInt[1][3]);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:12:29 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;反射即reflection&quot;&gt;&lt;a href=&quot;#反射即reflection&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java base" scheme="http://www.fufan.me/categories/java-base/"/>
    
    
      <category term="java" scheme="http://www.fufan.me/tags/java/"/>
    
  </entry>
  
</feed>
