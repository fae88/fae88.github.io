<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Gemini Boy</title>
  
  <subtitle>welcome to my site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fufan.me/"/>
  <updated>2023-01-30T03:02:06.264Z</updated>
  <id>http://www.fufan.me/</id>
  
  <author>
    <name>fae88</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>消息队列的前生今世</title>
    <link href="http://www.fufan.me/2019/08/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/"/>
    <id>http://www.fufan.me/2019/08/18/消息队列的前生今世/</id>
    <published>2019-08-18T15:30:00.000Z</published>
    <updated>2023-01-30T03:02:06.264Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><h4 id="半成品运输案例"><a href="#半成品运输案例" class="headerlink" title="半成品运输案例"></a>半成品运输案例</h4><p>话说小寰是一家巧克力作坊的老板，生产出美味的巧克力需要三道工序：首先将可可豆磨成可可粉，然后将可可粉加热并加入糖变成巧克力浆，最后将巧克力浆灌入模具，撒上坚果碎，冷却后就是成品巧克力了。</p><p>最开始的时候，每次研磨出一桶可可粉后，工人就会把这桶可可粉送到加工巧克力浆的工人手上，然后再回来加工下一桶可可粉。小寰很快就发现，其实工人可以不用自己运送半成品，于是他在每道工序之间都增加了一组传送带，研磨工人只要把研磨好的可可粉放到传送带上，就可以去加工下一桶可可粉了。 传送带解决了上下游工序之间的“通信”问题。</p><p>传送带上线后确实提高了生产效率，但也带来了新的问题：每道工序的生产速度并不相同。在巧克力浆车间，一桶可可粉传送过来时，工人可能正在加工上一批可可粉，没有时间接收。不同工序的工人们必须协调好什么时间往传送带上放置半成品，如果出现上下游工序加工速度不一致的情况，上下游工人之间必须互相等待，确保不会出现传送带上的半成品无人接收的情况。</p><p>为了解决这个问题，小寰在每组传送的下游带配备了一个暂存半成品的仓库，这样上游工人就不用等待下游工人有空，任何时间都可以把加工完成的半成品丢到传送带上，无法接收的货物被暂存在仓库中，下游工人可以随时来取。传送带配备的仓库实际上起到了“通信”过程中“缓存”的作用。</p><p><img src="/image/mq-2-3.jpg" alt=""></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息队列，一般我们会简称它为MQ(Message Queue)，嗯，就是很直白的简写。</span><br></pre></td></tr></table></figure><p>消息队列，我们可以分为消息 + 队列，即 Message + Queue。</p><ul><li>消息：各个系统之间传输的各种数据，一般会封装成一个大家都可以序列化和反序列化的对象（即它包含消费者与服务双方都能识别的数据）</li><li>队列：一种先进先出的数据结构（可以思考下为什么使用这种数据结构，比如Map？）<br><img src="/image/mq-2-0.jpg" alt=""></li></ul><h4 id="与RPC的对比"><a href="#与RPC的对比" class="headerlink" title="与RPC的对比"></a>与RPC的对比</h4><p>RPC：Remote Procedure Call，即远程过程调用，主要解决远程通信间的问题，不需要了解底层网络的通信机制。<br><img src="/image/mq-2-1.jpg" alt=""><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简单介绍下RPC的调用过程，分成4个步骤</span><br><span class="line">1. 建立通信</span><br><span class="line">即A机器想要调用B机器，首先得建立起通信连接，主要是通过在客户端和服务器之间建立TCP连接。</span><br><span class="line">2. 服务寻址</span><br><span class="line">A服务器上如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称是什么。（分布式系统中一般我们会使用协调者中间件来实现，入ZK、euraka、consul等）</span><br><span class="line">3. 网络传输</span><br><span class="line">即序列化和反序列化</span><br><span class="line">序列化： 当A服务器上的应用发起一个RPC调用时，调用方法和参数数据都需要先进行序列化。</span><br><span class="line">反序列化：当B服务器接收到A服务器的请求之后，又需要对接收到的参数等信息进行反序列化操作。</span><br><span class="line">4. 服务调用</span><br><span class="line">B服务器进行本地调用（通过代理Proxy）之后得到了返回值，此时还需要再把返回值发送回A服务器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A服务器。</span><br><span class="line"></span><br><span class="line">知名度较高的有Thrift(FB的)、dubbo(阿里的)，gRpc（google）</span><br></pre></td></tr></table></figure><p></p><h5 id="结构对比"><a href="#结构对比" class="headerlink" title="结构对比"></a>结构对比</h5><p>RPC系统结构：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----------+     +----------+</span><br><span class="line">| Consumer | &lt;=&gt; | Provider |</span><br><span class="line">+----------+     +----------+</span><br><span class="line">Consumer调用的Provider提供的服务。</span><br></pre></td></tr></table></figure><p></p><p>Message Queue系统结构：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+     +-------+     +----------+</span><br><span class="line">| Sender | &lt;=&gt; | Queue | &lt;=&gt; | Receiver |</span><br><span class="line">+--------+     +-------+     +----------+</span><br></pre></td></tr></table></figure><p></p><p>Sender发送消息给Queue；Receiver从Queue拿到消息来处理。</p><p>在架构上，RPC和MQ的差异点是，Message Queue有一个中间结点Queue，可以把消息存储。</p><h5 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h5><p>在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。</p><ul><li><p>mq的特点</p><ul><li>Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。</li><li>Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响。</li><li>Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。</li></ul></li><li><p>RPC的特点</p><ul><li>同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。（当然，RPC也有异步调用方式，思考下异步调用方式存在的问题）</li><li>由于等待结果，Consumer（Client）会有线程消耗。</li></ul></li></ul><h5 id="场景对比"><a href="#场景对比" class="headerlink" title="场景对比"></a>场景对比</h5><ul><li>对于要立即等待返回处理结果的场景，RPC是首选。</li><li>希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。</li><li>不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。</li></ul><h3 id="消息队列的两种模式"><a href="#消息队列的两种模式" class="headerlink" title="消息队列的两种模式"></a>消息队列的两种模式</h3><h5 id="点对点：QUEUE，不可重复消费"><a href="#点对点：QUEUE，不可重复消费" class="headerlink" title="点对点：QUEUE，不可重复消费"></a>点对点：QUEUE，不可重复消费</h5><ul><li>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。</li><li>消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</li></ul><p><img src="/image/mq-2-4.jpg" alt=""></p><h5 id="发布-订阅：Topic，可以重复消费"><a href="#发布-订阅：Topic，可以重复消费" class="headerlink" title="发布/订阅：Topic，可以重复消费"></a>发布/订阅：Topic，可以重复消费</h5><p>支持订阅组的发布订阅模式：</p><p>发布订阅模式下，当发布者消息量很大时，显然单个订阅者的处理能力是不足的。实际上现实场景中是多个订阅者节点组成一个订阅组负载均衡消费topic消息即分组订阅，这样订阅者很容易实现消费能力线性扩展。可以看成是一个topic下有多个Queue，每个Queue是点对点的方式，Queue之间是发布订阅方式。</p><p><img src="/image/mq-2-5.jpg" alt=""></p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><p>在生产环境中，其实主要是6个字，解耦、异步、削峰</p><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><h5 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h5><p>系统间耦合性太强，如下图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</p><p><img src="/image/mq-2-6.jpg" alt=""></p><h5 id="MQ模式"><a href="#MQ模式" class="headerlink" title="MQ模式"></a>MQ模式</h5><p>将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。<br><img src="/image/mq-2-7.jpg" alt=""></p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><h5 id="传统模式-1"><a href="#传统模式-1" class="headerlink" title="传统模式"></a>传统模式</h5><p>一些非必要的业务逻辑以同步的方式运行，太耗费时间。<br><img src="/image/mq-2-8.jpg" alt=""></p><h5 id="MQ模式-1"><a href="#MQ模式-1" class="headerlink" title="MQ模式"></a>MQ模式</h5><p>将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度<br><img src="/image/mq-2-9.jpg" alt=""></p><h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><p>削峰其实就是流控</p><h5 id="传统模式-2"><a href="#传统模式-2" class="headerlink" title="传统模式"></a>传统模式</h5><p>并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常<br><img src="/image/mq-2-10.jpg" alt=""></p><h5 id="MQ模式-2"><a href="#MQ模式-2" class="headerlink" title="MQ模式"></a>MQ模式</h5><p>系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。<br><img src="/image/mq-2-11.jpg" alt=""></p><h3 id="如何使用消息队列"><a href="#如何使用消息队列" class="headerlink" title="如何使用消息队列"></a>如何使用消息队列</h3><p>这里我先介绍个大概，因为毕竟篇幅原因，这块内容应该单独拿出来分享。这里先贴一张主流消息队列对比表，之后会详细说。</p><p><img src="/image/mq-2-12.jpg" alt=""></p><h3 id="使用消息队列有什么问题"><a href="#使用消息队列有什么问题" class="headerlink" title="使用消息队列有什么问题"></a>使用消息队列有什么问题</h3><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>无论是我们使用消息队列来做解耦、异步还是削峰，消息队列肯定不能是单机的。试着想一下，如果是单机的消息队列，万一这台机器挂了，那我们整个系统几乎就是不可用了。</p><p><img src="/image/mq-2-13.jpg" alt=""></p><p>所以，当我们项目中使用消息队列，都是得集群/分布式的。要做集群/分布式就必然希望该消息队列能够提供现成的支持，而不是自己写代码手动去实现。</p><h4 id="数据丢失问题"><a href="#数据丢失问题" class="headerlink" title="数据丢失问题"></a>数据丢失问题</h4><p>我们将数据写到消息队列上，系统B和C还没来得及取消息队列的数据，就挂掉了。如果没有做任何的措施，我们的数据就丢了。</p><p><img src="/image/mq-2-14.jpg" alt=""></p><p>学过Redis的都知道，Redis可以将数据持久化磁盘上，万一Redis挂了，还能从磁盘从将数据恢复过来。同样地，消息队列中的数据也需要存在别的地方，这样才尽可能减少数据的丢失。</p><h4 id="消费者怎么得到消息队列的数据"><a href="#消费者怎么得到消息队列的数据" class="headerlink" title="消费者怎么得到消息队列的数据"></a>消费者怎么得到消息队列的数据</h4><p>消费者怎么从消息队列里边得到数据？有两种办法：</p><p>生产者将数据放到消息队列中，消息队列有数据了，主动叫消费者去拿(俗称push)<br>消费者不断去轮训消息队列，看看有没有新的数据，如果有就消费(俗称pull)</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>消息的幂等问题</li><li>消息的事务</li><li>消息重复消费</li><li>……</li></ul><p>虽然消息队列给我们带来了那么多的好处，但同时我们发现引入消息队列也会提高系统的复杂性。市面上现在已经有不少消息队列轮子了，每种消息队列都有自己的特点，选取哪种MQ还得好好斟酌。</p><h4 id="如何设计一个消息队列（进阶）"><a href="#如何设计一个消息队列（进阶）" class="headerlink" title="如何设计一个消息队列（进阶）"></a>如何设计一个消息队列（进阶）</h4><p>待续……</p><h3 id="典型使用场景举例"><a href="#典型使用场景举例" class="headerlink" title="典型使用场景举例"></a>典型使用场景举例</h3><h4 id="电商下单"><a href="#电商下单" class="headerlink" title="电商下单"></a>电商下单</h4><p>我们再浏览器或app中提交了一个购物订单，那么他的流程如下：<br><img src="/image/mq-2-15.jpg" alt=""></p><h4 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h4><p>秒杀业务中利用MQ来实现流量削峰，以及应用解耦使用。</p><p><img src="/image/mq-2-16.jpg" alt=""></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;什么是消息队列&quot;&gt;&lt;a href=&quot;#什么是消息队列&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="mq" scheme="http://www.fufan.me/categories/mq/"/>
    
    
      <category term="mq" scheme="http://www.fufan.me/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>git设置代理模式，仅为github设置代理</title>
    <link href="http://www.fufan.me/2019/03/20/git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BB%85%E4%B8%BAgithub%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>http://www.fufan.me/2019/03/20/git设置代理模式，仅为github设置代理/</id>
    <published>2019-03-20T15:31:00.000Z</published>
    <updated>2023-01-29T15:34:11.994Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>这篇文章可能对于经常要使用github的同学很有用，毕竟github访问速度缓慢，设置代理可有加速</p><h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>设置代理前首先要有一个翻墙的代理ip和端口，这里我用的是ssh里的，相信很多朋友都是用ssh翻墙的。不过其他翻墙的一般也都是会提供有这个代理地址的。</p><h3 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h3><p>git config –global http.proxy 127.0.0.1:1087</p><h3 id="局部代理，在github-clone-仓库内执行"><a href="#局部代理，在github-clone-仓库内执行" class="headerlink" title="局部代理，在github clone 仓库内执行"></a>局部代理，在github clone 仓库内执行</h3><p>git config –local http.proxy 127.0.0.1:1087<br>(127.0.0.1:1087 这个地址是我翻出去用的代理地址，根据自己的实际修改)</p><h3 id="查询是否使用代理："><a href="#查询是否使用代理：" class="headerlink" title="查询是否使用代理："></a>查询是否使用代理：</h3><h4 id="查询全局代理"><a href="#查询全局代理" class="headerlink" title="查询全局代理"></a>查询全局代理</h4><p>git config –global http.proxy</p><h4 id="查询局部代理"><a href="#查询局部代理" class="headerlink" title="查询局部代理"></a>查询局部代理</h4><p>git config –local http.proxy</p><h3 id="取消代理："><a href="#取消代理：" class="headerlink" title="取消代理："></a>取消代理：</h3><p>git config –global –unset http.proxy<br>git config –local –unset http.proxy</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;这篇文章可能对于经常要使用github的同学很有用，毕竟github访问速度缓慢，设置代理可有加速&lt;/p&gt;&lt;h3 id=&quot;预
      
    
    </summary>
    
      <category term="github" scheme="http://www.fufan.me/categories/github/"/>
    
    
      <category term="github" scheme="http://www.fufan.me/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装Python3.7</title>
    <link href="http://www.fufan.me/2019/03/12/Centos7%E5%AE%89%E8%A3%85Python3-7/"/>
    <id>http://www.fufan.me/2019/03/12/Centos7安装Python3-7/</id>
    <published>2019-03-12T15:29:00.000Z</published>
    <updated>2023-01-29T15:30:22.188Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>python升级的真快，之前写了3.65的，现在继续安排3.7的。。。</p><h3 id="安装编译相关工具"><a href="#安装编译相关工具" class="headerlink" title="安装编译相关工具"></a>安装编译相关工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development tools&quot;</span><br><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class="line">yum install libffi-devel -y</span><br></pre></td></tr></table></figure><h3 id="下载安装包解压"><a href="#下载安装包解压" class="headerlink" title="下载安装包解压"></a>下载安装包解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd #回到用户目录</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</span><br><span class="line">tar -xvJf  Python-3.7.0.tar.xz</span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/python3 #创建编译安装目录</span><br><span class="line">cd Python-3.7.0</span><br><span class="line">./configure --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3</span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3</span><br></pre></td></tr></table></figure><h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;python升级的真快，之前写了3.65的，现在继续安排3.7的。。。&lt;/p&gt;&lt;h3 id=&quot;安装编译相关工具&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="centos" scheme="http://www.fufan.me/categories/centos/"/>
    
    
      <category term="python" scheme="http://www.fufan.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Java Design Patterns —— 软件设计和代码编写几个原则</title>
    <link href="http://www.fufan.me/2019/02/11/Java-Design-Patterns%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%88%99/"/>
    <id>http://www.fufan.me/2019/02/11/Java-Design-Patterns（一）——-软件设计和代码编写几个原则/</id>
    <published>2019-02-11T10:53:00.000Z</published>
    <updated>2019-03-30T10:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><h1 id="Programming-Principles"><a href="#Programming-Principles" class="headerlink" title="Programming Principles"></a>Programming Principles</h1><p>Every programmer benefits from understanding programming principles and patterns. This overview is a reference for myself, and I’ve just put it here. Maybe it is of help to you during design, discussion, or review. Please note that it’s far from complete, and that you often need to make trade-offs between conflicting principles.</p><p>The list was inspired by <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=331531" target="_blank" rel="noopener">The Principles of Good Programming</a>. I felt that the list closely, but not completely matches what I would personally put into something similar. Additionally, I wanted a bit more reasoning, details, and links to further resources. <a href="https://github.com/webpro/programming-principles/issues" target="_blank" rel="noopener">Let me know</a> if you have any feedback or suggestions for improvement.</p><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><ul><li><a href="#kiss">KISS (Keep It Simple Stupid)</a></li><li><a href="#yagni">YAGNI</a></li><li><a href="#do-the-simplest-thing-that-could-possibly-work">Do The Simplest Thing That Could Possibly Work</a></li><li><a href="#separation-of-concerns">Separation of Concerns</a></li><li><a href="#keep-things-dry">Keep Things DRY</a></li><li><a href="#code-for-the-maintainer">Code For The Maintainer</a></li><li><a href="#avoid-premature-optimization">Avoid Premature Optimization</a></li><li><a href="#boy-scout-rule">Boy-Scout Rule</a></li></ul><h3 id="Inter-Module-Class"><a href="#Inter-Module-Class" class="headerlink" title="Inter-Module/Class"></a>Inter-Module/Class</h3><ul><li><a href="#minimise-coupling">Minimise Coupling</a></li><li><a href="#law-of-demeter">Law of Demeter</a></li><li><a href="#composition-over-inheritance">Composition Over Inheritance</a></li><li><a href="#orthogonality">Orthogonality</a></li><li><a href="#robustness-principle">Robustness Principle</a></li><li><a href="#inversion-of-control">Inversion of Control</a></li></ul><h3 id="Module-Class"><a href="#Module-Class" class="headerlink" title="Module/Class"></a>Module/Class</h3><ul><li><a href="#maximise-cohesion">Maximise Cohesion</a></li><li><a href="#liskov-substitution-principle">Liskov Substitution Principle</a></li><li><a href="#openclosed-principle">Open/Closed Principle</a></li><li><a href="#single-responsibility-principle">Single Responsibility Principle</a></li><li><a href="#hide-implementation-details">Hide Implementation Details</a></li><li><a href="#curlys-law">Curly’s Law</a></li><li><a href="#encapsulate-what-changes">Encapsulate What Changes</a></li><li><a href="#interface-segregation-principle">Interface Segregation Principle</a></li><li><a href="#command-query-separation">Command Query Separation</a></li></ul><h2 id="KISS"><a href="#KISS" class="headerlink" title="KISS"></a>KISS</h2><p>Most systems work best if they are kept simple rather than made complex.</p><p>Why</p><ul><li>Less code takes less time to write, has less bugs, and is easier to modify.</li><li>Simplicity is the ultimate sophistication.</li><li>It seems that perfection is reached not when there is nothing left to add, but when there is nothing left to take away.</li></ul><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">KISS principle</a></li><li><a href="http://principles-wiki.net/principles:keep_it_simple_stupid" target="_blank" rel="noopener">Keep It Simple Stupid (KISS)</a></li></ul><h2 id="YAGNI"><a href="#YAGNI" class="headerlink" title="YAGNI"></a>YAGNI</h2><p>YAGNI stands for “you aren’t gonna need it”: don’t implement something until it is necessary.</p><p>Why</p><ul><li>Any work that’s only used for a feature that’s needed tomorrow, means losing effort from features that need to be done for the current iteration.</li><li>It leads to code bloat; the software becomes larger and more complicated.</li></ul><p>How</p><ul><li>Always implement things when you actually need them, never when you just foresee that you need them.</li></ul><p>Resources</p><ul><li><a href="http://c2.com/xp/YouArentGonnaNeedIt.html" target="_blank" rel="noopener">You Arent Gonna Need It</a></li><li><a href="http://www.xprogramming.com/Practices/PracNotNeed.html" target="_blank" rel="noopener">You’re NOT gonna need it!</a></li><li><a href="http://en.wikipedia.org/wiki/You_ain&#39;t_gonna_need_it" target="_blank" rel="noopener">You ain’t gonna need it</a></li></ul><h2 id="Do-The-Simplest-Thing-That-Could-Possibly-Work"><a href="#Do-The-Simplest-Thing-That-Could-Possibly-Work" class="headerlink" title="Do The Simplest Thing That Could Possibly Work"></a>Do The Simplest Thing That Could Possibly Work</h2><p>Why</p><ul><li>Real progress against the real problem is maximized if we just work on what the problem really is.</li></ul><p>How</p><ul><li>Ask yourself: “What is the simplest thing that could possibly work?”</li></ul><p>Resources</p><ul><li><a href="http://c2.com/xp/DoTheSimplestThingThatCouldPossiblyWork.html" target="_blank" rel="noopener">Do The Simplest Thing That Could Possibly Work</a></li></ul><h2 id="Separation-of-Concerns"><a href="#Separation-of-Concerns" class="headerlink" title="Separation of Concerns"></a>Separation of Concerns</h2><p>Separation of concerns is a design principle for separating a computer program into distinct sections, such that each section addresses a separate concern. For example the business logic of the application is a concern and the user interface is another concern. Changing the user interface should not require changes to business logic and vice versa.</p><p>Quoting <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger W. Dijkstra</a> (1974):</p><blockquote><p>It is what I sometimes have called “the separation of concerns”, which, even if not perfectly possible, is yet the only available technique for effective ordering of one’s thoughts, that I know of. This is what I mean by “focusing one’s attention upon some aspect”: it does not mean ignoring the other aspects, it is just doing justice to the fact that from this aspect’s point of view, the other is irrelevant.</p></blockquote><p>Why</p><ul><li>Simplify development and maintenance of software applications.</li><li>When concerns are well-separated, individual sections can be reused, as well as developed and updated independently.</li></ul><p>How</p><ul><li>Break program functionality into separate modules that overlap as little as possible.</li></ul><p>Resources</p><ul><li><a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">Separation of Concerns</a></li></ul><h2 id="Keep-things-DRY"><a href="#Keep-things-DRY" class="headerlink" title="Keep things DRY"></a>Keep things DRY</h2><p>Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.</p><p>Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.</p><p>Why</p><ul><li>Duplication (inadvertent or purposeful duplication) can lead to maintenance nightmares, poor factoring, and logical contradictions.</li><li>A modification of any single element of a system does not require a change in other logically unrelated elements.</li><li>Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in sync.</li></ul><p>How</p><ul><li>Put business rules, long expressions, if statements, math formulas, metadata, etc. in only one place.</li><li>Identify the single, definitive source of every piece of knowledge used in your system, and then use that source to generate applicable instances of that knowledge (code, documentation, tests, etc).</li><li>Apply the <a href="http://en.wikipedia.org/wiki/Rule_of_three_(computer_programming" target="_blank" rel="noopener">Rule of three</a>).</li></ul><p>Resources</p><ul><li><a href="http://c2.com/cgi/wiki?DontRepeatYourself" target="_blank" rel="noopener">Dont Repeat Yourself</a></li><li><a href="http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself" target="_blank" rel="noopener">Don’t repeat yourself</a></li><li><a href="http://programmer.97things.oreilly.com/wiki/index.php/Don&#39;t_Repeat_Yourself" target="_blank" rel="noopener">Don’t Repeat Yourself</a></li></ul><p>Related</p><ul><li><a href="http://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming" target="_blank" rel="noopener">Abstraction principle</a>)</li><li><a href="http://c2.com/cgi/wiki?OnceAndOnlyOnce" target="_blank" rel="noopener">Once And Only Once</a> is a subset of DRY (also referred to as the goal of refactoring).</li><li><a href="http://en.wikipedia.org/wiki/Single_Source_of_Truth" target="_blank" rel="noopener">Single Source of Truth</a></li><li>A violation of DRY is <a href="http://thedailywtf.com/articles/The-WET-Cart" target="_blank" rel="noopener">WET</a> (Write Everything Twice)</li></ul><h2 id="Code-For-The-Maintainer"><a href="#Code-For-The-Maintainer" class="headerlink" title="Code For The Maintainer"></a>Code For The Maintainer</h2><p>Why</p><ul><li>Maintenance is by far the most expensive phase of any project.</li></ul><p>How</p><ul><li><em>Be</em> the maintainer.</li><li>Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.</li><li>Always code and comment in such a way that if someone a few notches junior picks up the code, they will take pleasure in reading and learning from it.</li><li><a href="http://www.sensible.com/dmmt.html" target="_blank" rel="noopener">Don’t make me think</a>.</li><li>Use the <a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank" rel="noopener">Principle of Least Astonishment</a>.</li></ul><p>Resources</p><ul><li><a href="http://c2.com/cgi/wiki?CodeForTheMaintainer" target="_blank" rel="noopener">Code For The Maintainer</a></li><li><a href="http://blog.codinghorror.com/the-noble-art-of-maintenance-programming/" target="_blank" rel="noopener">The Noble Art of Maintenance Programming</a></li></ul><h2 id="Avoid-Premature-Optimization"><a href="#Avoid-Premature-Optimization" class="headerlink" title="Avoid Premature Optimization"></a>Avoid Premature Optimization</h2><p>Quoting <a href="http://en.wikiquote.org/wiki/Donald_Knuth" target="_blank" rel="noopener">Donald Knuth</a>:</p><blockquote><p>Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.</p></blockquote><p>Understanding what is and isn’t “premature” is critical of course.</p><p>Why</p><ul><li>It is unknown upfront where the bottlenecks will be.</li><li>After optimization, it might be harder to read and thus maintain.</li></ul><p>How</p><ul><li><a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast" target="_blank" rel="noopener">Make It Work Make It Right Make It Fast</a></li><li>Don’t optimize until you need to, and only after profiling you discover a bottleneck optimise that.</li></ul><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Program_optimization" target="_blank" rel="noopener">Program optimization</a></li><li><a href="http://c2.com/cgi/wiki?PrematureOptimization" target="_blank" rel="noopener">Premature Optimization</a></li></ul><h2 id="Minimise-Coupling"><a href="#Minimise-Coupling" class="headerlink" title="Minimise Coupling"></a>Minimise Coupling</h2><p>Coupling between modules/components is their degree of mutual interdependence; lower coupling is better. In other words, coupling is the probability that code unit “B” will “break” after an unknown change to code unit “A”.</p><p>Why</p><ul><li>A change in one module usually forces a ripple effect of changes in other modules.</li><li>Assembly of modules might require more effort and/or time due to the increased inter-module dependency.</li><li>A particular module might be harder to reuse and/or test because dependent modules must be included.</li><li>Developers might be afraid to change code because they aren’t sure what might be affected.</li></ul><p>How</p><ul><li>Eliminate, minimise, and reduce complexity of necessary relationships.</li><li>By hiding implementation details, coupling is reduced.</li><li>Apply the <a href="#law-of-demeter">Law of Demeter</a>.</li></ul><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Coupling_(computer_programming" target="_blank" rel="noopener">Coupling</a>)</li><li><a href="http://c2.com/cgi/wiki?CouplingAndCohesion" target="_blank" rel="noopener">Coupling And Cohesion</a></li></ul><h2 id="Law-of-Demeter"><a href="#Law-of-Demeter" class="headerlink" title="Law of Demeter"></a>Law of Demeter</h2><p>Don’t talk to strangers.</p><p>Why</p><ul><li>It usually tightens coupling</li><li>It might reveal too much implementation details</li></ul><p>How</p><p>A method of an object may only call methods of:</p><ol><li>The object itself.</li><li>An argument of the method.</li><li>Any object created within the method.</li><li>Any direct properties/fields of the object.</li></ol><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="noopener">Law of Demeter</a></li><li><a href="http://haacked.com/archive/2009/07/14/law-of-demeter-dot-counting.aspx/" target="_blank" rel="noopener">The Law of Demeter Is Not A Dot Counting Exercise</a></li></ul><h2 id="Composition-Over-Inheritance"><a href="#Composition-Over-Inheritance" class="headerlink" title="Composition Over Inheritance"></a>Composition Over Inheritance</h2><p>Why</p><ul><li>Less coupling between classes.</li><li>Using inheritance, subclasses easily make assumptions, and break LSP.</li></ul><p>How</p><ul><li>Test for LSP (substitutability) to decide when to inherit.</li><li>Compose when there is a “has a” (or “uses a”) relationship, inherit when “is a”.</li></ul><p>Resources</p><ul><li><a href="http://blogs.msdn.com/b/thalesc/archive/2012/09/05/favor-composition-over-inheritance.aspx" target="_blank" rel="noopener">Favor Composition Over Inheritance</a></li></ul><h2 id="Orthogonality"><a href="#Orthogonality" class="headerlink" title="Orthogonality"></a>Orthogonality</h2><blockquote><p>The basic idea of orthogonality is that things that are not related conceptually should not be related in the system.</p></blockquote><p>Source: <a href="http://www.artima.com/intv/dry3.html" target="_blank" rel="noopener">Be Orthogonal</a></p><blockquote><p>It is associated with simplicity; the more orthogonal the design, the fewer exceptions. This makes it easier to learn, read and write programs in a programming language. The meaning of an orthogonal feature is independent of context; the key parameters are symmetry and consistency.</p></blockquote><p>Source: <a href="http://en.wikipedia.org/wiki/Orthogonality_(programming" target="_blank" rel="noopener">Orthogonality</a>)</p><h2 id="Robustness-Principle"><a href="#Robustness-Principle" class="headerlink" title="Robustness Principle"></a>Robustness Principle</h2><blockquote><p>Be conservative in what you do, be liberal in what you accept from others</p></blockquote><p>Collaborating services depend on each others interfaces. Often the interfaces need to evolve causing the other end to receive unspecified data. A naive implementation refuses to collaborate if the received data does not strictly follow the specification. A more sophisticated implementation will still work ignoring the data it does not recognize.</p><p>Why</p><ul><li>In order to be able to evolve services you need to ensure that a provider can make changes to support new demands while causing minimal breakage to their existing clients.</li></ul><p>How</p><ul><li>Code that sends commands or data to other machines (or to other programs on the same machine) should conform completely to the specifications, but code that receives input should accept non-conformant input as long as the meaning is clear.</li></ul><p>Resources</p><ul><li><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Robustness Principle in Wikipedia</a></li><li><a href="http://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="noopener">Tolerant Reader</a></li></ul><h2 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a>Inversion of Control</h2><p>Inversion of Control is also known as the Hollywood Principle, “Don’t call us, we’ll call you”. It is a design principle in which custom-written portions of a computer program receive the flow of control from a generic framework. Inversion of control carries the strong connotation that the reusable code and the problem-specific code are developed independently even though they operate together in an application.</p><p>Why</p><ul><li>Inversion of control is used to increase modularity of the program and make it extensible.</li><li>To decouple the execution of a task from implementation.</li><li>To focus a module on the task it is designed for.</li><li>To free modules from assumptions about how other systems do what they do and instead rely on contracts.</li><li>To prevent side effects when replacing a module.</li></ul><p>How</p><ul><li>Using Factory pattern</li><li>Using Service Locator pattern</li><li>Using Dependency Injection</li><li>Using contextualized lookup</li><li>Using Template Method pattern</li><li>Using Strategy pattern</li></ul><p>Resources</p><ul><li><a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">Inversion of Control in Wikipedia</a></li><li><a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Inversion of Control Containers and the Dependency Injection pattern</a></li></ul><h2 id="Maximise-Cohesion"><a href="#Maximise-Cohesion" class="headerlink" title="Maximise Cohesion"></a>Maximise Cohesion</h2><p>Cohesion of a single module/component is the degree to which its responsibilities form a meaningful unit; higher cohesion is better.</p><p>Why</p><ul><li>Increased difficulty in understanding modules.</li><li>Increased difficulty in maintaining a system, because logical changes in the domain affect multiple modules, and because changes in one module require changes in related modules.</li><li>Increased difficulty in reusing a module because most applications won’t need the random set of operations provided by a module.</li></ul><p>How</p><ul><li>Group related functionalities sharing a single responsibility (e.g. in a class).</li></ul><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Cohesion_(computer_science" target="_blank" rel="noopener">Cohesion</a>)</li><li><a href="http://c2.com/cgi/wiki?CouplingAndCohesion" target="_blank" rel="noopener">Coupling And Cohesion</a></li></ul><h2 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h2><p>The LSP is all about expected behavior of objects:</p><blockquote><p>Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.</p></blockquote><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">Liskov substitution principle</a></li><li><a href="http://www.blackwasp.co.uk/lsp.aspx" target="_blank" rel="noopener">Liskov Substitution Principle</a></li></ul><h2 id="Open-Closed-Principle"><a href="#Open-Closed-Principle" class="headerlink" title="Open/Closed Principle"></a>Open/Closed Principle</h2><p>Software entities (e.g. classes) should be open for extension, but closed for modification. I.e. such an entity can allow its behavior to be modified without altering its source code.</p><p>Why</p><ul><li>Improve maintainability and stability by minimizing changes to existing code.</li></ul><p>How</p><ul><li>Write classes that can be extended (as opposed to classes that can be modified).</li><li>Expose only the moving parts that need to change, hide everything else.</li></ul><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">Open Closed Principle</a></li><li><a href="https://8thlight.com/blog/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html" target="_blank" rel="noopener">The Open Closed Principle</a></li></ul><h2 id="Single-Responsibility-Principle"><a href="#Single-Responsibility-Principle" class="headerlink" title="Single Responsibility Principle"></a>Single Responsibility Principle</h2><p>A class should never have more than one reason to change.</p><p>Long version: Every class should have a single responsibility, and that responsibility should be entirely encapsulated by the class. Responsibility can be defined as a reason to change, so a class or module should have one, and only one, reason to change.</p><p>Why</p><ul><li>Maintainability: changes should be necessary only in one module or class.</li></ul><p>How</p><ul><li>Apply <a href="#Curly-s-Law">Curly’s Law</a>.</li></ul><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">Single responsibility principle</a></li></ul><h2 id="Hide-Implementation-Details"><a href="#Hide-Implementation-Details" class="headerlink" title="Hide Implementation Details"></a>Hide Implementation Details</h2><p>A software module hides information (i.e. implementation details) by providing an interface, and not leak any unnecessary information.</p><p>Why</p><ul><li>When the implementation changes, the interface clients are using does not have to change.</li></ul><p>How</p><ul><li>Minimize accessibility of classes and members.</li><li>Don’t expose member data in public.</li><li>Avoid putting private implementation details into a class’s interface.</li><li>Decrease coupling to hide more implementation details.</li></ul><p>Resources</p><ul><li><a href="http://en.wikipedia.org/wiki/Information_hiding" target="_blank" rel="noopener">Information hiding</a></li></ul><h2 id="Curly’s-Law"><a href="#Curly’s-Law" class="headerlink" title="Curly’s Law"></a>Curly’s Law</h2><p>Curly’s Law is about choosing a single, clearly defined goal for any particular bit of code: Do One Thing.</p><ul><li><a href="http://blog.codinghorror.com/curlys-law-do-one-thing/" target="_blank" rel="noopener">Curly’s Law: Do One Thing</a></li><li><a href="http://fortyplustwo.com/2008/09/06/the-rule-of-one-or-curlys-law/" target="_blank" rel="noopener">The Rule of One or Curly’s Law</a></li></ul><h2 id="Encapsulate-What-Changes"><a href="#Encapsulate-What-Changes" class="headerlink" title="Encapsulate What Changes"></a>Encapsulate What Changes</h2><p>A good design identifies the hotspots that are most likely to change and encapsulates them behind an API. When an anticipated change then occurs, the modifications are kept local.</p><p>Why</p><ul><li>To minimize required modifications when a change occurs</li></ul><p>How</p><ul><li>Encapsulate the concept that varies behind an API</li><li>Possibly separate the varying concept into its own module</li></ul><p>Resources</p><ul><li><a href="http://principles-wiki.net/principles:encapsulate_the_concept_that_varies" target="_blank" rel="noopener">Encapsulate the Concept that Varies</a></li><li><a href="http://blogs.msdn.com/b/steverowe/archive/2007/12/26/encapsulate-what-varies.aspx" target="_blank" rel="noopener">Encapsulate What Varies</a></li><li><a href="https://en.wikipedia.org/wiki/Information_hiding" target="_blank" rel="noopener">Information Hiding</a></li></ul><h2 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface Segregation Principle"></a>Interface Segregation Principle</h2><p>Reduce fat interfaces into multiple smaller and more specific client specific interfaces. An interface should be more dependent on the code that calls it than the code that implements it.</p><p>Why</p><ul><li>If a class implements methods that are not needed the caller needs to know about the method implementation of that class. For example if a class implements a method but simply throws then the caller will need to know that this method shouldn’t actually be called.</li></ul><p>How</p><ul><li>Avoid fat interfaces. Classes should never have to implement methods that violate the <a href="#single-responsibility-principle">Single responsibility principle</a>.</li></ul><p>Resources</p><ul><li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank" rel="noopener">Interface segregation principle</a></li></ul><h2 id="Boy-Scout-Rule"><a href="#Boy-Scout-Rule" class="headerlink" title="Boy-Scout Rule"></a>Boy-Scout Rule</h2><p>The Boy Scouts of America have a simple rule that we can apply to our profession: “Leave the campground cleaner than you found it”. The boy-scout rule states that we should always leave the code cleaner than we found it.</p><p>Why</p><ul><li>When making changes to an existing codebase the code quality tends to degrade, accumulating technical debt. Following the boyscout rule, we should mind the quality with each commit. Technical debt is resisted by continuous refactoring, no matter how small.</li></ul><p>How</p><ul><li>With each commit make sure it does not degrade the codebase quality.</li><li>Any time someone sees some code that isn’t as clear as it should be, they should take the opportunity to fix it right there and then.</li></ul><p>Resources</p><ul><li><a href="http://martinfowler.com/bliki/OpportunisticRefactoring.html" target="_blank" rel="noopener">Opportunistic Refactoring</a></li></ul><h2 id="Command-Query-Separation"><a href="#Command-Query-Separation" class="headerlink" title="Command Query Separation"></a>Command Query Separation</h2><p>The Command Query Separation principle states that each method should be either a command that performs an action or a query that returns data to the caller but not both. Asking a question should not modify the answer.</p><p>With this principle applied the programmer can code with much more confidence. The query methods can be used anywhere and in any order since they do not mutate the state. With commands one has to be more careful.</p><p>Why</p><ul><li>By clearly separating methods into queries and commands the programmer can code with additional confidence without knowing each method’s implementation details.</li></ul><p>How</p><ul><li>Implement each method as either a query or a command</li><li>Apply naming convention to method names that implies whether the method is a query or a command</li></ul><p>Resources</p><ul><li><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation" target="_blank" rel="noopener">Command Query Separation in Wikipedia</a></li><li><a href="http://martinfowler.com/bliki/CommandQuerySeparation.html" target="_blank" rel="noopener">Command Query Separation by Martin Fowler</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;Programming-Principles&quot;&gt;&lt;a href=&quot;#Programming-Principles&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://www.fufan.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.fufan.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（五）—— 链表</title>
    <link href="http://www.fufan.me/2019/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.fufan.me/2019/02/10/数据结构与算法学习（五）——-链表/</id>
    <published>2019-02-10T10:51:00.000Z</published>
    <updated>2019-03-30T10:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>链表是一种通过指针将一组零散的内存块串在一起。内存块称为“结点”</p><p><img src="/image/data-structure-4-4.jpg" alt=""></p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表的结构如下图，我们可以看到有一个头结点和一个尾结点，尾节点指向空地址null，每个结点存储了两个值：当前节点数据、指向下个节点的指针。<br><img src="/image/data-structure-4-0.jpg" alt=""></p><p>和数组一样，链表也有查询、删除、插入操作，插入和删除操作由于是可以预知的两步操作，所以时间复杂度为O(1), 但是如果要查询某一个值，那么就像是一个队伍里找一个人，每个人只知道前面是谁，也只能从头遍历，时间复杂度就是O(n)</p><p><img src="/image/data-structure-4-3.jpg" alt=""></p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><img src="/image/data-structure-4-1.jpg" alt=""></p><p>循环链表其实很简单，他只不过把单链表的尾节点的指针指向了头结点</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表就是，每个结点存储了三个值：当前节点数据、指向下个结点的指针（后继），指向上一个结点的指针（前驱）。</p><p>他的特点就是他可以通过当前结点获取到前驱结点，时间复杂度为O(1)，而单链表则为O(n)，在某些情况下，这个特性能有比较大的优势。</p><p>像java中的LinkedHashMap就是用到了双向链表。</p><p><img src="/image/data-structure-4-2.jpg" alt=""></p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p>双向+循环即为双向循环链表</p><p><img src="/image/data-structure-4-6.jpg" alt=""></p><h3 id="链表-VS-数组"><a href="#链表-VS-数组" class="headerlink" title="链表 VS 数组"></a>链表 VS 数组</h3><p><img src="/image/data-structure-4-5.jpg" alt=""></p><p>数组的特点是连续存储，访问效率高，但是它需要初始化内存，大小固定。<br>链表大小可以扩，但是他访问效率低，而且如果再java中，频繁的对链表进行插入删除操作，会频繁申请内存和释放，造成内存碎片，可能会导致GC频繁。</p><h3 id="链表的操作技巧和代码"><a href="#链表的操作技巧和代码" class="headerlink" title="链表的操作技巧和代码"></a>链表的操作技巧和代码</h3><h4 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h4><h4 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h4><h4 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h4><h4 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h4><h4 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h4><h4 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h4><p>关于链表的练习题LeetCode对应编号：206，141，21，19，876。大家可以去练习</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="空间和时间的互换思维"><a href="#空间和时间的互换思维" class="headerlink" title="空间和时间的互换思维"></a>空间和时间的互换思维</h4><p>其实这是软件设计和算法思想中经常遇到的一个问题，比如我们在设计接口的时候回考虑到耗时，就会想到用缓存，这就是用空间来换时间。再比如在单片机和手机芯片上，我们需要用时间来换空间。</p><h4 id="用链表实现LRU算法"><a href="#用链表实现LRU算法" class="headerlink" title="用链表实现LRU算法"></a>用链表实现LRU算法</h4><p>经典的LRU缓存算法，即最近最常使用的数据，用链表实现如下步骤：</p><p>一、 从链表中遍历数据，找到后删除该位置的节点，并插入到链表头部。<br>二、 未找到的话，分两种情况：</p><ol><li>链表未满，则插入到链表头部；</li><li>若链表满，则删除尾节点，再插入到链表头部；</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并发编程重新出发（六）——  用“等待-通知”机制优化循环等待</title>
    <link href="http://www.fufan.me/2019/02/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94-%E7%94%A8%E2%80%9C%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E2%80%9D%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/"/>
    <id>http://www.fufan.me/2019/02/09/并发编程重新出发（六）——-用“等待-通知”机制优化循环等待/</id>
    <published>2019-02-09T10:47:00.000Z</published>
    <updated>2019-03-30T10:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>上一篇中，我们看到如何打破死锁，我们通过Allocator的中间类来管理，使用了while的死循环来一直请求拿到两个账号，这里会消耗大量CPU资源，所以这里我们需要通过经典的“等待-通知“的方式优化这个问题。<br>我们先来看现实生活中的一个场景</p><h4 id="完美的就医流程"><a href="#完美的就医流程" class="headerlink" title="完美的就医流程"></a>完美的就医流程</h4><p>在介绍 Java 语言如何支持等待 - 通知机制之前，我们先看一个现实世界里面的就医流程，因为它有着完善的等待 - 通知机制，所以对比就医流程，我们就能更好地理解和应用并发编程中的等待 - 通知机制。<br>就医流程基本上是这样：</p><ol><li>患者先去挂号，然后到就诊门口分诊，等待叫号；</li><li>当叫到自己的号时，患者就可以找大夫就诊了；</li><li>就诊过程中，大夫可能会让患者去做检查，同时叫下一位患者；</li><li>当患者做完检查后，拿检测报告重新分诊，等待叫号；</li><li>当大夫再次叫到自己的号时，患者再去找大夫就诊。</li></ol><p>或许你已经发现了，这个有着完美等待 - 通知机制的就医流程，不仅能够保证同一时刻大夫只为一个患者服务，而且还能够保证大夫和患者的效率。与此同时你可能也会有疑问，“这个就医流程很复杂呀，我们前面描述的等待 - 通知机制相较而言是不是太简单了？”那这个复杂度是否是必须的呢？这个是必须的，我们不能忽视等待 - 通知机制中的一些细节。<br>下面我们来对比看一下前面都忽视了哪些细节。</p><ol><li>患者到就诊门口分诊，类似于线程要去获取互斥锁；当患者被叫到时，类似线程已经获取到锁了。</li><li>大夫让患者去做检查（缺乏检测报告不能诊断病因），类似于线程要求的条件没有满足。</li><li>患者去做检查，类似于线程进入等待状态；然后大夫叫下一个患者，这个步骤我们在前面的等待 - 通知机制中忽视了，这个步骤对应到程序里，本质是线程释放持有的互斥锁。</li><li>患者做完检查，类似于线程要求的条件已经满足；患者拿检测报告重新分诊，类似于线程需要重新获取互斥锁，这个步骤我们在前面的等待 - 通知机制中也忽视了。</li></ol><p>所以加上这些至关重要的细节，综合一下，就可以得出一个完整的等待 - 通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。</p><h4 id="用-synchronized-实现等待-通知机制"><a href="#用-synchronized-实现等待-通知机制" class="headerlink" title="用 synchronized 实现等待 - 通知机制"></a>用 synchronized 实现等待 - 通知机制</h4><p>在 Java 语言里，等待 - 通知机制可以有多种实现方式，比如 Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能轻松实现。<br>如何用 synchronized 实现互斥锁，你应该已经很熟悉了。在下面这个图里，左边有一个等待队列，同一时刻，只允许一个线程进入 synchronized 保护的临界区（这个临界区可以看作大夫的诊室），当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列里等待（相当于患者分诊等待）。<strong>这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。</strong></p><p>如下图：</p><p><img src="/image/concurrent-5-0.jpg" alt=""></p><p>在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。如上图所示，当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。 线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p><p>那线程要求的条件满足时，该怎么通知这个等待的线程呢？很简单，就是 Java 对象的 notify() 和 notifyAll() 方法。我在下面这个图里为你大致描述了这个过程，当条件满足时调用 notify()，会通知等待队列（互斥锁的等待队列）中的线程，告诉它条件曾经满足过。</p><p><img src="/image/concurrent-5-1.jpg" alt=""></p><p>为什么说是曾经满足过呢？因为notify() 只能保证在通知时间点，条件是满足的。而被通知线程的执行时间点和通知的时间点基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。这一点你需要格外注意。</p><p>除此之外，还有一个需要注意的点，被通知的线程要想重新执行，仍然需要获取到互斥锁（因为曾经获取的锁在调用 wait() 时已经释放了）。</p><p>上面我们一直强调 wait()、notify()、notifyAll() 方法操作的等待队列是互斥锁的等待队列，所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait()、this.notify()、this.notifyAll()；如果 synchronized 锁定的是 target，那么对应的一定是 target.wait()、target.notify()、target.notifyAll() 。而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException。</p><h4 id="notify和notifyAll"><a href="#notify和notifyAll" class="headerlink" title="notify和notifyAll"></a>notify和notifyAll</h4><p>首先，尽量使用notifyAll</p><p>区别的话在于notify是随机取队列中的线程通知，notifyAll是通知所有线程，如果队列里就1个线程，那还好，如果队列里多个线程，用的是同一个锁，那么就会可能存在部分线程永远不能被通知到。当然是用notifyAll是肯定没问题，不过同时notifyAll在队列很大的时候的效率上应该是必notify差一点的。这个就是看具体业务逻辑而定了</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>等待 - 通知机制是一种非常普遍的线程间协作的方式。工作中经常看到有同学使用轮询的方式来等待某个状态，其实很多情况下都可以用今天我们介绍的等待 - 通知机制来优化。Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法可以快速实现这种机制，但是它们的使用看上去还是有点复杂，所以你需要认真理解等待队列和 wait()、notify()、notifyAll() 的关系。最好用现实世界做个类比，这样有助于你的理解。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;上一篇中，我们看到如何打破死锁，我们通过Allocator的中间类来管理，使用了while的死循环来一直请求拿到两个账号，这
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并发编程重新出发（五）——  死锁的处理</title>
    <link href="http://www.fufan.me/2019/02/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20%20%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://www.fufan.me/2019/02/07/并发编程重新出发（五）——  死锁的处理/</id>
    <published>2019-02-07T03:45:00.000Z</published>
    <updated>2019-03-30T10:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>死锁是很容易理解的，通俗的说就是两个操作同一时间需要拿到对方想要拿到的资源，导致互相等待不释放的情况。然而在细节上是怎么样处理的，需要分析一下。</p><p>继上节提到的转账问题，我们用 Account.class 作为互斥锁，来解决银行业务里面的转账问题，虽然这个方案不存在并发问题，但是所有账户的转账操作都是串行的，例如账户 A 转账户 B、账户 C 转账户 D 这两个转账操作现实世界里是可以并行的，但是在这个方案里却被串行化了，这样的话，性能太差。</p><p>试想互联网支付盛行的当下，8 亿网民每人每天一笔交易，每天就是 8 亿笔交易；每笔交易都对应着一次转账操作，8 亿笔交易就是 8 亿次转账操作，也就是说平均到每秒就是近 1 万次转账操作，若所有的转账操作都串行，性能完全不能接受。</p><h4 id="向现实世界要答案"><a href="#向现实世界要答案" class="headerlink" title="向现实世界要答案"></a>向现实世界要答案</h4><p>现实世界里，账户转账操作是支持并发的，而且绝对是真正的并行，银行所有的窗口都可以做转账操作。只要我们能仿照现实世界做转账操作，串行的问题就解决了。<br>我们试想在古代，没有信息化，账户的存在形式真的就是一个账本，而且每个账户都有一个账本，这些账本都统一存放在文件架上。银行柜员在给我们做转账时，要去文件架上把转出账本和转入账本都拿到手，然后做转账。这个柜员在拿账本的时候可能遇到以下三种情况：</p><ol><li>文件架上恰好有转出账本和转入账本，那就同时拿走；</li><li>如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；</li><li>转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。</li></ol><p>上面这个过程在编程的世界里怎么实现呢？其实用两把锁就实现了，转出账本一把，转入账本另一把。在 transfer() 方法内部，我们首先尝试锁定转出账户 this（先把转出账本拿到手），然后尝试锁定转入账户 target（再把转入账本拿到手），只有当两者都成功时，才执行转账操作。如下图所示：</p><p><img src="/image/concurrent-4-0.jpg" alt=""></p><p>代码实现应该是这样：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;              </span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target) &#123;           </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="没有免费的午餐"><a href="#没有免费的午餐" class="headerlink" title="没有免费的午餐"></a>没有免费的午餐</h4><p>上面的实现看上去很完美，并且也算是将锁用得出神入化了。相对于用 Account.class 作为互斥锁，锁定的范围太大，而我们锁定两个账户范围就小多了，这样的锁，上一章我们介绍过，叫细粒度锁。<strong>使用细粒度锁可以提高并行度，是性能优化的一个重要手段。</strong></p><p>这个时候可能你已经开始警觉了，使用细粒度锁这么简单，有这样的好事，是不是也要付出点什么代价啊？编写并发程序就需要这样时时刻刻保持谨慎。</p><p><strong>的确，使用细粒度锁是有代价的，这个代价就是可能会导致死锁。</strong></p><p>在详细介绍死锁之前，我们先看看现实世界里的一种特殊场景。如果有客户找柜员张三做个转账业务：账户 A 转账户 B 100 元，此时另一个客户找柜员李四也做个转账业务：账户 B 转账户 A 100 元，于是张三和李四同时都去文件架上拿账本，这时候有可能凑巧张三拿到了账本 A，李四拿到了账本 B。张三拿到账本 A 后就等着账本 B（账本 B 已经被李四拿走），而李四拿到账本 B 后就等着账本 A（账本 A 已经被张三拿走），他们要等多久呢？他们会永远等待下去…因为张三不会把账本 A 送回去，李四也不会把账本 B 送回去。我们姑且称为死等吧。</p><p><img src="/image/concurrent-4-1.jpg" alt=""></p><p>转账业务中的“死等”<br>现实世界里的死等，就是编程领域的死锁了。死锁的一个比较专业的定义是：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。<br>上面转账的代码是怎么发生死锁的呢？我们假设线程 T1 执行账户 A 转账户 B 的操作，账户 A.transfer(账户 B)；同时线程 T2 执行账户 B 转账户 A 的操作，账户 B.transfer(账户 A)。当 T1 和 T2 同时执行完①处的代码时，T1 获得了账户 A 的锁（对于 T1，this 是账户 A），而 T2 获得了账户 B 的锁（对于 T2，this 是账户 B）。之后 T1 和 T2 在执行②处的代码时，T1 试图获取账户 B 的锁时，发现账户 B 已经被锁定（被 T2 锁定），所以 T1 开始等待；T2 则试图获取账户 A 的锁时，发现账户 A 已经被锁定（被 T1 锁定），所以 T2 也开始等待。于是 T1 和 T2 会无期限地等待下去，也就是我们所说的死锁了。</p><h4 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h4><p><strong>并发程序一旦死锁，一般没有特别好的方法，很多时候我们只能重启应用。因此，解决死锁问题最好的办法还是规避死锁。</strong></p><p>那如何避免死锁呢？要避免死锁就需要分析死锁发生的条件，有个叫 Coffman 的牛人早就总结过了，只有以下这四个条件都发生时才会出现死锁：</p><ol><li><p>互斥，共享资源 X 和 Y 只能被一个线程占用；</p></li><li><p>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</p></li><li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li><li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li></ol><p>反过来分析，也就是说只要我们破坏其中一个，就可以成功避免死锁的发生。</p><p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p><ol><li><p>对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</p></li><li><p>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p></li><li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol><h5 id="破坏占用且等待条件"><a href="#破坏占用且等待条件" class="headerlink" title="破坏占用且等待条件"></a>破坏占用且等待条件</h5><p>我们可以修改等待条件，一次性拿到所有资源才等待。比如把申请两个账户都锁住，这样就不会出现两个账户分开在两个线程中的情况。具体的方式可以通过一个中间角色来控制这个请求的申请，比如管理员allocator，合理分配资源。今天代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAccount</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Account accountA = Account.builder().balance(<span class="number">100.0</span>).build();</span><br><span class="line">        Account accountB = Account.builder().balance(<span class="number">200.0</span>).build();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">                accountA.transfer(accountB, <span class="number">0.5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">                accountB.transfer(accountA, <span class="number">0.5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">"accountA balance: %f"</span>, accountA.getBalance()));</span><br><span class="line">        System.out.println(String.format(<span class="string">"accountB balance: %f"</span>, accountB.getBalance()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Double balance;</span><br><span class="line">    Allocator allocator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, Double amount)</span> </span>&#123;</span><br><span class="line">        allocator = Allocator.getInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!allocator.apply(<span class="keyword">this</span>, target));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amount) &#123;</span><br><span class="line">                target.balance = target.balance + amount;</span><br><span class="line">                <span class="keyword">this</span>.balance = <span class="keyword">this</span>.balance - amount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocator.free(<span class="keyword">this</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Allocator allocator = getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Allocator <span class="title">getInstance</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (allocator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Allocator.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allocator == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Allocator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allocator;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Set&lt;Object&gt; locks = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Object from , Object to)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (locks.contains(from) || locks.contains(to)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            locks.add(from);</span><br><span class="line">            locks.add(to);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">void</span> <span class="title">free</span><span class="params">(Object from, Object to)</span> </span>&#123;</span><br><span class="line">        locks.remove(from);</span><br><span class="line">        locks.remove(to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h5><p>破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p><p>虽然Java原生语言层面是没办法做到，但是Java提供了相关的SDK的util包中的类如Lock等是支持该种方式打破死锁的。</p><h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><p>破坏这个条件，需要对资源进行排序，然后按序申请资源。这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当我们在编程世界里遇到问题时，应不局限于当下，可以换个思路，向现实世界要答案，利用现实世界的模型来构思解决方案，这样往往能够让我们的方案更容易理解，也更能够看清楚问题的本质。</p><p>但是现实世界的模型有些细节往往会被我们忽视。因为在现实世界里，人太智能了，以致有些细节实在是显得太不重要了。在转账的模型中，我们为什么会忽视死锁问题呢？原因主要是在现实世界，我们会交流，并且会很智能地交流。而编程世界里，两个线程是不会智能地交流的。所以在利用现实模型建模的时候，我们还要仔细对比现实世界和编程世界里的各角色之间的差异。</p><p>我们今天这一篇文章主要讲了用细粒度锁来锁定多个资源时，要注意死锁的问题。这个就需要你能把它强化为一个思维定势，遇到这种场景，马上想到可能存在死锁问题。当你知道风险之后，才有机会谈如何预防和避免，因此，识别出风险很重要。</p><p>预防死锁主要是破坏三个条件中的一个，有了这个思路后，实现就简单了。但仍需注意的是，有时候预防死锁成本也是很高的。</p><p>所以我们在选择具体方案的时候，还需要评估一下操作成本，从中选择一个成本最低的方案。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;死锁是很容易理解的，通俗的说就是两个操作同一时间需要拿到对方想要拿到的资源，导致互相等待不释放的情况。然而在细节上是怎么样处
      
    
    </summary>
    
      <category term="并发编程" scheme="http://www.fufan.me/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://www.fufan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程重新出发（四）——  Java解决原子性问题</title>
    <link href="http://www.fufan.me/2019/02/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94-Java%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98-1/"/>
    <id>http://www.fufan.me/2019/02/03/并发编程重新出发（四）——-Java解决原子性问题-1/</id>
    <published>2019-02-03T10:45:00.000Z</published>
    <updated>2019-03-30T10:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>上篇文章我们已经看到Java线程模型如何解决有序性和可见性。那么如何解决原子性，而单独拿出来分析原子性，可见原子性的复杂度相对较高。</p><p>在单核CPU中，我们知道一个时刻只能执行一个线程，是可以保证原子性的，而多核CPU时，我们必须通过限制不同线程对共享变量的修改是<strong>互斥的</strong>，才能保证既可以提高性能，又能保证操作的原子性。</p><h4 id="简易锁模型"><a href="#简易锁模型" class="headerlink" title="简易锁模型"></a>简易锁模型</h4><p><img src="/image/concurrent-3-0.jpg" alt=""></p><p>我们把一段需要互斥执行的代码称为临界区。线程在进入临界区之前，首先尝试加锁 lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁 unlock()。<br>这个过程非常像办公室里高峰期抢占坑位，每个人都是进坑锁门（加锁），出坑开门（解锁），如厕这个事就是临界区。很长时间里，我也是这么理解的。这样理解本身没有问题，但却很容易让我们忽视两个非常非常重要的点：我们锁的是什么？我们保护的又是什么？</p><h4 id="改进后的锁模型"><a href="#改进后的锁模型" class="headerlink" title="改进后的锁模型"></a>改进后的锁模型</h4><p>我们知道在现实世界里，锁和锁要保护的资源是有对应关系的，比如你用你家的锁保护你家的东西，我用我家的锁保护我家的东西。在并发编程世界里，锁和资源也应该有这个关系，但这个关系在我们上面的模型中是没有体现的，所以我们需要完善一下我们的模型。</p><p><img src="/image/concurrent-3-1.jpg" alt=""></p><p>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；其次，我们要保护资源 R 就得为它创建一把锁 LR；最后，针对这把锁 LR，我们还需在进出临界区时添上加锁操作和解锁操作。另外，在锁 LR 和受保护资源之间，我特地用一条线做了关联，这个关联关系非常重要。很多并发 Bug 的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的 Bug 非常不好诊断，因为潜意识里我们认为已经正确加锁了。</p><h4 id="Java中提供的原生锁-synchronized"><a href="#Java中提供的原生锁-synchronized" class="headerlink" title="Java中提供的原生锁 synchronized"></a>Java中提供的原生锁 synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰代码块</span></span><br><span class="line">  Object obj = <span class="keyword">new</span> Object()；</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完之后你可能会觉得有点奇怪，这个和我们上面提到的模型有点对不上号啊，加锁 lock() 和解锁 unlock() 在哪里呢？其实这两个操作都是有的，只是这两个操作是被 Java 默默加上的，Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()，这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的，毕竟忘记解锁 unlock() 可是个致命的 Bug（意味着其他线程只能死等下去了）。<br>那 synchronized 里的加锁 lock() 和解锁 unlock() 锁定的对象在哪里呢？上面的代码我们看到只有修饰代码块的时候，锁定了一个 obj 对象，那修饰方法的时候锁定的是什么呢？这个也是 Java 的一条隐式规则：</p><ul><li>当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；</li><li>当修饰非静态方法的时候，锁定的是当前实例对象 this。</li></ul><p>即修饰静态方法的话：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span>(X.class) <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>非静态方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个模型更像现实世界里面球赛门票的管理，一个座位只允许一个人使用，这个座位就是“受保护资源”，球场的入口就是 Java 类里的方法，而门票就是用来保护资源的“锁”，Java 里的检票工作是由 synchronized 解决的。</p><h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><p>锁的粒度可以衡量你锁资源的范围。<br>就类比我们房子里，大门有一把锁，是为了防住陌生人。而房间锁是我们家人自己房间的锁，是为了防家里人，锁的范围不同意义不同。</p><p>那么编程当中为什么要提出锁的粒度呢，其实我们锁的优化就一直在解决这个问题。什么样的锁适合什么样的场景。比如对象之间没有关联关系的话，你可以通过锁定方法就可以；但是如果对象之间存在对某个资源的操作先后顺序问题，就需要将锁粒度变大，比如转账，我们会需要锁住的不仅仅是自己的余额，同时也要锁住对方的余额，那么代码应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Account.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">        target.balance += amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以解决转账锁住所有Account对象的问题，但是随即你会发现这样处理的话，那么所有的转账操作都是要锁住，那么此时串行操作效率极低，所以我们需要优化该部分。<br>后面一节提到死锁的时候还会继续分析该问题。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>互斥锁，在并发领域的知名度极高，只要有了并发问题，大家首先容易想到的就是加锁，因为大家都知道，加锁能够保证执行临界区代码的互斥性。这样理解虽然正确，但是却不能够指导你真正用好互斥锁。临界区的代码是操作受保护资源的路径，类似于球场的入口，入口一定要检票，也就是要加锁，但不是随便一把锁都能有效。所以必须深入分析锁定的对象和受保护资源的关系，综合考虑受保护资源的访问路径，多方面考量才能用好互斥锁。</p><p>synchronized 是 Java 在语言层面提供的互斥原语，其实 Java 里面还有很多其他类型的锁，但作为互斥锁，原理都是相通的：锁，一定有一个要锁定的对象，至于这个锁定的对象要保护的资源以及在哪里加锁 / 解锁，就属于设计层面的事情了。</p><p><strong>“原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。</strong> 例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。<strong>所以解决原子性问题，是要保证中间状态对外不可见。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;上篇文章我们已经看到Java线程模型如何解决有序性和可见性。那么如何解决原子性，而单独拿出来分析原子性，可见原子性的复杂度相
      
    
    </summary>
    
      <category term="并发编程" scheme="http://www.fufan.me/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://www.fufan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程重新出发（三）——  Java内存模型如何解决有序性和可见性</title>
    <link href="http://www.fufan.me/2019/02/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%9C%89%E5%BA%8F%E6%80%A7%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>http://www.fufan.me/2019/02/02/并发编程重新出发（三）——-Java内存模型如何解决有序性和可见性/</id>
    <published>2019-02-02T08:29:00.000Z</published>
    <updated>2019-03-30T10:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><ul><li>什么是JAVA内存模型</li><li>Java内存模型涉及的几个关键词</li><li>Happens-Before的7个规则</li></ul><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。</p><p>我们知道，导致可见性的原因是缓存，导致有序性的原因是编译优化。合理方案就是按需禁用缓存和编译优化，Java中使用volatile、synchronized和final三个关键字。，以及happens-before规则。</p><h3 id="Java内存模型涉及的几个关键词"><a href="#Java内存模型涉及的几个关键词" class="headerlink" title="Java内存模型涉及的几个关键词"></a>Java内存模型涉及的几个关键词</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。Java1.5之后对volatile进行了增强，其本质就是加了happens-before规则。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。</p><h3 id="Happens-Before的7个规则"><a href="#Happens-Before的7个规则" class="headerlink" title="Happens-Before的7个规则"></a>Happens-Before的7个规则</h3><p>(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。<br>(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。<br>(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序。<br>(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。<br>(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p><p><strong>Happens-Before的1个特性：传递性。</strong></p><h3 id="Java内存模型底层怎么实现的"><a href="#Java内存模型底层怎么实现的" class="headerlink" title="Java内存模型底层怎么实现的"></a>Java内存模型底层怎么实现的</h3><p>主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;ul&gt;&lt;li&gt;什么是JAVA内存模型&lt;/li&gt;&lt;li&gt;Java内存模型涉及的几个关键词&lt;/li&gt;&lt;li&gt;Happens-Befo
      
    
    </summary>
    
      <category term="并发编程" scheme="http://www.fufan.me/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://www.fufan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程重新出发（二）——  有序性、原子性、可见性</title>
    <link href="http://www.fufan.me/2019/01/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>http://www.fufan.me/2019/01/26/并发编程重新出发（二）——-有序性、原子性、可见性/</id>
    <published>2019-01-26T07:47:00.000Z</published>
    <updated>2019-03-09T07:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>并发编程bug的源头：</p><ul><li>有序性</li><li>原子性</li><li>可见性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发编程源头故事</span><br><span class="line"></span><br><span class="line">自从发明出计算机以后，我们知道冯诺依曼的结构，我们一直在解决一个问题：CPU、内存、IO三者之前速度的差异。我们做了这些</span><br><span class="line"></span><br><span class="line">* 1. CPU增加了缓存</span><br><span class="line">* 2. 操作系统增加了线程、进程，来分时复用CPU，进而平衡CPU和IO之前的速度差异</span><br><span class="line">* 3. 编译指令的执行顺序优化，以便更好地利用缓存。</span><br></pre></td></tr></table></figure><h3 id="源头之一：存储导致可见性"><a href="#源头之一：存储导致可见性" class="headerlink" title="源头之一：存储导致可见性"></a>源头之一：存储导致可见性</h3><p>在单核时代，我们只有一块CPU，那么我们在CPU的缓存也只有一份，那么不同线程通过缓存取到的值也是确定的。</p><p><strong>可见性：一个线程对变量进行修改后，其他线程能及时看到。</strong></p><p>但是到了多核时代，我们可以看到每块CPU都有自己的缓存，那么就会出现如何同步内存和CPU缓存的一个问题。比如下图，线程A操作的是CPU-1的缓存v变量，而线程B是CPU-2的v变量，就不具备可见性了</p><p><img src="/image/concurrent-1-0.jpg" alt=""></p><h3 id="源头之二：线程切换带来的原子性问题"><a href="#源头之二：线程切换带来的原子性问题" class="headerlink" title="源头之二：线程切换带来的原子性问题"></a>源头之二：线程切换带来的原子性问题</h3><p>当然，在早期的单核时代，我们也是支持多任务的，也就是统一个CPU是可以支持多个进程切换的方式来执行指令。操作系统会允许某个进程执行一段时间，然后切换到另一个进程，这一段就叫’时间片‘。</p><p>线程切换示意图</p><p><img src="/image/concurrent-1-1.jpg" alt=""></p><p>在一个时间片中，如果一个进程停留在读IO的话，就没必要占用CPU了，就会休眠此线程，让出CPU使用权，待IO完成，就会被操作系统在休眠中被唤醒。唤醒后的进程就有机会重新获取使用权了。这种支持CPU分时复用的方式，最早是Unix提出并应用。</p><p>java中主要指的多线程之间的切换，任务切换大多数是时间片结束的时候，我们使用高级语言中一条语句基本会分成几条CPU指令来执行，如count += 1；需要三条指令：</p><ol><li>获取count的值</li><li>在寄存器中 + 1 操作；</li><li>将结果写进内存</li></ol><p>我们知道，CPU指令是不知道目前执行的是哪个线程给的，所以可以发生在任一时刻，当A线程在操作2的时候CPU执行权被抢走的话，如果B线程也在操作count时，在回到A的时候，继续讲count+1存入内存，那就会丢失B线程对count的操作记录。如下图：</p><p><img src="/image/concurrent-1-2.jpg" alt=""></p><p><strong>原子性：一个或者多个操作在CPU执行的过程中不被终端的特性</strong></p><p>源头三：编译优化带来的指令有序性问题</p><p>之前提到过，编译器为了优化指令，在不影响结果的情况下，可能会对CPU的部分指令进行指令重排序。经典的java案例就是双重检测加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  static Singleton instance;</span><br><span class="line">  static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家都结果了，这里直接上图：</p><p><img src="/image/concurrent-1-3.jpg" alt=""></p><p>我们解决方法就是把instance变量设为volatile，该关键字可以保证防止指令重排序和可见性，但不能保证原子性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上三点是我们在排查并发BUG时，通常会出现，我觉得这三点是本质上的原因，值得我们好好理解。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;并发编程bug的源头：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;有序性&lt;/li&gt;&lt;li&gt;原子性&lt;/li&gt;&lt;li&gt;可见性&lt;/li&gt;&lt;/ul&gt;&lt;f
      
    
    </summary>
    
      <category term="并发编程" scheme="http://www.fufan.me/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://www.fufan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（四）—— 数组</title>
    <link href="http://www.fufan.me/2019/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E6%95%B0%E7%BB%84/"/>
    <id>http://www.fufan.me/2019/01/15/数据结构与算法学习（三）——-数组/</id>
    <published>2019-01-15T15:41:00.000Z</published>
    <updated>2019-03-30T10:52:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数组</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="线性表（linear-list）"><a href="#线性表（linear-list）" class="headerlink" title="线性表（linear list）"></a>线性表（linear list）</h4><p>就是数据排成一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，除了数组以外还有链表、队列、栈等。<br><img src="/image/data-structure-3-0.jpg" alt=""><br>与他相对的是非线性表，如二叉树,堆，图等<br><img src="/image/data-structure-3-1.jpg" alt=""></p><h4 id="连续的内存空间和相同的数据类型"><a href="#连续的内存空间和相同的数据类型" class="headerlink" title="连续的内存空间和相同的数据类型"></a>连续的内存空间和相同的数据类型</h4><p>之所以他可以随机访问的原因就在于它是连续存储的，你可以通过数组下表和首地址来获取到所在位置的内存地址并访问。当然这也使得如果要在数组中删除和插入数据时，需要做大量数据搬运的工作，显得低效。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h5 id="如何优化-低效的插入和删除"><a href="#如何优化-低效的插入和删除" class="headerlink" title="如何优化 低效的插入和删除"></a>如何优化 低效的插入和删除</h5><p>我们可以算出，插入和删除的平均时间复杂度都为O(n)。</p><p><img src="/image/data-structure-3-2.jpg" alt=""></p><p>如上图所示，当我们需要删除abc的时候，正常的操作就会搬移defgh这些数据3次，我们可以先记录下已删除的数据，每次删除操作都不是真正的搬移数据，而是记录已经被删除的，当数组没有空间时，我们再执行删除操作，这是一种思维。其实JVM中的标记清除算法也是用到了这种思想。</p><h4 id="数组为何从0开始编号"><a href="#数组为何从0开始编号" class="headerlink" title="数组为何从0开始编号"></a>数组为何从0开始编号</h4><p>可以想象，机器在计算数组内存地址的时候，下标就是偏移，公式为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><p></p><p>如果1开始计数的话，就会变为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p></p><p>对于两个公式来说，CPU是多了一次减法指令的，数组是很基础的一个数据结构，就要把优化做到极致。</p><p>最早是C语言是最早用0开始计数的，其他语言也纷纷效仿</p><h4 id="容器能否代替数组"><a href="#容器能否代替数组" class="headerlink" title="容器能否代替数组"></a>容器能否代替数组</h4><p>java中的ArrayList是大多是java开发工程师最多接触的类型，ArrayList 最大的优势就是可以将很多数组操作的细节封装起来，像插入删除等，另外还能支持动态扩容。但是扩容的话原理是这样的，因为原生的数组是必须初始化大小的，而即使是ArrayList也是一样的，他初始化固定的大小10个元素，而扩容时会增加原来的1.5倍大小，但是扩容过程的话是会涉及到内存申请、数组的拷贝和搬移，所以最好是初始化的时候指定ArrayList大小，这样会省去很多次内存申请和数据搬移操作。</p><p>当然，我们也同样可以列出原生数组的优势：</p><ul><li>ArrayList是不能装原生类型的，如int、long等，只能放包装类Integer、Long。</li><li>数据量大小已知的情况下，且使用数组操作简单时，数组更优</li><li>多维数组时，往往用数组更直观，如Object[][]</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP连接的几个TIMEOUT</title>
    <link href="http://www.fufan.me/2019/01/13/http%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%87%A0%E4%B8%AATimeout/"/>
    <id>http://www.fufan.me/2019/01/13/http连接的几个Timeout/</id>
    <published>2019-01-13T14:32:00.000Z</published>
    <updated>2019-03-05T14:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><h3 id="HTTP连接的几个TIMEOUT"><a href="#HTTP连接的几个TIMEOUT" class="headerlink" title="HTTP连接的几个TIMEOUT"></a>HTTP连接的几个TIMEOUT</h3><ol><li><p>connectTimeOut：指建立连接的超时时间，比较容易理解</p></li><li><p>connectionRequestTimeOut：指从连接池获取到连接的超时时间，如果是非连接池的话，该参数暂时没有发现有什么用处</p></li><li>socketTimeOut：指客户端和服务进行数据交互的时间，是指两者之间如果两个数据包之间的时间大于该时间则认为超时，而不是整个交互的整体时间，比如如果设置1秒超时，如果每隔0.8秒传输一次数据，传输10次，总共8秒，这样是不超时的。而如果任意两个数据包之间的时间超过了1秒，则超时。</li></ol><p>线上问题：设置sockettimeout 15秒，但是实际到达156秒，线程数陡增，导致机器崩溃，具体原因有待抓包分析</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;HTTP连接的几个TIMEOUT&quot;&gt;&lt;a href=&quot;#HTTP连接的几个TIMEOUT&quot; class=&quot;head
      
    
    </summary>
    
      <category term="http" scheme="http://www.fufan.me/categories/http/"/>
    
    
      <category term="http" scheme="http://www.fufan.me/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（三）—— 复杂度分析（下）</title>
    <link href="http://www.fufan.me/2019/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://www.fufan.me/2019/01/08/数据结构与算法学习（三）——-复杂度分析（下）/</id>
    <published>2019-01-08T10:50:00.000Z</published>
    <updated>2019-03-30T10:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>浅析最好、最坏、平均、均摊时间复杂度</p><ul><li>最好时间复杂度</li><li>最坏时间复杂度</li><li>平均时间复杂度</li><li>均摊时间复杂度</li></ul><h4 id="最好、最坏时间复杂度"><a href="#最好、最坏时间复杂度" class="headerlink" title="最好、最坏时间复杂度"></a>最好、最坏时间复杂度</h4><p>举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码主要是找x在arr的位置，不存在则返回-1，这种情况下如果数组第一个位置即为x，则我们称之为最好情况O(1),反之当最末尾为x时则为最坏情况O(n)</p><h4 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h4><p>极端情况下发生的概率不大，我们需要的是一个平均情况，所以这里可以分析一下：</p><p>由于总共有n+1种情况，然后在每个位置上的次数是1+2+3……+n+n，总和除以n+1，如下图<br><img src="/image/data-structure-2-0.jpg" alt=""></p><p>可以得到平均时间复杂度为O(n)</p><p>不过我们这里需要加一个概率的因素，在和不在概率是1/2，同时在0~n-1的位置出现概率也是1/n，所以查找数据在任意位置出现的概率为1/2n，结果如下图</p><p><img src="/image/data-structure-2-1.jpg" alt=""></p><p>此为加权平均值，也叫期望值，当然结果仍然是O(n)</p><h4 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h4><p>其实就是特殊的平均时间复杂度，暂时可以这么理解。一般情况下，均摊以后，接近最好情况时间复杂度</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;浅析最好、最坏、平均、均摊时间复杂度&lt;/p&gt;&lt;ul&gt;&lt;li&gt;最好时间复杂度&lt;/li&gt;&lt;li&gt;最坏时间复杂度&lt;/li&gt;&lt;li&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（二）—— 复杂度分析（上）</title>
    <link href="http://www.fufan.me/2019/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://www.fufan.me/2019/01/02/数据结构与算法学习（一）——-复杂度分析/</id>
    <published>2019-01-02T02:07:00.000Z</published>
    <updated>2019-02-21T15:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>复杂度分析是算法学习的精髓，对面任何代码和场景下，都需要学会分析其复杂度分析</p><h4 id="为什么需要复杂度分析"><a href="#为什么需要复杂度分析" class="headerlink" title="为什么需要复杂度分析"></a>为什么需要复杂度分析</h4><ol><li><p>测试结果依赖测试环境</p></li><li><p>测试结果受数据规模的影响很大</p></li></ol><h4 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h4><p>下面通过例子来表示如何计算复杂度</p><h5 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i ++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码我们把每一行作为一个CPU执行的unit_time，那么算起来执行的次数为2n+2次，那么我们可以算出T(n)=O(n)</p><h5 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i ++) &#123;</span><br><span class="line">       j = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> ( ; j &lt; n; j ++) &#123;</span><br><span class="line">            sum += i*j;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，我们也可以得到执行次数为2n²+2n+3 次，所以我们得到T(n)=O(n²)</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><ol><li><p>只关注循环执行次数最多的那段代码</p></li><li><p>加发法则，总复杂度等于量级最大的那段代码的复杂度<br>如果T1(n)=O(f(n)), T2(n)=O(g(n));那么T(n)=T1 + T2 = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))</p></li><li><p>乘法法则：嵌套代码复杂度等于内外嵌套代码复杂度乘积<br>T1(n)=O(f(n)), T2(n)=O(g(n));那么T(n)=T1 + T2 = T1(n) <em>T2(n) = O(f(n)</em>g(n))</p></li></ol><h4 id="常见的几种复杂度"><a href="#常见的几种复杂度" class="headerlink" title="常见的几种复杂度"></a>常见的几种复杂度</h4><h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><p>一般情况下，如果算法中没有循环语句、递归语句，即使上万行代码，复杂度也是O(1)</p><h5 id="O-logn-O-nlogn"><a href="#O-logn-O-nlogn" class="headerlink" title="O(logn),O(nlogn)"></a>O(logn),O(nlogn)</h5><p>比如下面这行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line"> i = i * <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>i从1开始取，每次乘以2 ，可以算出这个while循环的执行次数就是log2n，即O(log2n)</p><p>再可以改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line"> i = i * <span class="number">3</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此时为O(log3n)，由于对数互相转换，加上复杂度里常量可以忽略，这种情况我们可以都记为O(logn)。</p><p>O(nlogn)可以借助前面的乘法法则，可以举出例子。</p><h5 id="O-m-n-O-m-n"><a href="#O-m-n-O-m-n" class="headerlink" title="O(m+n), O(m*n)"></a>O(m+n), O(m*n)</h5><p>当我们引入两个未知循环次数的变量m,n时，就会得到 T1(m) + T2(n) = O(f(m) + g(n))</p><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><p>空间复杂度相对来说比较容易分析，</p><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系，空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的关系</p><p>常见的有O(1), O(n), O(n²)，像O(logn), O(nlogn)就很少见了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;复杂度分析是算法学习的精髓，对面任何代码和场景下，都需要学会分析其复杂度分析&lt;/p&gt;&lt;h4 id=&quot;为什么需要复杂度分析&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（一）—— 绪论</title>
    <link href="http://www.fufan.me/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E7%BB%AA%E8%AE%BA/"/>
    <id>http://www.fufan.me/2019/01/01/数据结构与算法学习（一）——-绪论/</id>
    <published>2018-12-31T18:06:00.000Z</published>
    <updated>2019-03-30T10:53:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><h3 id="什么是数据结构？什么是算法？"><a href="#什么是数据结构？什么是算法？" class="headerlink" title="什么是数据结构？什么是算法？"></a>什么是数据结构？什么是算法？</h3><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p><h3 id="一张图概括内容"><a href="#一张图概括内容" class="headerlink" title="一张图概括内容"></a>一张图概括内容</h3><p><img src="/image/data-structure-0-0.jpg" alt=""></p><h3 id="20个核心知识点"><a href="#20个核心知识点" class="headerlink" title="20个核心知识点"></a>20个核心知识点</h3><p>10个数据结构：数组、链表、队列、栈、散列表、堆、二叉树、跳表、图、Trie树；</p><p>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法；</p><h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><ol><li><p>边学边练、适度刷题</p></li><li><p>多问、多思考、不逃避问题</p></li><li><p>打怪升级学习</p></li><li><p>慢慢沉淀，切忌死记</p></li></ol><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><p>《算法导论》<br>《大话数据结构》<br>《剑指OFFER》</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;什么是数据结构？什么是算法？&quot;&gt;&lt;a href=&quot;#什么是数据结构？什么是算法？&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java多线程系列（十）——ReentrantLock的使用</title>
    <link href="http://www.fufan.me/2018/12/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94ReentrantLock%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.fufan.me/2018/12/24/java多线程系列（十）——ReentrantLock的使用/</id>
    <published>2018-12-24T08:17:00.000Z</published>
    <updated>2018-12-24T08:18:01.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>在java中我们在多线程中使用锁的话一般会用到synchronized和ReentrantLock的两种方式，有以下几个不同的层面：</p><ol><li>实现<br>synchronized是基于JVM层面实现的，而Lock是基于JDK层面实现的</li><li>使用<br>synchronized的使用相对简单，只需要针对对象加上关键字即可。ReentrantLock需要手动进行lock和unlock，同时还有相关封装的api</li><li>其他特点<br>ReentrantLock支持锁超时获取、锁中断响应、公平锁，而synchronized也在jdk1.5后引入了偏向锁，轻量级锁和重量级锁，从而大大的提高了synchronized的性能。</li></ol><p>下面主要介绍一下ReentrantLock的使用</p><h3 id="锁超时获取"><a href="#锁超时获取" class="headerlink" title="锁超时获取"></a>锁超时获取</h3><p>通过tryLock(long time, TimeUnit unit)的api来控制超时时间，返回true则获取到锁，返回false则锁被占用，是一个非阻塞方法，测试方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试锁超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReetrantLockTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                        log.info(<span class="string">"get lock thread &#123;&#125;"</span>, Thread.currentThread().getName()) ;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">"get lock error thread &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                        log.info(<span class="string">"get lock thread &#123;&#125;"</span>, Thread.currentThread().getName()) ;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">"get lock error thread &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16:04:33.502 [t2] ERROR thread.lock.ReetrantLockTest2 - get lock error thread t2</span><br><span class="line">16:04:33.502 [t1] INFO thread.lock.ReetrantLockTest2 - get lock thread t1</span><br></pre></td></tr></table></figure><p></p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。直接上代码，来演示使用重入锁如何解决死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KillDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KillDeadLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">                lock1.lockInterruptibly();  <span class="comment">// 以可以响应中断的方式加锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockInterruptibly();  <span class="comment">// 以可以响应中断的方式加锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"&#123;&#125; interrupted"</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) lock1.unlock();  <span class="comment">// 注意判断方式</span></span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) lock2.unlock();</span><br><span class="line">            log.error( <span class="string">"退出 &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        KillDeadLock deadLock1 = <span class="keyword">new</span> KillDeadLock(<span class="number">1</span>);</span><br><span class="line">        KillDeadLock deadLock2 = <span class="keyword">new</span> KillDeadLock(<span class="number">2</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(deadLock1, <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(deadLock2, <span class="string">"t2"</span>);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16:12:27.660 [t2] ERROR thread.lock.KillDeadLock - t2 interrupted</span><br><span class="line">16:12:27.673 [t2] ERROR thread.lock.KillDeadLock - 退出 t2</span><br><span class="line">16:12:27.673 [t1] ERROR thread.lock.KillDeadLock - 退出 t1</span><br></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLockTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                log.info(<span class="string">" &#123;&#125; 获取到了锁！"</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        FairLockTest test = <span class="keyword">new</span> FairLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test, <span class="string">"线程1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test, <span class="string">"线程2"</span>);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">16:12:43.884 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.884 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.884 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.884 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock-配合-Conditond-使用"><a href="#ReentrantLock-配合-Conditond-使用" class="headerlink" title="ReentrantLock 配合 Conditond 使用"></a>ReentrantLock 配合 Conditond 使用</h4><p>配合关键字synchronized使用的方法如：await()、notify()、notifyAll()，同样配合ReentrantLock 使用的Conditon提供了以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 类似于Object.wait()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>; <span class="comment">// 与await()相同，但不会再等待过程中响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>; <span class="comment">// 类似于Obejct.notify()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    log.info(<span class="string">"into lock thread1"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    log.info(<span class="string">"get CPU again lock time: &#123;&#125;"</span>, lock.getHoldCount());</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    log.info(<span class="string">"get CPU again 2 lock time: &#123;&#125;"</span>, lock.getHoldCount());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"error"</span>, e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    log.info(<span class="string">"into lock thread2"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"error"</span>, e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16:15:24.970 [Thread-0] INFO thread.lock.ReentrantLockTest - into lock thread1</span><br><span class="line">16:15:27.980 [Thread-1] INFO thread.lock.ReentrantLockTest - into lock thread2</span><br><span class="line">16:15:30.986 [Thread-0] INFO thread.lock.ReentrantLockTest - get CPU again lock time: 1</span><br><span class="line">16:15:33.990 [Thread-0] INFO thread.lock.ReentrantLockTest - get CPU again 2 lock time: 2</span><br></pre></td></tr></table></figure><p>ReentrantLock的基本使用就先介绍到这里</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在java中我们在多线程中使用锁的话一般会用到synchronized和ReentrantLock的两种方式，有以下几个不同
      
    
    </summary>
    
      <category term="多线程" scheme="http://www.fufan.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.fufan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程系列（九）—— JUC中的阻塞队列</title>
    <link href="http://www.fufan.me/2018/12/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94-JUC%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://www.fufan.me/2018/12/06/java多线程系列（九）——-JUC中的阻塞队列/</id>
    <published>2018-12-06T04:00:00.000Z</published>
    <updated>2018-12-06T06:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><h3 id="阻塞队列概要"><a href="#阻塞队列概要" class="headerlink" title="阻塞队列概要"></a>阻塞队列概要</h3><h4 id="阻塞队列说明"><a href="#阻塞队列说明" class="headerlink" title="阻塞队列说明"></a>阻塞队列说明</h4><p>阻塞队列与我们平常接触的普通队列(LinkedList或ArrayList等)的最大不同点，在于阻塞队列支出阻塞添加和阻塞删除方法。</p><ul><li>阻塞添加<br>所谓的阻塞添加是指当阻塞队列元素已满时，队列会阻塞加入元素的线程，直队列元素不满时才重新唤醒线程执行元素加入操作。</li><li>阻塞删除<br>阻塞删除是指在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作(一般都会返回被删除的元素)</li></ul><p>由于Java中的阻塞队列接口BlockingQueue继承自Queue接口，因此先来看看阻塞队列接口为我们提供的主要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</span></span><br><span class="line">    <span class="comment">//在成功时返回 true，如果此队列已满，则抛IllegalStateException。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） </span></span><br><span class="line">    <span class="comment">// 将指定的元素插入此队列的尾部，如果该队列已满， </span></span><br><span class="line">    <span class="comment">//则在到达指定的等待时间之前等待可用的空间,该方法可中断 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，如果没有元素则等待（阻塞）， </span></span><br><span class="line">    <span class="comment">//直到有元素将唤醒等待线程执行该操作 </span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，在指定的等待时间前一直等到获取元素， //超过时间方法将结束</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从此队列中移除指定元素的单个实例（如果存在）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除了上述方法还有继承自Queue接口的方法 </span></span><br><span class="line">    <span class="comment">//获取但不移除此队列的头元素,没有则跑异常NoSuchElementException </span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取但不移除此队列的头；如果此队列为空，则返回 null。 </span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头，如果此队列为空，则返回 null。 </span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>插入方法：<br>add(E e) : 添加成功返回true，失败抛IllegalStateException异常<br>offer(E e) : 成功返回 true，如果此队列已满，则返回 false。<br>put(E e) :将元素插入此队列的尾部，如果该队列已满，则一直阻塞</p></li><li><p>删除方法:<br>remove(Object o) :移除指定元素,成功返回true，失败返回false<br>poll() : 获取并移除此队列的头元素，若队列为空，则返回 null<br>take()：获取并移除此队列头元素，若没有元素则一直阻塞。</p></li><li><p>检查方法<br>element() ：获取但不移除此队列的头元素，没有元素则抛异常<br>peek() :获取但不移除此队列的头；若队列为空，则返回 null。</p></li></ul><h4 id="阻塞队列的成员"><a href="#阻塞队列的成员" class="headerlink" title="阻塞队列的成员"></a>阻塞队列的成员</h4><table><thead><tr><th>队列</th><th>有界性</th><th>锁 数据结构</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>bounded(有界)</td><td>加锁 arrayList</td></tr><tr><td>LinkedBlockingQueue</td><td>optionally-bounded</td><td>加锁 linkedList</td></tr><tr><td>PriorityBlockingQueue</td><td>unbounded</td><td>加锁 heap</td></tr><tr><td>DelayQueue</td><td>unbounded</td><td>加锁 heap</td></tr><tr><td>SynchronousQueue</td><td>bounded</td><td>加锁 无</td></tr><tr><td>LinkedTransferQueue</td><td>unbounded</td><td>加锁 heap</td></tr><tr><td>LinkedBlockingDeque</td><td>unbounded</td><td>无锁 heap</td></tr></tbody></table><p>下面分别简单介绍一下：</p><ul><li>ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁】</li><li>LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。此队列按照先进先出的顺序进行排序。</li><li>PriorityBlockingQueue： 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</li><li>DelayQueue： 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（DelayQueue可以运用在以下应用场景：1.缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。2.定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。）</li><li>SynchronousQueue： 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li><li>LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</li><li>LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</li></ul><p>这里主要介绍阻塞队列中的两个实现类ArrayBlockingQueue和LinkedBlockingQueue的简单使用和实现原理</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>一个用数组实现的有界阻塞队列，其内部按先进先出的原则对元素进行排序</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>ArrayBlockingQueue的内部是通过一个可重入锁ReentrantLock和两个Condition条件对象来实现阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 存储数据的数组 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**获取数据的索引，主要用于take，poll，peek，remove方法 */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**添加数据的索引，主要用于 put, offer, or add 方法*/</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列元素的个数 */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 控制并非访问的锁 */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**notFull条件对象，用于通知put方法队列未满，可执行添加操作 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素的添加"><a href="#元素的添加" class="headerlink" title="元素的添加"></a>元素的添加</h5><p>这里的add方法和offer方法实现比较简单，其中需要注意的是enqueue(E x)方法，其方法内部通过putIndex索引直接将元素添加到数组items中，这里可能会疑惑的是当putIndex索引大小等于数组长度时，需要将putIndex重新设置为0，这是因为当前队列执行元素获取时总是从队列头部获取，而添加元素从中从队列尾部获取所以当队列索引（从0开始）与数组长度相等时，下次我们就需要从数组头部开始添加了</p><h6 id="add、offer、put"><a href="#add、offer、put" class="headerlink" title="add、offer、put"></a>add、offer、put</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add方法实现，间接调用了offer(e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (offer(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//offer方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     checkNotNull(e);<span class="comment">//检查元素是否为null</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();<span class="comment">//加锁</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (count == items.length)<span class="comment">//判断队列是否满</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             enqueue(e);<span class="comment">//添加元素到队列</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//通过putIndex索引对数组进行赋值</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">//索引自增，如果已是最后一个位置，重新设置 putIndex = 0;</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;<span class="comment">//队列中元素数量加1</span></span><br><span class="line">    <span class="comment">//唤醒调用take()方法的线程，执行元素获取操作。</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">put方法是一个阻塞的方法，如果队列元素已满，那么当前线程将会被notFull条件对象挂起加到等待队列中，直到队列有空档才会唤醒执行添加操作。但如果队列没有满，那么就直接调用enqueue(e)方法将元素加入到数组队列中。到此我们对三个添加方法即put，offer，add都分析完毕，其中offer，add在正常情况下都是无阻塞的添加，而put方法是阻塞添加。这就是阻塞队列的添加过程。说白了就是当队列满时通过条件对象Condtion来阻塞当前调用put方法的线程，直到线程又再次被唤醒执行。总得来说添加线程的执行存在以下两种情况，一是，队列已满，那么新到来的put线程将添加到notFull的条件队列中等待，二是，有移除线程执行移除操作，移除成功同时唤醒put线程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//put方法，阻塞时可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lockInterruptibly();<span class="comment">//该方法可中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == items.length)</span><br><span class="line">              <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中等待唤醒</span></span><br><span class="line">              notFull.await();</span><br><span class="line">          enqueue(e);<span class="comment">//如果队列没有满直接添加。。</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><h6 id="poll、remove、peek"><a href="#poll、remove、peek" class="headerlink" title="poll、remove、peek"></a>poll、remove、peek</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//删除队列头元素并返回</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//获取要删除的对象</span></span><br><span class="line">      E x = (E) items[takeIndex];</span><br><span class="line">      将数组中takeIndex索引位置设置为<span class="keyword">null</span></span><br><span class="line">      items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//takeIndex索引加1并判断是否与数组长度相等，</span></span><br><span class="line">      <span class="comment">//如果相等说明已到尽头，恢复为0</span></span><br><span class="line">      <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">          takeIndex = <span class="number">0</span>;</span><br><span class="line">      count--;<span class="comment">//队列个数减1</span></span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">          itrs.elementDequeued();<span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">      <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件对象添加线程，执行添加操作</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">poll()，获取并删除队列头元素，队列没有数据就返回null，内部通过dequeue()方法删除头元素，注释很清晰，这里不重复了。接着看remove(Object o)方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//获取数组数据</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果此时队列不为null，这里是为了防止并发情况</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//获取下一个要添加元素时的索引</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="comment">//获取当前要被删除元素的索引</span></span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="comment">//执行循环查找要删除的元素</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//找到要删除的元素</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    removeAt(i);<span class="comment">//执行删除</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//删除成功返回true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前删除索引执行加1后判断是否与数组长度相等</span></span><br><span class="line">                <span class="comment">//若为true，说明索引已到数组尽头，将i设置为0</span></span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>; </span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);<span class="comment">//继承查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引删除元素，实际上是把删除索引之后的元素往前移动一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="comment">//先判断要删除的元素是否为当前队列头元素</span></span><br><span class="line">      <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">          <span class="comment">//如果是直接删除</span></span><br><span class="line">          items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//当前队列头元素加1并判断是否与数组长度相等，若为true设置为0</span></span><br><span class="line">          <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">              takeIndex = <span class="number">0</span>;</span><br><span class="line">          count--;<span class="comment">//队列元素减1</span></span><br><span class="line">          <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">              itrs.elementDequeued();<span class="comment">//更新迭代器中的数据</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果要删除的元素不在队列头部，</span></span><br><span class="line">      <span class="comment">//那么只需循环迭代把删除元素后面的所有元素往前移动一个位置</span></span><br><span class="line">          <span class="comment">//获取下一个要被添加的元素的索引，作为循环判断结束条件</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">          <span class="comment">//执行循环</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex;;) &#123;</span><br><span class="line">              <span class="comment">//获取要删除节点索引的下一个索引</span></span><br><span class="line">              <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">              <span class="comment">//判断是否已为数组长度，如果是从数组头部（索引为0）开始找</span></span><br><span class="line">              <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                  next = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//如果查找的索引不等于要添加元素的索引，说明元素可以再移动</span></span><br><span class="line">              <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                  items[i] = items[next];<span class="comment">//把后一个元素前移覆盖要删除的元</span></span><br><span class="line">                  i = next;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//在removeIndex索引之后的元素都往前移动完毕后清空最后一个元素</span></span><br><span class="line">                  items[i] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                  <span class="keyword">break</span>;<span class="comment">//结束循环</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          count--;<span class="comment">//队列元素减1</span></span><br><span class="line">          <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">              itrs.removedAt(removeIndex);<span class="comment">//更新迭代器数据</span></span><br><span class="line">      &#125;</span><br><span class="line">      notFull.signal();<span class="comment">//唤醒添加线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">remove(Object o)方法的删除过程相对复杂些，因为该方法并不是直接从队列头部删除元素。首先线程先获取锁，再一步判断队列count&gt;0,这点是保证并发情况下删除操作安全执行。接着获取下一个要添加源的索引putIndex以及takeIndex索引 ，作为后续循环的结束判断，因为只要putIndex与takeIndex不相等就说明队列没有结束。然后通过while循环找到要删除的元素索引，执行removeAt(i)方法删除，在removeAt(i)方法中实际上做了两件事，一是首先判断队列头部元素是否为删除元素，如果是直接删除，并唤醒添加线程，二是如果要删除的元素并不是队列头元素，那么执行循环操作，从要删除元素的索引removeIndex之后的元素都往前移动一个位置，那么要删除的元素就被removeIndex之后的元素替换，从而也就完成了删除操作。接着看take()方法，是一个阻塞方法，直接获取队列头元素并删除。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列头部删除，队列没有元素就阻塞，可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lockInterruptibly();<span class="comment">//中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//如果队列没有元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">              <span class="comment">//执行阻塞操作</span></span><br><span class="line">              notEmpty.await();</span><br><span class="line">          <span class="keyword">return</span> dequeue();<span class="comment">//如果队列有元素执行删除操作</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">peek方法非常简单，直接返回当前队列的头元素但不删除任何元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//直接返回当前队列的头元素，但不删除</span></span><br><span class="line">          <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (E) items[i];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>是一个由链表实现的有界队列阻塞队列，但大小默认值为Integer.MAX_VALUE，如果存在添加速度大于删除速度时候，有可能会内存溢出，所以我们在使用LinkedBlockingQueue时建议手动传值，为其提供我们所需的大小，避免队列过大造成机器负载或者内存爆满等情况。(和前者最大的不同是他通过插入和弹出的分离锁方式来提高吞吐量，即添加和删除操作并不是互斥操作，可以同时进行）</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认大小为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建指定大小为capacity的阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">     last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建大小默认值为Integer.MAX_VALUE的阻塞队列并添加c中的元素到阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">     putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">             <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">             <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">             enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">             ++n;</span><br><span class="line">         &#125;</span><br><span class="line">         count.set(n);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         putLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从源码看，有三种方式可以构造LinkedBlockingQueue，通常情况下，我们建议创建指定大小的LinkedBlockingQueue阻塞队列。LinkedBlockingQueue队列也是按 FIFO（先进先出）排序元素。队列的头部是在队列中时间最长的元素，队列的尾部 是在队列中时间最短的元素，新元素插入到队列的尾部，而队列执行获取操作会获得位于队列头部的元素。在正常情况下，链接队列的吞吐量要高于基于数组的队列（ArrayBlockingQueue），因为其内部实现添加和删除操作使用的两个ReenterLock来控制并发执行，而ArrayBlockingQueue内部只是使用一个ReenterLock控制并发，因此LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue。注意LinkedBlockingQueue和ArrayBlockingQueue的API几乎是一样的，但它们的内部实现原理不太相同，这点稍后会分析。使用LinkedBlockingQueue，我们同样也能实现生产者消费者模式。只需把前面ArrayBlockingQueue案例中的阻塞队列对象换成LinkedBlockingQueue即可。这里限于篇幅就不贴重复代码了。接下来我们重点分析LinkedBlockingQueue的内部实现原理，最后我们将对ArrayBlockingQueue和LinkedBlockingQueue 做总结，阐明它们间的不同之处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点类，用于存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * One of:</span></span><br><span class="line"><span class="comment">         * - the real successor Node</span></span><br><span class="line"><span class="comment">         * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">         * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前阻塞队列中的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取并移除元素时使用的锁，如take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加元素时使用的锁如 put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述可看成，每个添加到LinkedBlockingQueue队列中的数据都将被封装成Node节点，添加的链表队列中，其中head和last分别指向队列的头结点和尾结点。与ArrayBlockingQueue不同的是，LinkedBlockingQueue内部分别使用了takeLock 和 putLock 对并发进行控制，也就是说，添加和删除操作并不是互斥操作，可以同时进行，这样也就可以大大提高吞吐量。这里再次强调如果没有给LinkedBlockingQueue指定容量大小，其默认值将是Integer.MAX_VALUE，如果存在添加速度大于删除速度时候，有可能会内存溢出，这点在使用前希望慎重考虑。至于LinkedBlockingQueue的实现原理图与ArrayBlockingQueue是类似的，除了对添加和移除方法使用单独的锁控制外，两者都使用了不同的Condition条件对象作为等待队列，用于挂起take线程和put线程。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><h5 id="add、offer、put-1"><a href="#add、offer、put-1" class="headerlink" title="add、offer、put"></a>add、offer、put</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">add方法间接调用的是offer方法，如果add方法添加失败将抛出IllegalStateException异常，添加成功则返回true</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (offer(e))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//添加元素为null直接抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">//获取队列的个数</span></span><br><span class="line">      <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">      <span class="comment">//判断队列是否已满</span></span><br><span class="line">      <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//构建节点</span></span><br><span class="line">      Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">      putLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//再次判断队列是否已满，考虑并发情况</span></span><br><span class="line">          <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">              enqueue(node);<span class="comment">//添加元素</span></span><br><span class="line">              c = count.getAndIncrement();<span class="comment">//拿到当前未添加新元素时的队列长度</span></span><br><span class="line">              <span class="comment">//如果容量还没满</span></span><br><span class="line">              <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                  notFull.signal();<span class="comment">//唤醒下一个添加线程，执行添加操作</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          putLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 由于存在添加锁和消费锁，而消费锁和添加锁都会持续唤醒等到线程，因此count肯定会变化。</span></span><br><span class="line">      <span class="comment">//这里的if条件表示如果队列中还有1条数据</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) </span><br><span class="line">        signalNotEmpty();<span class="comment">//如果还存在数据那么就唤醒消费锁</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>; <span class="comment">// 添加成功返回true，否则返回false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//队列尾节点指向新的node节点</span></span><br><span class="line">     last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signalNotEmpty方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">      takeLock.lock();</span><br><span class="line">          <span class="comment">//唤醒获取并删除元素的线程</span></span><br><span class="line">          notEmpty.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的Offer()方法做了两件事，第一件事是判断队列是否满，满了就直接释放锁，没满就将节点封装成Node入队，然后再次判断队列添加完成后是否已满，不满就继续唤醒等到在条件对象notFull上的添加线程。第二件事是，判断是否需要唤醒等到在notEmpty条件对象上的消费线程。这里我们可能会有点疑惑，为什么添加完成后是继续唤醒在条件对象notFull上的添加线程而不是像ArrayBlockingQueue那样直接唤醒notEmpty条件对象上的消费线程？而又为什么要当if (c == 0)时才去唤醒消费线程呢？</p><ul><li>唤醒添加线程的原因，在添加新元素完成后，会判断队列是否已满，不满就继续唤醒在条件对象notFull上的添加线程，这点与前面分析的ArrayBlockingQueue很不相同，在ArrayBlockingQueue内部完成添加操作后，会直接唤醒消费线程对元素进行获取，这是因为ArrayBlockingQueue只用了一个ReenterLock同时对添加线程和消费线程进行控制，这样如果在添加完成后再次唤醒添加线程的话，消费线程可能永远无法执行，而对于LinkedBlockingQueue来说就不一样了，其内部对添加线程和消费线程分别使用了各自的ReenterLock锁对并发进行控制，也就是说添加线程和消费线程是不会互斥的，所以添加锁只要管好自己的添加线程即可，添加线程自己直接唤醒自己的其他添加线程，如果没有等待的添加线程，直接结束了。如果有就直到队列元素已满才结束挂起，当然offer方法并不会挂起，而是直接结束，只有put方法才会当队列满时才执行挂起操作。注意消费线程的执行过程也是如此。这也是为什么LinkedBlockingQueue的吞吐量要相对大些的原因。</li><li>为什么要判断if (c == 0)时才去唤醒消费线程呢，这是因为消费线程一旦被唤醒是一直在消费的（前提是有数据），所以c值是一直在变化的，c值是添加完元素前队列的大小，此时c只可能是0或c&gt;0，如果是c=0，那么说明之前消费线程已停止，条件对象上可能存在等待的消费线程，添加完数据后应该是c+1，那么有数据就直接唤醒等待消费线程，如果没有就结束啦，等待下一次的消费操作。如果c&gt;0那么消费线程就不会被唤醒，只能等待下一个消费操作（poll、take、remove）的调用，那为什么不是条件c&gt;0才去唤醒呢？我们要明白的是消费线程一旦被唤醒会和添加线程一样，一直不断唤醒其他消费线程，如果添加前c&gt;0，那么很可能上一次调用的消费线程后，数据并没有被消费完，条件队列上也就不存在等待的消费线程了，所以c&gt;0唤醒消费线程得意义不是很大，当然如果添加线程一直添加元素，那么一直c&gt;0，消费线程执行的换就要等待下一次调用消费操作了（poll、take、remove）。</li></ul><h4 id="移除元素-1"><a href="#移除元素-1" class="headerlink" title="移除元素"></a>移除元素</h4><h5 id="remove、poll、take"><a href="#remove、poll、take" class="headerlink" title="remove、poll、take"></a>remove、poll、take</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">remove方法删除指定的对象，这里我们可能会诧异，为什么同时对putLock和takeLock加锁？这是因为remove方法删除的数据的位置不确定，为了避免造成并非安全问题，所以需要对2个锁同时加锁。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     fullyLock();<span class="comment">//同时对putLock和takeLock加锁</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//循环查找要删除的元素</span></span><br><span class="line">         <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">              p != <span class="keyword">null</span>;</span><br><span class="line">              trail = p, p = p.next) &#123;</span><br><span class="line">             <span class="keyword">if</span> (o.equals(p.item)) &#123;<span class="comment">//找到要删除的节点</span></span><br><span class="line">                 unlink(p, trail);<span class="comment">//直接删除</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         fullyUnlock();<span class="comment">//解锁</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个同时加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       putLock.lock();</span><br><span class="line">       takeLock.lock();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      takeLock.unlock();</span><br><span class="line">      putLock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">poll方法也比较简单，如果队列没有数据就返回null，如果队列有数据，那么就取出来，如果队列还有数据那么唤醒等待在条件对象notEmpty上的消费线程。然后判断if (c == capacity)为true就唤醒添加线程，这点与前面分析if(c==0)是一样的道理。因为只有可能队列满了，notFull条件对象上才可能存在等待的添加线程。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//获取当前队列的大小</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">if</span> (count.get() == <span class="number">0</span>)<span class="comment">//如果没有元素直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        E x = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断队列是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果有，直接删除并获取该元素值</span></span><br><span class="line">                x = dequeue();</span><br><span class="line">                <span class="comment">//当前队列大小减一</span></span><br><span class="line">                c = count.getAndDecrement();</span><br><span class="line">                <span class="comment">//如果队列未空，继续唤醒等待在条件对象notEmpty上的消费线程</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断c是否等于capacity，这是因为如果满说明NotFull条件对象上</span></span><br><span class="line">        <span class="comment">//可能存在等待的添加线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;<span class="comment">//获取头结点</span></span><br><span class="line">        Node&lt;E&gt; first = h.next; 获取头结的下一个节点（要删除的节点）</span><br><span class="line">        h.next = h; <span class="comment">// help GC//自己next指向自己，即被删除</span></span><br><span class="line">        head = first;<span class="comment">//更新头结点</span></span><br><span class="line">        E x = first.item;<span class="comment">//获取删除节点的值</span></span><br><span class="line">        first.item = <span class="keyword">null</span>;<span class="comment">//清空数据，因为first变成头结点是不能带数据的，这样也就删除队列的带数据的第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">take方法是一个可阻塞可中断的移除方法，主要做了两件事，一是，如果队列没有数据就挂起当前线程到 notEmpty条件对象的等待队列中一直等待，如果有数据就删除节点并返回数据项，同时唤醒后续消费线程，二是尝试唤醒条件对象notFull上等待队列中的添加线程。 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取当前队列大小</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();<span class="comment">//可中断</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果队列没有数据，挂机当前线程到条件对象的等待队列中</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果存在数据直接删除并返回该数据</span></span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();<span class="comment">//队列大小减1</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();<span class="comment">//还有数据就唤醒后续的消费线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//满足条件，唤醒条件对象上等待队列中的添加线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="peek、element"><a href="#peek、element" class="headerlink" title="peek、element"></a>peek、element</h6><p>到此关于remove、poll、take的实现也分析完了，其中只有take方法具备阻塞功能。remove方法则是成功返回true失败返回false，poll方法成功返回被移除的值，失败或没数据返回null。下面再看看两个检查方法，即peek和element</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，head 节点不存放数据</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">       last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E x = peek();<span class="comment">//直接调用peek</span></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();<span class="comment">//没数据抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取头结节点的下一个节点</span></span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//为null就返回null</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> first.item;<span class="comment">//返回值</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码来看，head头结节点在初始化时是本身不带数据的，仅仅作为头部head方便我们执行链表的相关操作。peek返回直接获取头结点的下一个节点返回其值，如果没有值就返回null，有值就返回节点对应的值。element方法内部调用的是peek，有数据就返回，没数据就抛异常。下面我们最后来看两个根据时间阻塞的方法，比较有意思，利用的Conditin来实现的。</p><p>offer(E e, long timeout, TimeUnit unit)方法内部正是利用这样的Codition的超时等待awaitNanos方法实现添加方法的超时阻塞操作。同样对于poll(long timeout, TimeUnit unit)方法也是一样的道理。</p><h3 id="LinkedBlockingQueue和ArrayBlockingQueue的异同"><a href="#LinkedBlockingQueue和ArrayBlockingQueue的异同" class="headerlink" title="LinkedBlockingQueue和ArrayBlockingQueue的异同"></a>LinkedBlockingQueue和ArrayBlockingQueue的异同</h3><p>1.队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</p><p>2.数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</p><p>3.由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。</p><p>4.两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://blog.csdn.net/javazejian/article/details/77410889?locationNum=1&amp;fps=1" target="_blank" rel="noopener">深入剖析java并发之阻塞队列LinkedBlockingQueue与ArrayBlockingQueue</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;阻塞队列概要&quot;&gt;&lt;a href=&quot;#阻塞队列概要&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列概
      
    
    </summary>
    
      <category term="多线程" scheme="http://www.fufan.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.fufan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程系列（八）——执行器Executor并发框架</title>
    <link href="http://www.fufan.me/2018/12/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E5%99%A8Executor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.fufan.me/2018/12/04/java多线程系列（八）——执行器Executor并发框架/</id>
    <published>2018-12-04T03:53:00.000Z</published>
    <updated>2018-12-05T03:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>线程池的架构图如下：<br><img src="/image/thread-8-0.jpg" alt=""></p><h3 id="1-Executor"><a href="#1-Executor" class="headerlink" title="1. Executor"></a>1. Executor</h3><p>它是”执行者”接口，它是来执行任务的。准确的说，Executor提供了execute()接口来执行已提交的 Runnable 任务的对象。Executor存在的目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。<br>它只包含一个函数接口：</p><h3 id="2-ExecutorService"><a href="#2-ExecutorService" class="headerlink" title="2. ExecutorService"></a>2. ExecutorService</h3><p>xecutorService继承于Executor。它是”执行者服务”接口，它是为”执行者接口Executor”服务而存在的；准确的话，ExecutorService提供了”将任务提交给执行者的接口(submit方法)”，”让执行者执行任务(invokeAll, invokeAny方法)”的接口等等。</p><h3 id="3-AbstractExecutorService"><a href="#3-AbstractExecutorService" class="headerlink" title="3. AbstractExecutorService"></a>3. AbstractExecutorService</h3><p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。<br>AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。其实基本上抽象方法的作用一般也就是为了提供默认的实现，不过我们在jdk1.8开始，可以使用接口的默认方法，即default关键字。</p><h3 id="4-ThreadPoolExecutor"><a href="#4-ThreadPoolExecutor" class="headerlink" title="4. ThreadPoolExecutor"></a>4. ThreadPoolExecutor</h3><p>ThreadPoolExecutor就是大名鼎鼎的”线程池”。它继承于AbstractExecutorService抽象类。</p><h4 id="构造方法的核心参数"><a href="#构造方法的核心参数" class="headerlink" title="构造方法的核心参数"></a>构造方法的核心参数</h4><ul><li>corePoolSize：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：<ul><li>如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li><li>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；</li><li>如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li><li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；</li></ul></li><li>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</li><li>maximumPoolSize：最大线程数量；</li><li>workQueue：等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</li><li>workQueue：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul><li>直接切换：这种方式常用的队列是SynchronousQueue，但现在还没有研究过该队列，这里暂时还没法介绍；</li><li>使用无界队列：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li><li>使用有界队列：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。<ul><li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li><li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量。</li><li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li></ul></li></ul></li><li>keepAliveTime：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</li><li>threadFactory：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</li><li>handler：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul><li>AbortPolicy：直接抛出异常，这是默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ul></li></ul><h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><p>execute()方法用来提交任务，代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * clt记录着runState和workerCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">     * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">        <span class="comment">// 这时需要移除该command</span></span><br><span class="line">        <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">         * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">     * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">     * 如果失败则拒绝该任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p><p>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；<br>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。<br>这里要注意一下addWorker(null, false);，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在workerCountOf(recheck) == 0时执行addWorker(null, false);也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p><p>execute方法执行流程如下：</p><p><img src="/image/thread-8-1.png" alt=""></p><h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个if判断</span></span><br><span class="line"><span class="comment">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">         * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">         * 2. firsTask为空</span></span><br><span class="line"><span class="comment">         * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">         * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意一下这里的t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p><h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果task为空，则通过getTask来获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里说明一下第一个if判断，目的是：</p><ul><li>如果线程池正在停止，那么要保证当前线程是中断状态；</li><li>如果不是的话，则要保证当前线程不是中断状态；</li></ul><p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p><pre><code>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</code></pre><p>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环不断地通过getTask()方法获取任务；</li><li>getTask()方法从阻塞队列中取任务；</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法；</li><li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li></ol><p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p><p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p><h5 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h5><p>getTask方法用来从阻塞队列中取任务，代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">         * 1. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">         * 2. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">         * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class="line"><span class="comment">             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</li><li>什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</li><li>getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</li></ul><h5 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。 </span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：</p><p><img src="/image/thread-8-2.png" alt=""></p><h5 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h5><p>tryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前线程池的状态为以下几种情况时，直接返回：</span></span><br><span class="line"><span class="comment">         * 1. RUNNING，因为还在运行中，不能停止；</span></span><br><span class="line"><span class="comment">         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；</span></span><br><span class="line"><span class="comment">         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果线程数量不为0，则中断一个空闲的工作线程，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// terminated方法默认什么都不做，留给子类实现</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interruptIdleWorkers(ONLY_ONE);的作用是因为在getTask方法中执行workQueue.take()时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用workQueue.take()时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。</p><h5 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h5><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 安全策略判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 切换状态为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？</p><p>下面仔细分析一下：</p><ul><li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li><li>shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；</li><li>在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用workQueue.take()进行阻塞；</li><li>如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了workQueue.take()后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；</li><li>由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；</li><li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用workQueue.take()时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；</li><li>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</li><li>所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。</li></ul><h5 id="interruptIdleWorkers方法"><a href="#interruptIdleWorkers方法" class="headerlink" title="interruptIdleWorkers方法"></a>interruptIdleWorkers方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nterruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。</p><p>为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。</p><h5 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shutdownNow方法与shutdown方法类似，不同的地方在于：</p><ul><li>设置状态为STOP；</li><li>中断所有工作线程，无论是否是空闲的；</li><li>取出阻塞队列中没有被执行的任务并返回。</li></ul><p>shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</p><h4 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h4><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li>getTaskCount：线程池已经执行的和未执行的任务总数；</li><li>getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li><li>getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li><li>getPoolSize：线程池当前的线程数量；</li><li>getActiveCount：当前线程池中正在执行任务的线程数量。</li></ul><p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p><h3 id="5-ScheduledExecutorService"><a href="#5-ScheduledExecutorService" class="headerlink" title="5. ScheduledExecutorService"></a>5. ScheduledExecutorService</h3><p>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。<br>ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p><h3 id="6-ScheduledThreadPoolExecutor"><a href="#6-ScheduledThreadPoolExecutor" class="headerlink" title="6. ScheduledThreadPoolExecutor"></a>6. ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ScheduledExecutorService。<br>ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p><h3 id="7-Executors"><a href="#7-Executors" class="headerlink" title="7. Executors"></a>7. Executors</h3><p>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p><p>这里要注意，虽然Executors可以用静态方法来创建很多方便的线程池，但是我们在实际工作中发现，因为如果使用像newFixedThreadPool这种方式创建的线程池，会因为队列无限大，导致无法控制而出现内存溢出的问题，所以，我们创建线程池最优雅的方式是通过继承ThreadPoolExecutor，并重写相应的方法来处理。</p><p><strong><em>talk is cheap, let me show the code:</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 任务处理线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">WorkerPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">int</span> maxSize, <span class="keyword">long</span> keepAlive, TimeUnit timeUnit, BlockingQueue&lt;Runnable&gt; queue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(coreSize, maxSize, keepAlive, timeUnit, queue, threadFactory);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable runnable, Throwable throwable)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.afterExecute(runnable, throwable);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是我在项目中用到的手动构建线程池的简单示例，通过这种方式可以调用对应的构造方法，来构建你需要的线程池，包括参数的配置和策略的更换，只要你理解他是如何运行的，就可以轻松驾驭线程池，并发处理业务代码。</p><h2 id="博文参考"><a href="#博文参考" class="headerlink" title="博文参考"></a>博文参考</h2><p><a href="https://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">Java多线程系列目录(共43篇)</a></p><p><a href="https://www.cnblogs.com/liuzhihu/p/8177371.html" target="_blank" rel="noopener">深入理解Java线程池：ThreadPoolExecutor</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;线程池的架构图如下：&lt;br&gt;&lt;img src=&quot;/image/thread-8-0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;h3 
      
    
    </summary>
    
      <category term="多线程" scheme="http://www.fufan.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.fufan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python分布式爬虫利器——Scrapy+Scrapy-redis+Scrapyd+ScrapyWeb</title>
    <link href="http://www.fufan.me/2018/12/03/python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8%E2%80%94%E2%80%94Scrapy-Scrapy-redis-Scrapyd-ScrapyWeb/"/>
    <id>http://www.fufan.me/2018/12/03/python分布式爬虫利器——Scrapy-Scrapy-redis-Scrapyd-ScrapyWeb/</id>
    <published>2018-12-03T09:28:08.000Z</published>
    <updated>2018-12-03T09:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>由于最近公司海外项目需要接一个泰国二手车平台的报价信息的客户需求，公网爬虫的话用python来做是最方便的，因此技术选型用Scrapy+Scrapy-redis+Scrapyd+Gerapy。</p><p>优势如下：</p><pre><code>* 简单、易维护* 分布式爬虫，更快（由于海外代理少且贵）* scrapy文档内容丰富* 等等。。</code></pre><ol><li><p>Scrapy：是一个基于Twisted的异步IO框架，有了这个框架，我们就不需要等待当前URL抓取完毕之后在进行下一个URL的抓取，抓取效率可以提高很多。</p></li><li><p>Scrapy-redis：虽然Scrapy框架是异步加多线程的，但是我们只能在一台主机上运行，爬取效率还是有限的，Scrapy-redis库为我们提供了Scrapy分布式的队列，调度器，去重等等功能，有了它，我们就可以将多台主机组合起来，共同完成一个爬取任务，抓取的效率又提高了。</p></li><li><p>Scrapyd：分布式爬虫完成之后，接下来就是代码部署，如果我们有很多主机，那就要逐个登录服务器进行部署，万一代码有所改动……….可以想象，这个过程是多么繁琐。Scrapyd是专门用来进行分布式部署的工具，它提供HTTP接口来帮助我们部署，启动，停止，删除爬虫程序，利用它我们可以很方便的完成Scrapy爬虫项目的部署。</p></li><li><p>ScrapyWeb：是一个基于Scrapyd，Scrapyd API，Django，nodejs搭建的分布式爬虫管理框架。简单点说，就是用上述的Scrapyd工具是在命令行进行操作，而Gerapy将命令行和图形界面进行了对接，我们只需要点击按钮就可完成部署，启动，停止，删除的操作。并且支持节点管理、爬虫监控，邮件发送等功能。</p></li></ol><h3 id="1-创建Scrapy项目"><a href="#1-创建Scrapy项目" class="headerlink" title="1. 创建Scrapy项目"></a>1. 创建Scrapy项目</h3><h3 id="2-添加Scrapy-redis配置"><a href="#2-添加Scrapy-redis配置" class="headerlink" title="2. 添加Scrapy-redis配置"></a>2. 添加Scrapy-redis配置</h3><h3 id="3-安装Scrapyd"><a href="#3-安装Scrapyd" class="headerlink" title="3. 安装Scrapyd"></a>3. 安装Scrapyd</h3><h3 id="4-强大的界面分布式管理scrapy进程——ScrapyWeb"><a href="#4-强大的界面分布式管理scrapy进程——ScrapyWeb" class="headerlink" title="4. 强大的界面分布式管理scrapy进程——ScrapyWeb"></a>4. 强大的界面分布式管理scrapy进程——ScrapyWeb</h3><h2 id="待续……"><a href="#待续……" class="headerlink" title="待续……"></a>待续……</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;由于最近公司海外项目需要接一个泰国二手车平台的报价信息的客户需求，公网爬虫的话用python来做是最方便的，因此技术选型用S
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学会写脚本系列（二）—— Python之dict(或对象)与json之间的互相转化</title>
    <link href="http://www.fufan.me/2018/11/22/%E5%AD%A6%E4%BC%9A%E5%86%99%E8%84%9A%E6%9C%AC%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-Python%E4%B9%8Bdict-%E6%88%96%E5%AF%B9%E8%B1%A1-%E4%B8%8Ejson%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96/"/>
    <id>http://www.fufan.me/2018/11/22/学会写脚本系列（二）——-Python之dict-或对象-与json之间的互相转化/</id>
    <published>2018-11-22T09:52:00.000Z</published>
    <updated>2018-11-22T09:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --><p>在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。</p><p>在Python中自带json库。通过import json导入。</p><p>在json模块有2个方法，</p><ul><li>loads()：将json数据转化成dict数据</li><li>dumps()：将dict数据转化成json数据</li><li>load()：读取json文件数据，转成dict数据</li><li>dump()：将dict数据转化成json数据后写入json文件</li></ul><p>示例如下：</p><h3 id="1-dict字典转json数据"><a href="#1-dict字典转json数据" class="headerlink" title="1. dict字典转json数据"></a>1. dict字典转json数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dict_to_json():</span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    dict[&apos;name&apos;] = &apos;fufan&apos;</span><br><span class="line">    dict[&apos;age&apos;] = 25</span><br><span class="line">    dict[&apos;sex&apos;] = &apos;male&apos;</span><br><span class="line">    print(dict)  # 输出：&#123;&apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 25, &apos;sex&apos;: &apos;male&apos;&#125;</span><br><span class="line">    j = json.dumps(dict)</span><br><span class="line">    print(j)  # 输出：&#123;&quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 25, &quot;sex&quot;: &quot;male&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    dict_to_json()</span><br></pre></td></tr></table></figure><h3 id="2-对象转json数据"><a href="#2-对象转json数据" class="headerlink" title="2. 对象转json数据"></a>2. 对象转json数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    id = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    gender = &apos;&apos;</span><br><span class="line">    phone = &apos;&apos;</span><br><span class="line">    email = &apos;&apos;</span><br><span class="line">    def __init__(self, id, name, age, gender, phone, email):</span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.phone = phone</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def obj_to_json():</span><br><span class="line">    stu = Student(&apos;fufan&apos;, &apos;fufan&apos;, 28, &apos;male&apos;, &apos;13000000000&apos;, &apos;fufan@51dojo.com&apos;)</span><br><span class="line">    print(type(stu))  # &lt;class &apos;json_test.student.Student&apos;&gt;</span><br><span class="line">    stu = stu.__dict__  # 将对象转成dict字典</span><br><span class="line">    print(type(stu))  # &lt;class &apos;dict&apos;&gt;</span><br><span class="line">    print(stu)  # &#123;&apos;id&apos;: &apos;fufan&apos;, &apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 28, &apos;gender&apos;: &apos;male&apos;, &apos;phone&apos;: &apos;13000000000&apos;, &apos;email&apos;: &apos;fufan@51dojo.com&apos;&#125;</span><br><span class="line">    j = json.dumps(obj=stu)</span><br><span class="line">    print(j)  # &#123;&quot;id&quot;: &quot;fufan&quot;, &quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 28, &quot;gender&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;fufan@51dojo.com&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    obj_to_json()</span><br></pre></td></tr></table></figure><h3 id="3-json数据转成dict字典"><a href="#3-json数据转成dict字典" class="headerlink" title="3. json数据转成dict字典"></a>3. json数据转成dict字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">def json_to_dict():</span><br><span class="line">    j = &apos;&#123;&quot;id&quot;: &quot;fufan&quot;, &quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 28, &quot;gender&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;fufan@51dojo.com&quot;&#125;&apos;</span><br><span class="line">    dict = json.loads(s=j)</span><br><span class="line">    print(dict)  # &#123;&apos;id&apos;: &apos;fufan&apos;, &apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 28, &apos;gender&apos;: &apos;male&apos;, &apos;phone&apos;: &apos;13000000000&apos;, &apos;email&apos;: &apos;fufan@51dojo.com&apos;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    json_to_dict()</span><br></pre></td></tr></table></figure><h3 id="4-json数据转成对象"><a href="#4-json数据转成对象" class="headerlink" title="4. json数据转成对象"></a>4. json数据转成对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    id = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    gender = &apos;&apos;</span><br><span class="line">    phone = &apos;&apos;</span><br><span class="line">    email = &apos;&apos;</span><br><span class="line"></span><br><span class="line">def json_to_obj():</span><br><span class="line">    j = &apos;&#123;&quot;id&quot;: &quot;fufan&quot;, &quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 28, &quot;gender&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;fufan@51dojo.com&quot;&#125;&apos;</span><br><span class="line">    dict = json.loads(s=j)</span><br><span class="line">    stu = Student()</span><br><span class="line">    stu.__dict__ = dict</span><br><span class="line">    print(&apos;id: &apos; + stu.id + &apos; name: &apos; + stu.name + &apos; age: &apos; + str(stu.age) + &apos; gender: &apos; + str(</span><br><span class="line">        stu.gender) + &apos; phone: &apos; + stu.phone + &apos; email: &apos; + stu.email)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    json_to_obj()</span><br></pre></td></tr></table></figure><h3 id="5-dump-方法的使用"><a href="#5-dump-方法的使用" class="headerlink" title="5. dump()方法的使用"></a>5. dump()方法的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">def dict_to_json_write_file():</span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    dict[&apos;name&apos;] = &apos;fufan&apos;</span><br><span class="line">    dict[&apos;age&apos;] = 26</span><br><span class="line">    dict[&apos;gender&apos;] = &apos;male&apos;</span><br><span class="line">    print(dict)  # &#123;&apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 26, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line">    with open(&apos;test.json&apos;, &apos;w&apos;) as f:</span><br><span class="line">        json.dump(dict, f)  # 会在目录下生成一个test.json的文件，文件内容是dict数据转成的json数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    dict_to_json_write_file()</span><br></pre></td></tr></table></figure><h3 id="6-load-的使用"><a href="#6-load-的使用" class="headerlink" title="6. load()的使用"></a>6. load()的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">def json_file_to_dict():</span><br><span class="line">    with open(&apos;test.json&apos;, &apos;r&apos;) as f:</span><br><span class="line">        dict = json.load(fp=f)</span><br><span class="line">        print(dict)  # &#123;&apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 26, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    json_file_to_dict()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jan 30 2023 15:59:40 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。&lt;/p&gt;&lt;p&gt;在Python中自带js
      
    
    </summary>
    
    
  </entry>
  
</feed>
