<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Gemini Boy</title>
  
  <subtitle>welcome to my site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fufan.me/"/>
  <updated>2018-10-02T12:58:29.733Z</updated>
  <id>http://www.fufan.me/</id>
  
  <author>
    <name>fae88</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的vim命令整理（持续更新）</title>
    <link href="http://www.fufan.me/2018/10/02/%E5%B8%B8%E7%94%A8%E7%9A%84vim%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://www.fufan.me/2018/10/02/常用的vim命令整理（持续更新）/</id>
    <published>2018-10-02T12:58:26.000Z</published>
    <updated>2018-10-02T12:58:29.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --><h2 id="1-插入模式-command-mode"><a href="#1-插入模式-command-mode" class="headerlink" title="1. 插入模式 (command mode)"></a>1. 插入模式 (command mode)</h2><p>命令模式切换至插入状态</p><ul><li>i光标前插入</li><li>I行首插入</li><li>a光标后插入</li><li>A行尾插入</li><li>o行上新行</li><li>O行下新行</li></ul><h2 id="2-命令模式-insert-mode"><a href="#2-命令模式-insert-mode" class="headerlink" title="2. 命令模式 (insert mode)"></a>2. 命令模式 (insert mode)</h2><p>ESC从插入状态切换至命令模式</p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li>h左移</li><li>j下移</li><li>k上移</li><li>l右移</li><li>H到屏幕顶部</li><li>M到屏幕中央</li><li>L到屏幕底部</li><li>0到行首</li><li>$到行尾</li><li>Ctrl+f向前翻屏</li><li>Ctrl+b向后翻屏</li><li>Ctrl+d向前翻半屏</li><li>Ctrl+u向后翻半屏</li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul><li>gg回到文件首行,</li><li>G回到文件尾行</li><li>:n和nG光标定位到文件第n行(:20或20G表示光标定位到第20行)</li><li>:set nu 或:set number显示行号,</li><li>:set nonu 取消显示行号</li><li>ctrl+g</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>x删除光标所在字符(与Delete键相同的方向),</li><li>X删除光标所在字符(与Backspace键相同的方向)</li><li>nx删除光标后n个字符</li><li>dd删除光标所在行</li><li>ndd删除光标所在行以后的n行</li><li>D删除光标到行尾的内容</li><li>dG删除光标所在行到文件末尾的内容</li><li>n1,n2d删除行n1到行n2的内容，包括第n1和n2行都被删除</li><li>s删除一个字符来插入模式</li><li>S删除当前行以插入模式</li></ul><h3 id="复制、剪切、粘贴、替换"><a href="#复制、剪切、粘贴、替换" class="headerlink" title="复制、剪切、粘贴、替换"></a>复制、剪切、粘贴、替换</h3><ul><li>yy或Y复制当前行</li><li>nyy或nY从当前行开始赋值n行</li><li>ggVG全选</li><li>剪切使用dd和ndd，相当于删除</li><li>p在光标所在行之后粘贴</li><li>P在光标所在行之前粘贴</li><li>r替换当前字符后回到命令模式</li><li>R一直替换知道通过ESC回到命令模式</li></ul><h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ul><li>\KeyWord回车，n查找下一处</li><li>?KeyWord回车，n查找上一处</li><li>n重复相同方向</li><li>N重复反向方向·</li><li>:s/old/new/g替换整个文件，不确认</li><li>:s/old/new/gc替换整个文件，确认</li><li>:n1,n2s/old/new/g替换n1-n2行中匹配内容，不确认</li></ul><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>u</p><h3 id="保存及离开"><a href="#保存及离开" class="headerlink" title="保存及离开"></a>保存及离开</h3><ul><li>:w保存文件</li><li>:w!强制保存</li><li>:w file将修改另外保存到file</li><li>:wq保存文件并退出</li><li>:wq!强制保存文件并退出</li><li>:q不保存退出</li><li>:q!不保存强制退出</li><li>:e!放弃所有修改，从上次保存文件开始再编辑</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;1-插入模式-command-mode&quot;&gt;&lt;a href=&quot;#1-插入模式-command-mode&quot; class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ssh免密码登录步骤及别名设置</title>
    <link href="http://www.fufan.me/2018/10/02/ssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%88%AB%E5%90%8D%E8%AE%BE%E7%BD%AE/"/>
    <id>http://www.fufan.me/2018/10/02/ssh免密码登录步骤及别名设置/</id>
    <published>2018-10-02T05:23:00.000Z</published>
    <updated>2018-10-02T05:45:00.655Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --><h2 id="ssh免密码登录步骤及别名设置"><a href="#ssh免密码登录步骤及别名设置" class="headerlink" title="ssh免密码登录步骤及别名设置"></a>ssh免密码登录步骤及别名设置</h2><h5 id="1-生成本机的公私钥"><a href="#1-生成本机的公私钥" class="headerlink" title="1. 生成本机的公私钥"></a>1. 生成本机的公私钥</h5><p><code>ssh-keygen -t rsa</code></p><h5 id="2-将公钥复制到目标机器上"><a href="#2-将公钥复制到目标机器上" class="headerlink" title="2. 将公钥复制到目标机器上"></a>2. 将公钥复制到目标机器上</h5><p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.100</code></p><h5 id="3-设置别名登录"><a href="#3-设置别名登录" class="headerlink" title="3. 设置别名登录"></a>3. 设置别名登录</h5><p><code>vim ~/.ssh/config</code></p><p>添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host 100</span><br><span class="line">HostName 192.168.0.100</span><br><span class="line">Port 22</span><br><span class="line">User root</span><br><span class="line">IdentityFile ~/.ssh/id_rsa.pub</span><br><span class="line">IdentitiesOnly yes</span><br></pre></td></tr></table></figure><h5 id="4-登录"><a href="#4-登录" class="headerlink" title="4. 登录"></a>4. 登录</h5><p><code>ssh 100</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;ssh免密码登录步骤及别名设置&quot;&gt;&lt;a href=&quot;#ssh免密码登录步骤及别名设置&quot; class=&quot;header
      
    
    </summary>
    
      <category term="linux" scheme="http://www.fufan.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.fufan.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java面试总结积累（基础篇）之集合问题</title>
    <link href="http://www.fufan.me/2017/01/13/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E7%A7%AF%E7%B4%AF%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%E4%B9%8B%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>http://www.fufan.me/2017/01/13/Java面试总结积累（基础篇）之集合问题/</id>
    <published>2017-01-12T16:35:00.000Z</published>
    <updated>2018-10-02T16:38:58.285Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 03 2018 00:39:11 GMT+0800 (China Standard Time) --><p>这里通过收集网上一些比较好的博客对集合的总结做一下记录和积累。</p><h4 id="List-Set-Map三者的区别及总结"><a href="#List-Set-Map三者的区别及总结" class="headerlink" title="List, Set, Map三者的区别及总结"></a>List, Set, Map三者的区别及总结</h4><ol><li><p>List：对付顺序的好帮手<br>List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p></li><li><p>Set:注重独一无二的性质<br>不允许重复的集合。不会有多个元素引用相同的对象。</p></li><li><p>Map:用Key来搜索的专家<br>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p></li></ol><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h4><p>Arraylist底层使用的是数组（存读数据效率高，插入删除特定位置效率低），LinkedList底层使用的是双向循环链表数据结构（插入，删除效率特别高）。学过数据结构这门课后我们就知道采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n），因此当数据特别多，而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了，因为一般数据量都不会蛮大，Arraylist是使用最多的集合类。</p><h4 id="ArrayList-与-Vector-区别（为什么要用Arraylist取代Vector呢？）"><a href="#ArrayList-与-Vector-区别（为什么要用Arraylist取代Vector呢？）" class="headerlink" title="ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）"></a>ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）</h4><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector ，代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要同步时建议使用Arraylist。</p><h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><ol><li>HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。</li></ol><ol start="2"><li>因为线程安全的问题，HashMap要比HashTable效率高一点，HashTable基本被淘汰。</li></ol><ol start="3"><li>HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。</li></ol><ol start="4"><li>TIPS: Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java5或以上的话，请使用ConcurrentHashMap吧</li></ol><h4 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h4><p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）<br>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p><h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h4><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p><h4 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a>==与equals的区别</h4><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同</li></ol><h4 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h4><ul><li><p>comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h4 id="如何对Object的list排序？"><a href="#如何对Object的list排序？" class="headerlink" title="如何对Object的list排序？"></a>如何对Object的list排序？</h4><ul><li>对objects数组进行排序，我们可以用Arrays.sort()方法</li><li>对objects的集合进行排序，需要使用Collections.sort()方法</li></ul><h4 id="如何实现数组与List的相互转换？"><a href="#如何实现数组与List的相互转换？" class="headerlink" title="如何实现数组与List的相互转换？"></a>如何实现数组与List的相互转换？</h4><ul><li>List转数组:toArray(arraylist.size()方法</li><li>数组转List:Arrays的asList(a)方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span><br><span class="line">arrayList.add(&quot;s&quot;);</span><br><span class="line">arrayList.add(&quot;e&quot;);</span><br><span class="line">arrayList.add(&quot;n&quot;);</span><br><span class="line">/**</span><br><span class="line"> * ArrayList转数组</span><br><span class="line"> */</span><br><span class="line">int size=arrayList.size();</span><br><span class="line">String[] a = arrayList.toArray(new String[size]);</span><br><span class="line">//输出第二个元素</span><br><span class="line">System.out.println(a[1]);//结果：e</span><br><span class="line">//输出整个数组</span><br><span class="line">System.out.println(Arrays.toString(a));//结果：[s, e, n]</span><br><span class="line">/**</span><br><span class="line"> * 数组转list</span><br><span class="line"> */</span><br><span class="line">List&lt;String&gt; list=Arrays.asList(a);</span><br><span class="line">/**</span><br><span class="line"> * list转Arraylist</span><br><span class="line"> */</span><br><span class="line">List&lt;String&gt; arrayList2 = new ArrayList&lt;String&gt;();</span><br><span class="line">arrayList2.addAll(list);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="如何求ArrayList集合的交集-并集-差集-去重复并集"><a href="#如何求ArrayList集合的交集-并集-差集-去重复并集" class="headerlink" title="如何求ArrayList集合的交集 并集 差集 去重复并集"></a>如何求ArrayList集合的交集 并集 差集 去重复并集</h4><p>需要用到List接口中定义的几个方法：</p><ul><li>addAll(Collection&lt;? extends E&gt; c) :按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾</li><li>retainAll(Collection&lt;?&gt; c): 仅保留此列表中包含在指定集合中的元素。</li><li>removeAll(Collection&lt;?&gt; c) :从此列表中删除指定集合中包含的所有元素。</li></ul><p><strong>TIPS: JAVA8中提供了通过lambda方式处理集合，如Collections类中好多工具方法用stream流方式处理，方便了我们在处理集合时的各种情况，JAVA8集合这块再后面的blog中会单独拿出来总结。</strong></p><h4 id="HashMap-的工作原理及代码实现"><a href="#HashMap-的工作原理及代码实现" class="headerlink" title="HashMap 的工作原理及代码实现"></a>HashMap 的工作原理及代码实现</h4><p><a href="https://juejin.im/post/5ab0568b5188255580020e56" target="_blank" rel="noopener">集合框架源码学习之HashMap(JDK1.8)</a></p><h4 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h4><p><a href="http://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></p><h4 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>Arraylist：数组（查询快,增删慢 线程不安全,效率高 ）<br>Vector：数组（查询快,增删慢 线程安全,效率低 ）<br>LinkedList：链表（查询慢,增删快 线程不安全,效率高 ）</p><h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><p>HashSet（无序，唯一）:哈希表或者叫散列集(hash table)<br>LinkedHashSet：链表和哈希表组成 。 由链表保证元素的排序 ， 由哈希表证元素的唯一性<br>TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树。)</p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>HashMap：基于哈希表的Map接口实现（哈希表对键进行散列，Map结构即映射表存放键值对）<br>LinkedHashMap:HashMap 的基础上加上了链表数据结构<br>HashTable:哈希表<br>TreeMap:红黑树（自平衡的排序二叉树）</p><h4 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h4><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 03 2018 00:39:11 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;这里通过收集网上一些比较好的博客对集合的总结做一下记录和积累。&lt;/p&gt;&lt;h4 id=&quot;List-Set-Map三者的区别及总
      
    
    </summary>
    
      <category term="面试" scheme="http://www.fufan.me/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="java base" scheme="http://www.fufan.me/tags/java-base/"/>
    
      <category term="面试" scheme="http://www.fufan.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="collection" scheme="http://www.fufan.me/tags/collection/"/>
    
  </entry>
  
  <entry>
    <title>Java面试总结积累（基础篇）之语法问题</title>
    <link href="http://www.fufan.me/2017/01/03/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E7%A7%AF%E7%B4%AF%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%E4%B9%8B%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/"/>
    <id>http://www.fufan.me/2017/01/03/Java面试总结积累（基础篇）之语法问题/</id>
    <published>2017-01-02T16:34:00.000Z</published>
    <updated>2018-10-02T16:38:22.275Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 03 2018 00:39:11 GMT+0800 (China Standard Time) --><pre><code>java开发经验固然很重要，但是有很多面试当中会遇到一些基础问题，需要自己来进行总结归类，也算是扫盲和回归吧。</code></pre><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><ul><li>面向过程：<br>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</li></ul><ul><li><p>面向对象：</p><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护<br>缺点：性能比面向过程低</p></li></ul><h4 id="Java语言有哪些特点？"><a href="#Java语言有哪些特点？" class="headerlink" title="Java语言有哪些特点？"></a>Java语言有哪些特点？</h4><p>1，简单易学；<br>2，面向对象（封装，继承，多态）；<br>3，平台无关性（Java虚拟机实现平台无关性）；<br>4，可靠性；<br>5，安全性；<br>6，支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；<br>7，支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；<br>8，编译与解释并存；</p><h4 id="什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？"><a href="#什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？"></a>什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？</h4><ul><li><p>先看下java中的编译器和解释器：<br>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。<br>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p></li><li><p>采用字节码的好处：<br>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p></li></ul><h4 id="什么是Java虚拟机"><a href="#什么是Java虚拟机" class="headerlink" title="什么是Java虚拟机"></a>什么是Java虚拟机</h4><p>任何一种可以运行Java字节码的软件均可看成是Java的虚拟机（JVM）</p><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol><li><p>形式上:<br>字符常量是单引号引起的一个字符<br>字符串常量是双引号引起的若干个字符</p></li><li><p>含义上:<br>字符常量相当于一个整形值(ASCII值),可以参加表达式运算<br>字符串常量代表一个地址值(该字符串在内存中存放位置)</p></li><li><p>占内存大小<br>字符常量只占一个字节<br>字符串常量占若干个字节(至少一个字符结束标志)</p></li></ol><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h4 id="构造器Constructor是否可被override"><a href="#构造器Constructor是否可被override" class="headerlink" title="构造器Constructor是否可被override"></a>构造器Constructor是否可被override</h4><p>在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override,但是可以overload,所以你可以看到一个类中有多个构造函数的情况。</p><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><ul><li><p>重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p></li><li><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。</p></li></ul><h4 id="java-面向对象编程三大特性"><a href="#java-面向对象编程三大特性" class="headerlink" title="java 面向对象编程三大特性"></a>java 面向对象编程三大特性</h4><p>封装、继承、多态</p><h4 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><ul><li><p>可变性<br>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。</p></li><li><p>线程安全性<br>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p></li><li><p>性能<br>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。<br>对于三者使用的总结：<br>如果要操作少量的数据用 = String<br>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p></li></ul><h4 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h4 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h4><ol><li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是final类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象<br>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ol><h4 id="成员变量与局部变量的区别有那些？"><a href="#成员变量与局部变量的区别有那些？" class="headerlink" title="成员变量与局部变量的区别有那些？"></a>成员变量与局部变量的区别有那些？</h4><ol><li><p>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；</p></li><li><p>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</p></li><li><p>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li><p>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</p></li></ol><h4 id="创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>创建一个对象用什么运算符？对象实体与对象引用有何不同？</h4><p>new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h4 id="什么是方法的返回值？返回值在类的方法里的作用是什么"><a href="#什么是方法的返回值？返回值在类的方法里的作用是什么" class="headerlink" title="什么是方法的返回值？返回值在类的方法里的作用是什么"></a>什么是方法的返回值？返回值在类的方法里的作用是什么</h4><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><ol><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ol><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p>静态方法和实例方法的区别主要体现在两个方面：</p><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li></ol><ol start="2"><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ol><h4 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h4><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>帮助子类做初始化工作。</p><p>equals 和 == 的区别？</p><ul><li><p>通俗点讲：==是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，==：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。</p></li><li><p>术语来讲的区别：</p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同</li></ol></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 03 2018 00:39:11 GMT+0800 (China Standard Time) --&gt;&lt;pre&gt;&lt;code&gt;java开发经验固然很重要，但是有很多面试当中会遇到一些基础问题，需要自己来进行总结归类，也算是扫盲和回归吧
      
    
    </summary>
    
      <category term="面试相关" scheme="http://www.fufan.me/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="java base" scheme="http://www.fufan.me/tags/java-base/"/>
    
      <category term="面试" scheme="http://www.fufan.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>（绪）设计模式之架构中的设计原则</title>
    <link href="http://www.fufan.me/2016/10/11/%EF%BC%88%E7%BB%AA%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://www.fufan.me/2016/10/11/（绪）设计模式之架构中的设计原则/</id>
    <published>2016-10-11T10:51:00.000Z</published>
    <updated>2018-10-02T13:04:49.525Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --><p>在进行软件架构工作时，需要遵循面向对象原则，这些原则同样在各类设计模式、架构模式之中，在学习过程中可以通过类图、时序图、示例代码等形式，不断体会这些原则在解决“依赖”和变化中的效果。当然，这些“原则”的队伍也在变化。不断有新的“原则加入，也有被淘汰掉的，真正沉淀下来的通用的”原则“其实并不多</p><p>在使用面向对象的思想进行系统设计时，前任总结出了7条原则，分别是单一职责原则、开闭原则、里氏替换原则、依赖注入原则、接口分离原则、迪米特原则和有限使用组合而不是继承原则。下面来介绍下这几种原则的含义，也为后面学习设计模式打下基础。</p><h4 id="原则一：单一职责原则"><a href="#原则一：单一职责原则" class="headerlink" title="原则一：单一职责原则"></a>原则一：单一职责原则</h4><p>但以职责原则的核心思想就是：系统中的每一个对象都应该只有一个单独的职责，而所有对象所关注的就是自身职责的完成，全称即Single Responsibility Principle。</p><p>其实单一职责的意思就是开发人员经常说的”<strong>高内聚、低耦合</strong>“。也就是说，每一个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都要遵守这个原则。</p><p>”单一职责“也就是”单一变化原因“。通常一个类的职责越多，导致的变化因素也与阿朵，我们在设计的时候可能会把该类的有关的操作都组合在这个类中，这样做的后果就有可能将多个职责“<strong>耦合</strong>”到一起。解决这个问题的方法就是“分耦”，将不同的职责分别进行封装，不要将组合在一个类中。例如将用户的属性和用户的行为放在一个接口中声明，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface User&#123;</span><br><span class="line">//身高</span><br><span class="line">public double getHeight();</span><br><span class="line">//体重</span><br><span class="line">public double getWeight();</span><br><span class="line">//吃饭</span><br><span class="line">public void eat();</span><br><span class="line">//玩游戏</span><br><span class="line">public void gaming();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子就存在这个问题，身高和体重属于业务对象，与之对应的方法主要负责用户的属性，而吃饭和玩游戏是相应的业务逻辑，主要负责用户的行为，这会给人一种不知道这个接口到底是做什么的感觉，职责不清晰，后期维护的时候会造成各种各样的问题。可以将这个接口分为两个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UserPro&#123;</span><br><span class="line">//身高</span><br><span class="line">public double getHeight();</span><br><span class="line">//体重</span><br><span class="line">public double getWeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UserAct&#123;</span><br><span class="line">//吃饭</span><br><span class="line">public void eat();</span><br><span class="line">//玩游戏</span><br><span class="line">public void gaming();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后分别实现这两个接口，这里的实现我就不详细写了，主要通过这种方式可以做到当需要修改用户属性的时候，只需要对UserPro这个接口进行修改，而不会影响到其他类。</p><p>另外，SRP原则的好处是可以消除耦合，减小因需求变化引起代码僵化的难堪局面。需要注意：</p><ul><li>一个合理的类，应该仅有一个引起他变化的原因，即单一职责。</li><li>在没有变化征兆的情况下，应用SRP或其他原则是不明智的。</li><li>在需求实际发生变化时就应该应用SRP等原则来重构代码。</li><li>使用测试驱动开发会迫使我们在设计出现劣质趋势之前分离不合理代码</li><li>如果测试不能迫使职责分离，僵化性和脆弱性的腐朽味会变得很浓烈，那就应该用Facade或者Proxy模式对代码重构</li></ul><h4 id="原则二：里氏替换原则（LSP）"><a href="#原则二：里氏替换原则（LSP）" class="headerlink" title="原则二：里氏替换原则（LSP）"></a>原则二：里氏替换原则（LSP）</h4><p>里氏替换原则的核心思想就是：在任何父类出现的地方都可以用他的自雷来替代。它的英文缩写为LSP，全称是Liskov Subsitituition Principle。</p><p>通俗点讲，就是同一个继承体系中的对象应该有果农共同的行为特征。里氏替换原则关注的是怎样良好地使用继承，也就是说不要滥用继承，它是继承复用的基石。在里氏替换原则中，所有引用基类的地方必须能够透明地使用其子类对象，也就是说，只要父类出现的地方，子类就能出现，而且替换为子类不会产生任何错误或者异常。但是反过来，子类出现的地方，替换为父类就可能出现问题了。</p><p>主要抓住以下四层含义（子类的范围大于等于父类的范围）：</p><ol><li>子类必须完全实现父类的方法</li><li>子类可以有自己的特性</li><li>覆盖或者实现父类的方法时输入参数可以被放大</li><li>覆写或者实现父类的方法时输出结果可以被缩小</li></ol><h4 id="原则三：依赖注入原则（DIP）"><a href="#原则三：依赖注入原则（DIP）" class="headerlink" title="原则三：依赖注入原则（DIP）"></a>原则三：依赖注入原则（DIP）</h4><p>依赖注入原则的核心思想就是：要依赖于抽象，不要依赖于具体的实现。英文全称就是Dependence Inversion Principle。</p><p>通俗的讲：在应用程序中，所有的类如果使用或者依赖于其他的类，则都应该依赖于这些其他类的抽象类，而不是这些其他类的具体实现。即要求开发人员在编程时针对接口编程，而不是针对实现编程。</p><p>依赖注入原则有三点要注意的：</p><ol><li>高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）。</li><li>抽象（抽象类或接口）不应该依赖于细节（具体实现类）。</li><li>细节（具体实现类）应该依赖抽象</li></ol><p>这里的抽象指的是不能被实例化的抽象类或接口，具体的实现则是可以通过new直接实例化的。这个原则是开闭原则的基础（对扩展开放，对修改关闭）。</p><p>三种实现方式：</p><ol><li>通过构造函数传递依赖对象</li><li>通过setter方法传递依赖对象</li><li>接口声明实现依赖对象</li></ol><h4 id="原则四：接口分离原则（ISP）"><a href="#原则四：接口分离原则（ISP）" class="headerlink" title="原则四：接口分离原则（ISP）"></a>原则四：接口分离原则（ISP）</h4><p>接口分离原则的核心思想就是：不应该强迫客户程序依赖它们不需要使用的方法。它的全称是Interface Segregation Principle。其实接口分离原则的意思就是一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该吧所有的操作都封装到一个接口中。<br>这里的接口不仅是interface关键字的实例，接口分为以下两种：</p><ol><li>对象接口（object Interface）<br>java中声明一个类，通过new出一个实例，它是对一个类型的事务的描述，这也是一种接口。例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Phone phone = new Phone(); //这里的类Phone就是实例Phone的一个接口</span><br></pre></td></tr></table></figure><ol start="2"><li>类接口（Class Interface）<br>这种接口就是通过关键字Interface定义的接口。</li></ol><p>接口分离原则要求的是在一个模块中应该只依赖它需要的接口，以保证接口的纯洁。切勿定义太臃肿的接口。<br>接口分离原则与但以职责原则有点类似，都是说如何设计接口，不过不同在于单一职责原则要求的是类和接口职责单一，注重的是职责，是业务逻辑上的划分。而接口分离原则要求的是接口的方法尽量少，针对一个模块尽量有用。</p><p>如何做到该原则：</p><ol><li>接口尽量小：小的概念是保证一个接口之服务于一个子模块或者业务逻辑</li><li>接口高内聚：指的是对内高度依赖，对外尽可能隔离。即一个接口内部声明的方法相互之间都与某一个子模块相关，且这个子模块必需的。</li><li>接口设计是有限度的：话说回来，如果过度地遵循该原则，会使得接口数量剧增，复杂度正价，这并不是我们想要的结果。</li></ol><h4 id="原则五：迪米特原则（LOD）"><a href="#原则五：迪米特原则（LOD）" class="headerlink" title="原则五：迪米特原则（LOD）"></a>原则五：迪米特原则（LOD）</h4><p>全称是Law of Demeter。核心思想就是：一个对象应当对其他对象尽可能少地了解。意思就是降低各个对象之间的耦合，提高系统的可维护性。在模块之间，应该只通过接口来通信，而不理会模块的内部工作原理，它可以使各个模块偶和程度降到最低，促进软件的复用。</p><p>它的核心观念还是类间解耦，弱耦合。举个例子，监狱的犯人是不能随便和外面的人打交道，除非探亲，所以狱警就是这个迪米特法则的执行者，监狱就是类，犯人就是类的内部信息。</p><p>总结下这个原则要注意的地方：</p><ul><li>在类的划分上，因可更改创建有弱耦合的类。</li><li>在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</li><li>在类的设计上，只要有可能，一个类应当设计成不变类</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</li><li>尽量降低类的访问权限</li><li>谨慎使用序列化功能</li><li>不要暴露类成员，而应该提供相应的访问方法（属性getter）</li></ul><h4 id="原则六：开闭原则（OCP）"><a href="#原则六：开闭原则（OCP）" class="headerlink" title="原则六：开闭原则（OCP）"></a>原则六：开闭原则（OCP）</h4><p>开闭原则的核心思想：一个对象对扩展开放，对修改关闭。<br>其实开闭原则就是：对类的改动是通过增加代码进行的，而不是改动现有的代码。也就是说，软件开发人员一旦写出了可以运行的代码，就不应该去改变它，而是要保证他一直能运行下去，这就需要借助java的抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现层则是可以改变和扩展的。</p><p>注意：这些设计原则并不是绝对的，而是应根据项目的实际需求来定夺。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在进行软件架构工作时，需要遵循面向对象原则，这些原则同样在各类设计模式、架构模式之中，在学习过程中可以通过类图、时序图、示例
      
    
    </summary>
    
      <category term="framework" scheme="http://www.fufan.me/categories/framework/"/>
    
    
      <category term="design pattern" scheme="http://www.fufan.me/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基本数据结构</title>
    <link href="http://www.fufan.me/2016/09/12/JAVA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.fufan.me/2016/09/12/JAVA基本数据结构/</id>
    <published>2016-09-12T15:18:00.000Z</published>
    <updated>2018-10-02T13:11:46.149Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --><h2 id="java基本数据结构"><a href="#java基本数据结构" class="headerlink" title="java基本数据结构"></a>java基本数据结构</h2><p>其实学一门语言，基础很重要，现在很多java程序员只是对jdk和各种框架特别熟悉，能熟练地使用各种包和api组件，包括现在很多培训都是灌输这些所谓的实际应用。这会导致学到最后只会照葫芦画瓢。</p><p>java数据结构的只是体系包括线性表、树、数组、集合、矩阵、排序、查找、哈希表，并将java的设计思想、方法及一些常见的算法、设计模式贯穿其中。</p><p>其中线性表、链表、哈希表是最为常用的数据结构，在进行java开发时，jdk已经为我们提供了一系列相应的类，如下图。来实现基本的数据结构。这些类均在java.util包中。</p><p><strong>Collection</strong></p><ul><li>List<ul><li>LinkedList</li><li>ArrayList</li><li>Vector(Stack)</li></ul></li><li>Set</li><li>Queue</li></ul><p><strong>Map</strong></p><ul><li>Hashtable</li><li>HashMap</li><li>WeakHashMap</li></ul><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>接口Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。主要分为两类，LIst和Set，它们是以是否允许有相同元素来区分。当然其结构也不同。</p><p>所有实现Collection接口的类都必须提供两个标准的构造函数。无参为空，有参则可复制一个传入的Collection。</p><p>如何遍历？可以通过迭代器iterator()方法，注意访问Collection中的每一个元素，这种方式也是所有继承于它的类都可以使用的遍历方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection collection = new ArrayList&lt;String&gt;();</span><br><span class="line">Iterator i = collection.iterator();</span><br><span class="line">while(i.hasNext())&#123;</span><br><span class="line">Object s = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的派生类包括List和Set，以下是他接口中的主要方法：</p><ul><li>boolean add(Object o)：用于添加对象到集合</li><li>boolean remove(Object o)：用于删除指定的对象</li><li>int size()：用于返回当前集合中元素的个数</li><li>boolean isEmpty()：用于判断集合是否为空。</li><li>Iterator iterator()：返回一个迭代器</li><li>boolean contains(Object o)：用于查找集合中是否有指定的对象</li><li>boolean containsAll(Collection c)：用于查找集合中是否有集合c中的元素</li><li>boolean addAll（Collection c）：用于将集合c中的元素全部添加到该集合中</li><li>void clear()：用于清空该集合</li><li>void removeAll(Collection c)：用于从集合中删除从集合中所有的元素</li><li>void retainAll(Collection c)：从集合中删除集合c中不包含的元素</li></ul><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>List是有序的Collection，用户能够使用索引来访问List中的元素，类似数组。</p><p>LIst包括以下几种子类</p><ol><li>ArrayList:：是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。</li><li>LinkedList：是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率高，但随机插入、随机删除效率低。</li><li>Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。</li><li>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</li></ol><p>如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。<br>(01) 对于需要快速插入，删除元素，应该使用LinkedList。<br>(02) 对于需要快速随机访问元素，应该使用ArrayList。<br>(03)<br>对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。<br>对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。<br>通过下面的测试程序，我们来验证上面的(01)和(02)结论。参考代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Class;</span><br><span class="line">/*</span><br><span class="line"> * @desc 对比ArrayList和LinkedList的插入、随机读取效率、删除的效率</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> */</span><br><span class="line">public class ListCompareTest &#123;</span><br><span class="line">    private static final int COUNT = 100000;</span><br><span class="line">    private static LinkedList linkedList = new LinkedList();</span><br><span class="line">    private static ArrayList arrayList = new ArrayList();</span><br><span class="line">    private static Vector vector = new Vector();</span><br><span class="line">    private static Stack stack = new Stack();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 换行符</span><br><span class="line">        System.out.println(&quot;插入元素&quot;);</span><br><span class="line">        // 插入</span><br><span class="line">        insertByPosition(stack) ;</span><br><span class="line">        insertByPosition(vector) ;</span><br><span class="line">        insertByPosition(linkedList) ;</span><br><span class="line">        insertByPosition(arrayList) ;</span><br><span class="line">        // 换行符</span><br><span class="line">        System.out.println(&quot;随机读取&quot;);</span><br><span class="line">        // 随机读取</span><br><span class="line">        readByPosition(stack);</span><br><span class="line">        readByPosition(vector);</span><br><span class="line">        readByPosition(linkedList);</span><br><span class="line">        readByPosition(arrayList);</span><br><span class="line">        // 换行符</span><br><span class="line">        System.out.println(&quot;删除元素&quot;);</span><br><span class="line">        // 删除 </span><br><span class="line">        deleteByPosition(stack);</span><br><span class="line">        deleteByPosition(vector);</span><br><span class="line">        deleteByPosition(linkedList);</span><br><span class="line">        deleteByPosition(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取list的名称</span><br><span class="line">    private static String getListName(List list) &#123;</span><br><span class="line">        if (list instanceof LinkedList) &#123;</span><br><span class="line">            return &quot;LinkedList&quot;;</span><br><span class="line">        &#125; else if (list instanceof ArrayList) &#123;</span><br><span class="line">            return &quot;ArrayList&quot;;</span><br><span class="line">        &#125; else if (list instanceof Stack) &#123;</span><br><span class="line">            return &quot;Stack&quot;;</span><br><span class="line">        &#125; else if (list instanceof Vector) &#123;</span><br><span class="line">            return &quot;Vector&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;List&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 向list的指定位置插入COUNT个元素，并统计时间</span><br><span class="line">    private static void insertByPosition(List list) &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        // 向list的位置0插入COUNT个数</span><br><span class="line">        for (int i=0; i&lt;COUNT; i++)</span><br><span class="line">            list.add(0, i);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        long interval = endTime - startTime;</span><br><span class="line">        System.out.println(getListName(list) + &quot; : insert &quot;+COUNT+&quot; elements into the 1st position use time：&quot; + interval+&quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 从list的指定位置删除COUNT个元素，并统计时间</span><br><span class="line">    private static void deleteByPosition(List list) &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        // 删除list第一个位置元素</span><br><span class="line">        for (int i=0; i&lt;COUNT; i++)</span><br><span class="line">            list.remove(0);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        long interval = endTime - startTime;</span><br><span class="line">        System.out.println(getListName(list) + &quot; : delete &quot;+COUNT+&quot; elements from the 1st position use time：&quot; + interval+&quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据position，不断从list中读取元素，并统计时间</span><br><span class="line">    private static void readByPosition(List list) &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        // 读取list元素</span><br><span class="line">        for (int i=0; i&lt;COUNT; i++)</span><br><span class="line">            list.get(i);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        long interval = endTime - startTime;</span><br><span class="line">        System.out.println(getListName(list) + &quot; : read &quot;+COUNT+&quot; elements by position use time：&quot; + interval+&quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br>插入元素<br>Stack : insert 100000 elements into the 1st position use time：1544 ms<br>Vector : insert 100000 elements into the 1st position use time：1520 ms<br>LinkedList : insert 100000 elements into the 1st position use time：17 ms<br>ArrayList : insert 100000 elements into the 1st position use time：1519 ms<br>随机读取<br>Stack : read 100000 elements by position use time：7 ms<br>Vector : read 100000 elements by position use time：7 ms<br>LinkedList : read 100000 elements by position use time：8023 ms<br>ArrayList : read 100000 elements by position use time：2 ms<br>删除元素<br>Stack : delete 100000 elements from the 1st position use time：1553 ms<br>Vector : delete 100000 elements from the 1st position use time：1525 ms<br>LinkedList : delete 100000 elements from the 1st position use time：9 ms<br>ArrayList : delete 100000 elements from the 1st position use time：1547 ms</p><p>这里只是对性能做了大致的测试，如果需要研究为何产生如此差异，需要看下数据结构的相关资料。</p><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>Set接口是一种不包含重复元素的Collection，也就是说任何两个在Set里面的元素都存在以下e1.equals(e2) == false关系，且Set最多只有一个NULL元素。很明显，Set的构造函数有一个约束条件，就是传入的Collection参数不能包含重复的元素。</p><h4 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h4><p>Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Queue接 口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。BlockingQueue 继承了Queue接口。</p><p>队列是一种数据结构．它有两个基本操作：在队列尾部加人一个元素，和从队列头部移除一个元素就是说，队列以一种先进先出的方式管理数据，如果你试图向一个 已经满了的阻塞队列中添加一个元素或者是从一个空的阻塞队列中移除一个元索，将导致线程阻塞．在多线程进行合作时，阻塞队列是很有用的工具。工作者线程可 以定期地把中间结果存到阻塞队列中而其他工作者线线程把中间结果取出并在将来修改它们。队列会自动平衡负载。如果第一个线程集运行得比第二个慢，则第二个 线程集在等待结果时就会阻塞。如果第一个线程集运行得快，那么它将等待第二个线程集赶上来。下表显示了jdk1.5中的阻塞队列的操作：</p><ul><li>add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li><li>remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</li><li>element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</li><li>offer 添加一个元素并返回true 如果队列已满，则返回false</li><li>poll 移除并返问队列头部的元素 如果队列为空，则返回null</li><li>peek 返回队列头部的元素 如果队列为空，则返回null</li><li>put 添加一个元素 如果队列满，则阻塞</li><li>take 移除并返回队列头部的元素 如果队列为空，则阻塞</li></ul><p>remove、element、offer 、poll、peek 其实是属于Queue接口。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map接口没有继承于接口Collection，Map提供key到value的映射。键值对key-value，主要方法如下：</p><ul><li>boolean equals(Object o)：用于比较对象</li><li>boolean remove(Object o)：用于删除一个对象</li><li>void put(Object key, Object value)：用于添加key和value</li></ul><p>Map可分为HashMap、HashTable、WeakHashMap、ConcurrentHashMap等。但是我们常用的主要是HashMap和HashTable，下面比较下两者区别：</p><ol><li>HashMap是非线程安全的，HashTable是线程安全的。</li><li>HashMap的键和值都允许有null值存在，而HashTable则不行。</li><li>因为线程安全的问题，HashMap效率比HashTable的要高。</li></ol><p>能答出上面的三点，简单的面试，算是过了，但是如果再问：Java中的另一个线程安全的与HashMap及其类似的类是什么？(ConcurrentHashMap)同样是线程安全，它与HashTable在线程同步上有什么不同？(synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，锁住的都是对象整体，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象)能把第二个问题完整的答出来，说明你的基础算是不错的了。下面浅析更多区别。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>1) hashmap的数据结构</p><p>Hashmap是一个数组和链表的结合体（在数据结构称“链表散列“），如下图示：<br><img src="/image/1473689948894.png" alt="img"><br>当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。</p><p>2)使用和遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;Rajib Sarma&quot;,&quot;100&quot;);</span><br><span class="line">map.put(&quot;Rajib Sarma&quot;,&quot;200&quot;);//The value &quot;100&quot; is replaced by &quot;200&quot;.</span><br><span class="line">map.put(&quot;Sazid Ahmed&quot;,&quot;200&quot;);</span><br><span class="line"></span><br><span class="line">Iterator iter = map.entrySet().iterator();</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">    Object key = entry.getKey();</span><br><span class="line">    Object val = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashTable和HashMap区别"><a href="#HashTable和HashMap区别" class="headerlink" title="HashTable和HashMap区别"></a>HashTable和HashMap区别</h3><ul><li>继承不同。<br>public class Hashtable extends Dictionary implements Map<br>public class HashMap extends AbstractMap implements Map</li><li>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</li><li>Hashtable中，key和value都不允许出现null值。<br>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</li><li>两个遍历方式的内部实现上不同。<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</li><li>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</li><li>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;java基本数据结构&quot;&gt;&lt;a href=&quot;#java基本数据结构&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="java base" scheme="http://www.fufan.me/categories/java-base/"/>
    
    
      <category term="java 数据结构" scheme="http://www.fufan.me/tags/java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA的Reflection反射机制</title>
    <link href="http://www.fufan.me/2016/09/11/JAVA%E7%9A%84Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.fufan.me/2016/09/11/JAVA的Reflection反射机制/</id>
    <published>2016-09-11T06:55:00.000Z</published>
    <updated>2018-10-02T13:09:10.315Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --><h3 id="反射即reflection"><a href="#反射即reflection" class="headerlink" title="反射即reflection"></a><strong>反射即reflection</strong></h3><p>java反射运用了代理模式，代理模式在之后学习的设计模式中可以了解</p><p>反射主要用了以下几点：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法</li></ul><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>首先要搞清楚Class这个类，每个类在创建的时候都会有Class这个类伴随产生，这个Class是JVM产生的，<br>由于是JVM产生的，所以我们一般获取Class的方法是：</p><ol><li>object.getClass()</li><li>Class.forName(“java.lang.String”)</li><li>Class.getSuperClass()</li><li>运用.class语法,如java.lang.String.class</li><li>primitive wrapper classes的TYPE语法,如：Boolean.TYPE，类似Boolean.class</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = s.getClass();</span><br><span class="line">Class&lt;?&gt; clazz2 = Class.forName(&quot;com.fufan.reflection.Son&quot;);</span><br><span class="line">Class&lt;?&gt; clazz3 = clazz2.getSuperclass();</span><br><span class="line">Class&lt;?&gt; clazz4 = com.fufan.reflection.Son.class;</span><br><span class="line">Class&lt;?&gt; clazz5 = Boolean.class;</span><br></pre></td></tr></table></figure><p>Class是Reflection起源。针对任何您想探勘的class，唯有先为它产生一个Class object，接下来才能经由后者唤起为数十多个的Reflection APIs<br>接下来就可以通过Class调用衍生出的一系列API：</p><ul><li>getName()：获得类的完整名字。</li><li>getFields()：获得类的public类型的属性。</li><li>getDeclaredFields()：获得类的所有属性。</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</li></ul><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p>Filed类：代表类的成员变量（成员变量也称为类的属性）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fieldName = field.getName();</span><br></pre></td></tr></table></figure><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method类：代表类的方法，invoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = getMethod.invoke(object, new Object[] &#123;&#125;);</span><br></pre></td></tr></table></figure><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>Constructor类：代表类的构造方法，调用有参和无参</p><ul><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li><li>newInstance(new Object[]{value})：当调用有参构造函数时使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//无参构造方法</span><br><span class="line">Constructor constructor1 = classType.getConstructor();</span><br><span class="line"></span><br><span class="line">//有参构造方法</span><br><span class="line">Constructor constructor2 = classType.getConstructor(new Class[] &#123;int.class, String.class&#125;);</span><br></pre></td></tr></table></figure><h4 id="代码示例1"><a href="#代码示例1" class="headerlink" title="代码示例1"></a>代码示例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 获得对象的类型</span><br><span class="line"> Class&lt;?&gt; classType = object.getClass();</span><br><span class="line"> System.out.println(&quot;Class:&quot; + classType.getName());</span><br><span class="line"></span><br><span class="line"> // 通过默认构造方法创建一个新的对象</span><br><span class="line"> Object objectCopy = classType.getConstructor(new Class[] &#123;&#125;).newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line"> // 获得对象的所有属性</span><br><span class="line"> Field fields[] = classType.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"> for (int i = 0; i &lt; fields.length; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     Field field = fields[i];</span><br><span class="line">     String fieldName = field.getName();</span><br><span class="line">     String firstLetter = fieldName.substring(0, 1).toUpperCase();</span><br><span class="line">     // 获得和属性对应的getXXX()方法的名字</span><br><span class="line">     String getMethodName = &quot;get&quot; + firstLetter + fieldName.substring(1);</span><br><span class="line">     // 获得和属性对应的setXXX()方法的名字</span><br><span class="line">     String setMethodName = &quot;set&quot; + firstLetter + fieldName.substring(1);</span><br><span class="line">     // 获得和属性对应的getXXX()方法</span><br><span class="line">     Method getMethod = classType.getMethod(getMethodName, new Class[] &#123;&#125;);</span><br><span class="line">     // 获得和属性对应的setXXX()方法</span><br><span class="line">     Method setMethod = classType.getMethod(setMethodName, new Class[] &#123; field.getType() &#125;);</span><br><span class="line">     // 调用原对象的getXXX()方法</span><br><span class="line">     Object value = getMethod.invoke(object, new Object[] &#123;&#125;);</span><br><span class="line">     System.out.println(fieldName + &quot;:&quot; + value);</span><br><span class="line">     // 调用拷贝对象的setXXX()方法</span><br><span class="line">     setMethod.invoke(objectCopy, new Object[] &#123; value &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</p><h4 id="代码示例2"><a href="#代码示例2" class="headerlink" title="代码示例2"></a>代码示例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//一维数组的使用</span><br><span class="line">Object array = Array.newInstance(Integer.TYPE, 10);</span><br><span class="line">System.out.println(Integer.TYPE);</span><br><span class="line">for(int index=1; index&lt;10; index ++)&#123;</span><br><span class="line">Array.set(array, index, index);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Array.get(array, 4));</span><br><span class="line"></span><br><span class="line">//多维数组的使用</span><br><span class="line"></span><br><span class="line">Object arrays = Array.newInstance(String.class, 3,5);</span><br><span class="line"></span><br><span class="line">Object array1 = Array.get(arrays, 2);</span><br><span class="line"></span><br><span class="line">Array.set(array1, 3, &quot;fufan&quot;);</span><br><span class="line"></span><br><span class="line">String[][] arrayInt = (String[][]) arrays; </span><br><span class="line">System.out.println(arrayInt[1][3]);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 02 2018 21:27:24 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;反射即reflection&quot;&gt;&lt;a href=&quot;#反射即reflection&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java base" scheme="http://www.fufan.me/categories/java-base/"/>
    
    
      <category term="java" scheme="http://www.fufan.me/tags/java/"/>
    
  </entry>
  
</feed>
