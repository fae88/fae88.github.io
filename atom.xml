<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Gemini Boy</title>
  
  <subtitle>welcome to my site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fufan.me/"/>
  <updated>2019-03-09T08:29:19.535Z</updated>
  <id>http://www.fufan.me/</id>
  
  <author>
    <name>fae88</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程重新出发（三）——  Java内存模型如何解决有序性和可见性</title>
    <link href="http://www.fufan.me/2019/03/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%9C%89%E5%BA%8F%E6%80%A7%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>http://www.fufan.me/2019/03/09/并发编程重新出发（三）——-Java内存模型如何解决有序性和可见性/</id>
    <published>2019-03-09T08:29:13.000Z</published>
    <updated>2019-03-09T08:29:19.535Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 16:29:19 GMT+0800 (China Standard Time) --><ul><li>什么是JAVA内存模型</li><li>Java内存模型涉及的几个关键词</li><li>Happens-Before的7个规则</li></ul><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。</p><p>我们知道，导致可见性的原因是缓存，导致有序性的原因是编译优化。合理方案就是按需禁用缓存和编译优化，Java中使用volatile、synchronized和final三个关键字。，以及happens-before规则。</p><h3 id="Java内存模型涉及的几个关键词"><a href="#Java内存模型涉及的几个关键词" class="headerlink" title="Java内存模型涉及的几个关键词"></a>Java内存模型涉及的几个关键词</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。Java1.5之后对volatile进行了增强，其本质就是加了happens-before规则。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。</p><h3 id="Happens-Before的7个规则"><a href="#Happens-Before的7个规则" class="headerlink" title="Happens-Before的7个规则"></a>Happens-Before的7个规则</h3><p>(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。<br>(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。<br>(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序。<br>(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。<br>(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p><p><strong>Happens-Before的1个特性：传递性。</strong></p><h3 id="Java内存模型底层怎么实现的"><a href="#Java内存模型底层怎么实现的" class="headerlink" title="Java内存模型底层怎么实现的"></a>Java内存模型底层怎么实现的</h3><p>主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 16:29:19 GMT+0800 (China Standard Time) --&gt;&lt;ul&gt;&lt;li&gt;什么是JAVA内存模型&lt;/li&gt;&lt;li&gt;Java内存模型涉及的几个关键词&lt;/li&gt;&lt;li&gt;Happens-Befo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并发编程重新出发（二）——  有序性、原子性、可见性</title>
    <link href="http://www.fufan.me/2019/01/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>http://www.fufan.me/2019/01/26/并发编程重新出发（二）——-有序性、原子性、可见性/</id>
    <published>2019-01-26T07:47:00.000Z</published>
    <updated>2019-03-09T07:48:50.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 15:48:51 GMT+0800 (China Standard Time) --><p>并发编程bug的源头：</p><ul><li>有序性</li><li>原子性</li><li>可见性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发编程源头故事</span><br><span class="line"></span><br><span class="line">自从发明出计算机以后，我们知道冯诺依曼的结构，我们一直在解决一个问题：CPU、内存、IO三者之前速度的差异。我们做了这些</span><br><span class="line"></span><br><span class="line">* 1. CPU增加了缓存</span><br><span class="line">* 2. 操作系统增加了线程、进程，来分时复用CPU，进而平衡CPU和IO之前的速度差异</span><br><span class="line">* 3. 编译指令的执行顺序优化，以便更好地利用缓存。</span><br></pre></td></tr></table></figure><h3 id="源头之一：存储导致可见性"><a href="#源头之一：存储导致可见性" class="headerlink" title="源头之一：存储导致可见性"></a>源头之一：存储导致可见性</h3><p>在单核时代，我们只有一块CPU，那么我们在CPU的缓存也只有一份，那么不同线程通过缓存取到的值也是确定的。</p><p><strong>可见性：一个线程对变量进行修改后，其他线程能及时看到。</strong></p><p>但是到了多核时代，我们可以看到每块CPU都有自己的缓存，那么就会出现如何同步内存和CPU缓存的一个问题。比如下图，线程A操作的是CPU-1的缓存v变量，而线程B是CPU-2的v变量，就不具备可见性了</p><p><img src="/image/concurrent-1-0.jpg" alt=""></p><h3 id="源头之二：线程切换带来的原子性问题"><a href="#源头之二：线程切换带来的原子性问题" class="headerlink" title="源头之二：线程切换带来的原子性问题"></a>源头之二：线程切换带来的原子性问题</h3><p>当然，在早期的单核时代，我们也是支持多任务的，也就是统一个CPU是可以支持多个进程切换的方式来执行指令。操作系统会允许某个进程执行一段时间，然后切换到另一个进程，这一段就叫’时间片‘。</p><p>线程切换示意图</p><p><img src="/image/concurrent-1-1.jpg" alt=""></p><p>在一个时间片中，如果一个进程停留在读IO的话，就没必要占用CPU了，就会休眠此线程，让出CPU使用权，待IO完成，就会被操作系统在休眠中被唤醒。唤醒后的进程就有机会重新获取使用权了。这种支持CPU分时复用的方式，最早是Unix提出并应用。</p><p>java中主要指的多线程之间的切换，任务切换大多数是时间片结束的时候，我们使用高级语言中一条语句基本会分成几条CPU指令来执行，如count += 1；需要三条指令：</p><ol><li>获取count的值</li><li>在寄存器中 + 1 操作；</li><li>将结果写进内存</li></ol><p>我们知道，CPU指令是不知道目前执行的是哪个线程给的，所以可以发生在任一时刻，当A线程在操作2的时候CPU执行权被抢走的话，如果B线程也在操作count时，在回到A的时候，继续讲count+1存入内存，那就会丢失B线程对count的操作记录。如下图：</p><p><img src="/image/concurrent-1-2.jpg" alt=""></p><p><strong>原子性：一个或者多个操作在CPU执行的过程中不被终端的特性</strong></p><p>源头三：编译优化带来的指令有序性问题</p><p>之前提到过，编译器为了优化指令，在不影响结果的情况下，可能会对CPU的部分指令进行指令重排序。经典的java案例就是双重检测加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  static Singleton instance;</span><br><span class="line">  static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家都结果了，这里直接上图：</p><p><img src="/image/concurrent-1-3.jpg" alt=""></p><p>我们解决方法就是把instance变量设为volatile，该关键字可以保证防止指令重排序和可见性，但不能保证原子性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上三点是我们在排查并发BUG时，通常会出现，我觉得这三点是本质上的原因，值得我们好好理解。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 15:48:51 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;并发编程bug的源头：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;有序性&lt;/li&gt;&lt;li&gt;原子性&lt;/li&gt;&lt;li&gt;可见性&lt;/li&gt;&lt;/ul&gt;&lt;f
      
    
    </summary>
    
      <category term="并发编程" scheme="http://www.fufan.me/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://www.fufan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程重新出发（一）—— 在全局角度看并发</title>
    <link href="http://www.fufan.me/2019/01/23/Untitled-1/"/>
    <id>http://www.fufan.me/2019/01/23/Untitled-1/</id>
    <published>2019-01-23T06:30:00.000Z</published>
    <updated>2019-03-09T07:49:06.215Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 15:49:06 GMT+0800 (China Standard Time) --><p>首先，编程中很多模式和解决方案都是源于生活，其实并发编程也一样，如烧水泡茶、做菜等。其实核心就是三个：<strong>分工、协同、互斥。</strong></p><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>类似完成一个项目一样，作为项目经理，如果想要用最高效的方式来完成，那么就要考虑如何分工。并发编程里的模式，基本也是和分工相关，如<strong>生产者-消费者模式、Thread-Per-Message、Worker Thread</strong>等都是先处理如何分工。</p><p>如生产者消费者模式中，就像是饭店里厨子和服务员的一样关系，多个厨子是生产者，不停的做出一道道菜，多个服务员是消费者，不停的取菜，然后端给客人。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>分工好以后，就是具体执行。当然我们目标是完成同一件事情，那么各个角色之前就要有一个协作，即<strong>当一个线程执行完了一个任务以后，如何通知其他线程对其继续执行</strong>。</p><p>java并发包里的Executor、Fork/Join、Future等本质上是分工方法，但同时也解决了同步的问题，比如Future，他在主线程中执行了submit以后，就通过get方法来等待该任务完成后，再继续做其他事情。这里的Future帮我们解决了主线程和异步线程之前的协作问题。不过在很多情况下需要我们自己来处理协作问题。</p><p>另外，CountDownLatch、SephaMore，CyclicBarrier、Phaser、Exchanger等，在我的其他博文中有剖析。</p><p>管程（Monitors，监视器），是解决并发的万能钥匙。</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p><strong>分工和同步主要解决的是性能问题</strong>，既然性能提高上来了，但是我们追求的是问题的正确性，所以必须要考虑到一些极端情况下的问题。<strong>所以互斥就是为了保证线程安全</strong></p><p><strong>所以互斥，其实就是在同一时刻，只能有一个线程拿到共享的变量（资源）</strong></p><p><strong>那么，要实现互斥最核心的就是加锁。</strong>java中的synchronized、volitile、各种Lock就是来解决互斥问题。我们要考虑的就是如何使用互斥，才能既保证在程序正确性的条件下，完成性能最优的程序。大量的锁也会让性能变差，所以我们现在也有通过CAS等方式来进行无锁编程，如java中的原子类就是通过无锁技术来实现的。</p><p>除了锁，还有其他方案，原理其实就是<strong>写互斥，读共享或者不共享变量</strong>，比如ThreadLocal，final字段。还有一种Copy-on-write。</p><p>当然，锁编程是相对较难的一部分，要考虑的东西比较多，而且也容易出bug，比如死锁等问题。</p><p>下面的图就是刚刚提到的这三个并发核心的结构</p><p><img src="/image/concurrent-0-0.jpg" alt=""></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 15:49:06 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;首先，编程中很多模式和解决方案都是源于生活，其实并发编程也一样，如烧水泡茶、做菜等。其实核心就是三个：&lt;strong&gt;分工、
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://www.fufan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（四）—— 数组</title>
    <link href="http://www.fufan.me/2019/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E6%95%B0%E7%BB%84/"/>
    <id>http://www.fufan.me/2019/01/15/数据结构与算法学习（三）——-数组/</id>
    <published>2019-01-15T15:41:00.000Z</published>
    <updated>2019-03-05T15:42:08.684Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数组</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="线性表（linear-list）"><a href="#线性表（linear-list）" class="headerlink" title="线性表（linear list）"></a>线性表（linear list）</h4><p>就是数据排成一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，除了数组以外还有链表、队列、栈等。<br><img src="/image/data-structure-3-0.jpg" alt=""><br>与他相对的是非线性表，如二叉树,堆，图等<br><img src="/image/data-structure-3-1.jpg" alt=""></p><h4 id="连续的内存空间和相同的数据类型"><a href="#连续的内存空间和相同的数据类型" class="headerlink" title="连续的内存空间和相同的数据类型"></a>连续的内存空间和相同的数据类型</h4><p>之所以他可以随机访问的原因就在于它是连续存储的，你可以通过数组下表和首地址来获取到所在位置的内存地址并访问。当然这也使得如果要在数组中删除和插入数据时，需要做大量数据搬运的工作，显得低效。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h5 id="如何优化-低效的插入和删除"><a href="#如何优化-低效的插入和删除" class="headerlink" title="如何优化 低效的插入和删除"></a>如何优化 低效的插入和删除</h5><p>我们可以算出，插入和删除的平均时间复杂度都为O(n)。</p><p><img src="/image/data-structure-3-2.jpg" alt=""></p><p>如上图所示，当我们需要删除abc的时候，正常的操作就会搬移defgh这些数据3次，我们可以先记录下已删除的数据，每次删除操作都不是真正的搬移数据，而是记录已经被删除的，当数组没有空间时，我们再执行删除操作，这是一种思维。其实JVM中的标记清除算法也是用到了这种思想。</p><h4 id="数组为何从0开始编号"><a href="#数组为何从0开始编号" class="headerlink" title="数组为何从0开始编号"></a>数组为何从0开始编号</h4><p>可以想象，机器在计算数组内存地址的时候，下标就是偏移，公式为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><p></p><p>如果1开始计数的话，就会变为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p></p><p>对于两个公式来说，CPU是多了一次减法指令的，数组是很基础的一个数据结构，就要把优化做到极致。</p><p>最早是C语言是最早用0开始计数的，其他语言也纷纷效仿</p><h4 id="容器能否代替数组"><a href="#容器能否代替数组" class="headerlink" title="容器能否代替数组"></a>容器能否代替数组</h4><p>java中的ArrayList是大多是java开发工程师最多接触的类型，ArrayList 最大的优势就是可以将很多数组操作的细节封装起来，像插入删除等，另外还能支持动态扩容。但是扩容的话原理是这样的，因为原生的数组是必须初始化大小的，而即使是ArrayList也是一样的，他初始化固定的大小10个元素，而扩容时会增加原来的1.5倍大小，但是扩容过程的话是会涉及到内存申请、数组的拷贝和搬移，所以最好是初始化的时候指定ArrayList大小，这样会省去很多次内存申请和数据搬移操作。</p><p>当然，我们也同样可以列出原生数组的优势：</p><ul><li>ArrayList是不能装原生类型的，如int、long等，只能放包装类Integer、Long。</li><li>数据量大小已知的情况下，且使用数组操作简单时，数组更优</li><li>多维数组时，往往用数组更直观，如Object[][]</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.fufan.me/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法与数据结构" scheme="http://www.fufan.me/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>HTTP连接的几个TIMEOUT</title>
    <link href="http://www.fufan.me/2019/01/13/http%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%87%A0%E4%B8%AATimeout/"/>
    <id>http://www.fufan.me/2019/01/13/http连接的几个Timeout/</id>
    <published>2019-01-13T14:32:00.000Z</published>
    <updated>2019-03-05T14:33:54.995Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h3 id="HTTP连接的几个TIMEOUT"><a href="#HTTP连接的几个TIMEOUT" class="headerlink" title="HTTP连接的几个TIMEOUT"></a>HTTP连接的几个TIMEOUT</h3><ol><li><p>connectTimeOut：指建立连接的超时时间，比较容易理解</p></li><li><p>connectionRequestTimeOut：指从连接池获取到连接的超时时间，如果是非连接池的话，该参数暂时没有发现有什么用处</p></li><li>socketTimeOut：指客户端和服务进行数据交互的时间，是指两者之间如果两个数据包之间的时间大于该时间则认为超时，而不是整个交互的整体时间，比如如果设置1秒超时，如果每隔0.8秒传输一次数据，传输10次，总共8秒，这样是不超时的。而如果任意两个数据包之间的时间超过了1秒，则超时。</li></ol><p>线上问题：设置sockettimeout 15秒，但是实际到达156秒，线程数陡增，导致机器崩溃，具体原因有待抓包分析</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;HTTP连接的几个TIMEOUT&quot;&gt;&lt;a href=&quot;#HTTP连接的几个TIMEOUT&quot; class=&quot;head
      
    
    </summary>
    
      <category term="http" scheme="http://www.fufan.me/categories/http/"/>
    
    
      <category term="http" scheme="http://www.fufan.me/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（二）—— 复杂度分析（上）</title>
    <link href="http://www.fufan.me/2019/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://www.fufan.me/2019/01/02/数据结构与算法学习（一）——-复杂度分析/</id>
    <published>2019-01-02T02:07:00.000Z</published>
    <updated>2019-02-21T15:09:40.724Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>复杂度分析是算法学习的精髓，对面任何代码和场景下，都需要学会分析其复杂度分析</p><h4 id="为什么需要复杂度分析"><a href="#为什么需要复杂度分析" class="headerlink" title="为什么需要复杂度分析"></a>为什么需要复杂度分析</h4><ol><li><p>测试结果依赖测试环境</p></li><li><p>测试结果受数据规模的影响很大</p></li></ol><h4 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h4><p>下面通过例子来表示如何计算复杂度</p><h5 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i ++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码我们把每一行作为一个CPU执行的unit_time，那么算起来执行的次数为2n+2次，那么我们可以算出T(n)=O(n)</p><h5 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i ++) &#123;</span><br><span class="line">       j = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> ( ; j &lt; n; j ++) &#123;</span><br><span class="line">            sum += i*j;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，我们也可以得到执行次数为2n²+2n+3 次，所以我们得到T(n)=O(n²)</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><ol><li><p>只关注循环执行次数最多的那段代码</p></li><li><p>加发法则，总复杂度等于量级最大的那段代码的复杂度<br>如果T1(n)=O(f(n)), T2(n)=O(g(n));那么T(n)=T1 + T2 = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))</p></li><li><p>乘法法则：嵌套代码复杂度等于内外嵌套代码复杂度乘积<br>T1(n)=O(f(n)), T2(n)=O(g(n));那么T(n)=T1 + T2 = T1(n) <em>T2(n) = O(f(n)</em>g(n))</p></li></ol><h4 id="常见的几种复杂度"><a href="#常见的几种复杂度" class="headerlink" title="常见的几种复杂度"></a>常见的几种复杂度</h4><h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><p>一般情况下，如果算法中没有循环语句、递归语句，即使上万行代码，复杂度也是O(1)</p><h5 id="O-logn-O-nlogn"><a href="#O-logn-O-nlogn" class="headerlink" title="O(logn),O(nlogn)"></a>O(logn),O(nlogn)</h5><p>比如下面这行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line"> i = i * <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>i从1开始取，每次乘以2 ，可以算出这个while循环的执行次数就是log2n，即O(log2n)</p><p>再可以改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line"> i = i * <span class="number">3</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此时为O(log3n)，由于对数互相转换，加上复杂度里常量可以忽略，这种情况我们可以都记为O(logn)。</p><p>O(nlogn)可以借助前面的乘法法则，可以举出例子。</p><h5 id="O-m-n-O-m-n"><a href="#O-m-n-O-m-n" class="headerlink" title="O(m+n), O(m*n)"></a>O(m+n), O(m*n)</h5><p>当我们引入两个未知循环次数的变量m,n时，就会得到 T1(m) + T2(n) = O(f(m) + g(n))</p><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><p>空间复杂度相对来说比较容易分析，</p><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系，空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的关系</p><p>常见的有O(1), O(n), O(n²)，像O(logn), O(nlogn)就很少见了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;复杂度分析是算法学习的精髓，对面任何代码和场景下，都需要学会分析其复杂度分析&lt;/p&gt;&lt;h4 id=&quot;为什么需要复杂度分析&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习（一）—— 绪论</title>
    <link href="http://www.fufan.me/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E7%BB%AA%E8%AE%BA/"/>
    <id>http://www.fufan.me/2019/01/01/数据结构与算法学习（一）——-绪论/</id>
    <published>2018-12-31T18:06:00.000Z</published>
    <updated>2019-02-21T15:08:42.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h3 id="什么是数据结构？什么是算法？"><a href="#什么是数据结构？什么是算法？" class="headerlink" title="什么是数据结构？什么是算法？"></a>什么是数据结构？什么是算法？</h3><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p><h3 id="一张图概括内容"><a href="#一张图概括内容" class="headerlink" title="一张图概括内容"></a>一张图概括内容</h3><p><img src="/image/data-structure-0-0.jpg" alt=""></p><h3 id="20个核心知识点"><a href="#20个核心知识点" class="headerlink" title="20个核心知识点"></a>20个核心知识点</h3><p>10个数据结构：数组、链表、队列、栈、散列表、堆、二叉树、跳表、图、Trie树；</p><p>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法；</p><h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><ol><li><p>边学边练、适度刷题</p></li><li><p>多问、多思考、不逃避问题</p></li><li><p>打怪升级学习</p></li><li><p>慢慢沉淀，切忌死记</p></li></ol><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><p>《算法导论》<br>《大话数据结构》<br>《剑指OFFER》</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;什么是数据结构？什么是算法？&quot;&gt;&lt;a href=&quot;#什么是数据结构？什么是算法？&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java多线程系列（十）——ReentrantLock的使用</title>
    <link href="http://www.fufan.me/2018/12/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94ReentrantLock%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.fufan.me/2018/12/24/java多线程系列（十）——ReentrantLock的使用/</id>
    <published>2018-12-24T08:17:00.000Z</published>
    <updated>2018-12-24T08:18:01.942Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>在java中我们在多线程中使用锁的话一般会用到synchronized和ReentrantLock的两种方式，有以下几个不同的层面：</p><ol><li>实现<br>synchronized是基于JVM层面实现的，而Lock是基于JDK层面实现的</li><li>使用<br>synchronized的使用相对简单，只需要针对对象加上关键字即可。ReentrantLock需要手动进行lock和unlock，同时还有相关封装的api</li><li>其他特点<br>ReentrantLock支持锁超时获取、锁中断响应、公平锁，而synchronized也在jdk1.5后引入了偏向锁，轻量级锁和重量级锁，从而大大的提高了synchronized的性能。</li></ol><p>下面主要介绍一下ReentrantLock的使用</p><h3 id="锁超时获取"><a href="#锁超时获取" class="headerlink" title="锁超时获取"></a>锁超时获取</h3><p>通过tryLock(long time, TimeUnit unit)的api来控制超时时间，返回true则获取到锁，返回false则锁被占用，是一个非阻塞方法，测试方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试锁超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReetrantLockTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                        log.info(<span class="string">"get lock thread &#123;&#125;"</span>, Thread.currentThread().getName()) ;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">"get lock error thread &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                        log.info(<span class="string">"get lock thread &#123;&#125;"</span>, Thread.currentThread().getName()) ;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">"get lock error thread &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16:04:33.502 [t2] ERROR thread.lock.ReetrantLockTest2 - get lock error thread t2</span><br><span class="line">16:04:33.502 [t1] INFO thread.lock.ReetrantLockTest2 - get lock thread t1</span><br></pre></td></tr></table></figure><p></p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。直接上代码，来演示使用重入锁如何解决死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KillDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KillDeadLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">                lock1.lockInterruptibly();  <span class="comment">// 以可以响应中断的方式加锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockInterruptibly();  <span class="comment">// 以可以响应中断的方式加锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"&#123;&#125; interrupted"</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) lock1.unlock();  <span class="comment">// 注意判断方式</span></span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) lock2.unlock();</span><br><span class="line">            log.error( <span class="string">"退出 &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        KillDeadLock deadLock1 = <span class="keyword">new</span> KillDeadLock(<span class="number">1</span>);</span><br><span class="line">        KillDeadLock deadLock2 = <span class="keyword">new</span> KillDeadLock(<span class="number">2</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(deadLock1, <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(deadLock2, <span class="string">"t2"</span>);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16:12:27.660 [t2] ERROR thread.lock.KillDeadLock - t2 interrupted</span><br><span class="line">16:12:27.673 [t2] ERROR thread.lock.KillDeadLock - 退出 t2</span><br><span class="line">16:12:27.673 [t1] ERROR thread.lock.KillDeadLock - 退出 t1</span><br></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLockTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                log.info(<span class="string">" &#123;&#125; 获取到了锁！"</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        FairLockTest test = <span class="keyword">new</span> FairLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test, <span class="string">"线程1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test, <span class="string">"线程2"</span>);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">16:12:43.884 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.884 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.884 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.884 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br><span class="line">16:12:43.885 [线程1] INFO thread.lock.FairLockTest -  线程1 获取到了锁！</span><br><span class="line">16:12:43.885 [线程2] INFO thread.lock.FairLockTest -  线程2 获取到了锁！</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock-配合-Conditond-使用"><a href="#ReentrantLock-配合-Conditond-使用" class="headerlink" title="ReentrantLock 配合 Conditond 使用"></a>ReentrantLock 配合 Conditond 使用</h4><p>配合关键字synchronized使用的方法如：await()、notify()、notifyAll()，同样配合ReentrantLock 使用的Conditon提供了以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 类似于Object.wait()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>; <span class="comment">// 与await()相同，但不会再等待过程中响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>; <span class="comment">// 类似于Obejct.notify()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    log.info(<span class="string">"into lock thread1"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    log.info(<span class="string">"get CPU again lock time: &#123;&#125;"</span>, lock.getHoldCount());</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    log.info(<span class="string">"get CPU again 2 lock time: &#123;&#125;"</span>, lock.getHoldCount());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"error"</span>, e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    log.info(<span class="string">"into lock thread2"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"error"</span>, e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16:15:24.970 [Thread-0] INFO thread.lock.ReentrantLockTest - into lock thread1</span><br><span class="line">16:15:27.980 [Thread-1] INFO thread.lock.ReentrantLockTest - into lock thread2</span><br><span class="line">16:15:30.986 [Thread-0] INFO thread.lock.ReentrantLockTest - get CPU again lock time: 1</span><br><span class="line">16:15:33.990 [Thread-0] INFO thread.lock.ReentrantLockTest - get CPU again 2 lock time: 2</span><br></pre></td></tr></table></figure><p>ReentrantLock的基本使用就先介绍到这里</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在java中我们在多线程中使用锁的话一般会用到synchronized和ReentrantLock的两种方式，有以下几个不同
      
    
    </summary>
    
      <category term="多线程" scheme="http://www.fufan.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.fufan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程系列（九）—— JUC中的阻塞队列</title>
    <link href="http://www.fufan.me/2018/12/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94-JUC%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://www.fufan.me/2018/12/06/java多线程系列（九）——-JUC中的阻塞队列/</id>
    <published>2018-12-06T04:00:00.000Z</published>
    <updated>2018-12-06T06:55:59.651Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h3 id="阻塞队列概要"><a href="#阻塞队列概要" class="headerlink" title="阻塞队列概要"></a>阻塞队列概要</h3><h4 id="阻塞队列说明"><a href="#阻塞队列说明" class="headerlink" title="阻塞队列说明"></a>阻塞队列说明</h4><p>阻塞队列与我们平常接触的普通队列(LinkedList或ArrayList等)的最大不同点，在于阻塞队列支出阻塞添加和阻塞删除方法。</p><ul><li>阻塞添加<br>所谓的阻塞添加是指当阻塞队列元素已满时，队列会阻塞加入元素的线程，直队列元素不满时才重新唤醒线程执行元素加入操作。</li><li>阻塞删除<br>阻塞删除是指在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作(一般都会返回被删除的元素)</li></ul><p>由于Java中的阻塞队列接口BlockingQueue继承自Queue接口，因此先来看看阻塞队列接口为我们提供的主要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</span></span><br><span class="line">    <span class="comment">//在成功时返回 true，如果此队列已满，则抛IllegalStateException。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） </span></span><br><span class="line">    <span class="comment">// 将指定的元素插入此队列的尾部，如果该队列已满， </span></span><br><span class="line">    <span class="comment">//则在到达指定的等待时间之前等待可用的空间,该方法可中断 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，如果没有元素则等待（阻塞）， </span></span><br><span class="line">    <span class="comment">//直到有元素将唤醒等待线程执行该操作 </span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头部，在指定的等待时间前一直等到获取元素， //超过时间方法将结束</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从此队列中移除指定元素的单个实例（如果存在）。 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除了上述方法还有继承自Queue接口的方法 </span></span><br><span class="line">    <span class="comment">//获取但不移除此队列的头元素,没有则跑异常NoSuchElementException </span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取但不移除此队列的头；如果此队列为空，则返回 null。 </span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并移除此队列的头，如果此队列为空，则返回 null。 </span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>插入方法：<br>add(E e) : 添加成功返回true，失败抛IllegalStateException异常<br>offer(E e) : 成功返回 true，如果此队列已满，则返回 false。<br>put(E e) :将元素插入此队列的尾部，如果该队列已满，则一直阻塞</p></li><li><p>删除方法:<br>remove(Object o) :移除指定元素,成功返回true，失败返回false<br>poll() : 获取并移除此队列的头元素，若队列为空，则返回 null<br>take()：获取并移除此队列头元素，若没有元素则一直阻塞。</p></li><li><p>检查方法<br>element() ：获取但不移除此队列的头元素，没有元素则抛异常<br>peek() :获取但不移除此队列的头；若队列为空，则返回 null。</p></li></ul><h4 id="阻塞队列的成员"><a href="#阻塞队列的成员" class="headerlink" title="阻塞队列的成员"></a>阻塞队列的成员</h4><table><thead><tr><th>队列</th><th>有界性</th><th>锁 数据结构</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>bounded(有界)</td><td>加锁 arrayList</td></tr><tr><td>LinkedBlockingQueue</td><td>optionally-bounded</td><td>加锁 linkedList</td></tr><tr><td>PriorityBlockingQueue</td><td>unbounded</td><td>加锁 heap</td></tr><tr><td>DelayQueue</td><td>unbounded</td><td>加锁 heap</td></tr><tr><td>SynchronousQueue</td><td>bounded</td><td>加锁 无</td></tr><tr><td>LinkedTransferQueue</td><td>unbounded</td><td>加锁 heap</td></tr><tr><td>LinkedBlockingDeque</td><td>unbounded</td><td>无锁 heap</td></tr></tbody></table><p>下面分别简单介绍一下：</p><ul><li>ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁】</li><li>LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。此队列按照先进先出的顺序进行排序。</li><li>PriorityBlockingQueue： 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</li><li>DelayQueue： 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（DelayQueue可以运用在以下应用场景：1.缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。2.定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。）</li><li>SynchronousQueue： 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li><li>LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</li><li>LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</li></ul><p>这里主要介绍阻塞队列中的两个实现类ArrayBlockingQueue和LinkedBlockingQueue的简单使用和实现原理</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>一个用数组实现的有界阻塞队列，其内部按先进先出的原则对元素进行排序</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>ArrayBlockingQueue的内部是通过一个可重入锁ReentrantLock和两个Condition条件对象来实现阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 存储数据的数组 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**获取数据的索引，主要用于take，poll，peek，remove方法 */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**添加数据的索引，主要用于 put, offer, or add 方法*/</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列元素的个数 */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 控制并非访问的锁 */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**notFull条件对象，用于通知put方法队列未满，可执行添加操作 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素的添加"><a href="#元素的添加" class="headerlink" title="元素的添加"></a>元素的添加</h5><p>这里的add方法和offer方法实现比较简单，其中需要注意的是enqueue(E x)方法，其方法内部通过putIndex索引直接将元素添加到数组items中，这里可能会疑惑的是当putIndex索引大小等于数组长度时，需要将putIndex重新设置为0，这是因为当前队列执行元素获取时总是从队列头部获取，而添加元素从中从队列尾部获取所以当队列索引（从0开始）与数组长度相等时，下次我们就需要从数组头部开始添加了</p><h6 id="add、offer、put"><a href="#add、offer、put" class="headerlink" title="add、offer、put"></a>add、offer、put</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add方法实现，间接调用了offer(e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (offer(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//offer方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     checkNotNull(e);<span class="comment">//检查元素是否为null</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();<span class="comment">//加锁</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (count == items.length)<span class="comment">//判断队列是否满</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             enqueue(e);<span class="comment">//添加元素到队列</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//通过putIndex索引对数组进行赋值</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">//索引自增，如果已是最后一个位置，重新设置 putIndex = 0;</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;<span class="comment">//队列中元素数量加1</span></span><br><span class="line">    <span class="comment">//唤醒调用take()方法的线程，执行元素获取操作。</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">put方法是一个阻塞的方法，如果队列元素已满，那么当前线程将会被notFull条件对象挂起加到等待队列中，直到队列有空档才会唤醒执行添加操作。但如果队列没有满，那么就直接调用enqueue(e)方法将元素加入到数组队列中。到此我们对三个添加方法即put，offer，add都分析完毕，其中offer，add在正常情况下都是无阻塞的添加，而put方法是阻塞添加。这就是阻塞队列的添加过程。说白了就是当队列满时通过条件对象Condtion来阻塞当前调用put方法的线程，直到线程又再次被唤醒执行。总得来说添加线程的执行存在以下两种情况，一是，队列已满，那么新到来的put线程将添加到notFull的条件队列中等待，二是，有移除线程执行移除操作，移除成功同时唤醒put线程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//put方法，阻塞时可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lockInterruptibly();<span class="comment">//该方法可中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == items.length)</span><br><span class="line">              <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中等待唤醒</span></span><br><span class="line">              notFull.await();</span><br><span class="line">          enqueue(e);<span class="comment">//如果队列没有满直接添加。。</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><h6 id="poll、remove、peek"><a href="#poll、remove、peek" class="headerlink" title="poll、remove、peek"></a>poll、remove、peek</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//删除队列头元素并返回</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//获取要删除的对象</span></span><br><span class="line">      E x = (E) items[takeIndex];</span><br><span class="line">      将数组中takeIndex索引位置设置为<span class="keyword">null</span></span><br><span class="line">      items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//takeIndex索引加1并判断是否与数组长度相等，</span></span><br><span class="line">      <span class="comment">//如果相等说明已到尽头，恢复为0</span></span><br><span class="line">      <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">          takeIndex = <span class="number">0</span>;</span><br><span class="line">      count--;<span class="comment">//队列个数减1</span></span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">          itrs.elementDequeued();<span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">      <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件对象添加线程，执行添加操作</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">poll()，获取并删除队列头元素，队列没有数据就返回null，内部通过dequeue()方法删除头元素，注释很清晰，这里不重复了。接着看remove(Object o)方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//获取数组数据</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果此时队列不为null，这里是为了防止并发情况</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//获取下一个要添加元素时的索引</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="comment">//获取当前要被删除元素的索引</span></span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="comment">//执行循环查找要删除的元素</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//找到要删除的元素</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    removeAt(i);<span class="comment">//执行删除</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//删除成功返回true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前删除索引执行加1后判断是否与数组长度相等</span></span><br><span class="line">                <span class="comment">//若为true，说明索引已到数组尽头，将i设置为0</span></span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>; </span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);<span class="comment">//继承查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引删除元素，实际上是把删除索引之后的元素往前移动一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="comment">//先判断要删除的元素是否为当前队列头元素</span></span><br><span class="line">      <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">          <span class="comment">//如果是直接删除</span></span><br><span class="line">          items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//当前队列头元素加1并判断是否与数组长度相等，若为true设置为0</span></span><br><span class="line">          <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">              takeIndex = <span class="number">0</span>;</span><br><span class="line">          count--;<span class="comment">//队列元素减1</span></span><br><span class="line">          <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">              itrs.elementDequeued();<span class="comment">//更新迭代器中的数据</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果要删除的元素不在队列头部，</span></span><br><span class="line">      <span class="comment">//那么只需循环迭代把删除元素后面的所有元素往前移动一个位置</span></span><br><span class="line">          <span class="comment">//获取下一个要被添加的元素的索引，作为循环判断结束条件</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">          <span class="comment">//执行循环</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex;;) &#123;</span><br><span class="line">              <span class="comment">//获取要删除节点索引的下一个索引</span></span><br><span class="line">              <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">              <span class="comment">//判断是否已为数组长度，如果是从数组头部（索引为0）开始找</span></span><br><span class="line">              <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                  next = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//如果查找的索引不等于要添加元素的索引，说明元素可以再移动</span></span><br><span class="line">              <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                  items[i] = items[next];<span class="comment">//把后一个元素前移覆盖要删除的元</span></span><br><span class="line">                  i = next;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//在removeIndex索引之后的元素都往前移动完毕后清空最后一个元素</span></span><br><span class="line">                  items[i] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                  <span class="keyword">break</span>;<span class="comment">//结束循环</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          count--;<span class="comment">//队列元素减1</span></span><br><span class="line">          <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">              itrs.removedAt(removeIndex);<span class="comment">//更新迭代器数据</span></span><br><span class="line">      &#125;</span><br><span class="line">      notFull.signal();<span class="comment">//唤醒添加线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">remove(Object o)方法的删除过程相对复杂些，因为该方法并不是直接从队列头部删除元素。首先线程先获取锁，再一步判断队列count&gt;0,这点是保证并发情况下删除操作安全执行。接着获取下一个要添加源的索引putIndex以及takeIndex索引 ，作为后续循环的结束判断，因为只要putIndex与takeIndex不相等就说明队列没有结束。然后通过while循环找到要删除的元素索引，执行removeAt(i)方法删除，在removeAt(i)方法中实际上做了两件事，一是首先判断队列头部元素是否为删除元素，如果是直接删除，并唤醒添加线程，二是如果要删除的元素并不是队列头元素，那么执行循环操作，从要删除元素的索引removeIndex之后的元素都往前移动一个位置，那么要删除的元素就被removeIndex之后的元素替换，从而也就完成了删除操作。接着看take()方法，是一个阻塞方法，直接获取队列头元素并删除。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列头部删除，队列没有元素就阻塞，可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lockInterruptibly();<span class="comment">//中断</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//如果队列没有元素</span></span><br><span class="line">          <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">              <span class="comment">//执行阻塞操作</span></span><br><span class="line">              notEmpty.await();</span><br><span class="line">          <span class="keyword">return</span> dequeue();<span class="comment">//如果队列有元素执行删除操作</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">peek方法非常简单，直接返回当前队列的头元素但不删除任何元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//直接返回当前队列的头元素，但不删除</span></span><br><span class="line">          <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (E) items[i];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>是一个由链表实现的有界队列阻塞队列，但大小默认值为Integer.MAX_VALUE，如果存在添加速度大于删除速度时候，有可能会内存溢出，所以我们在使用LinkedBlockingQueue时建议手动传值，为其提供我们所需的大小，避免队列过大造成机器负载或者内存爆满等情况。(和前者最大的不同是他通过插入和弹出的分离锁方式来提高吞吐量，即添加和删除操作并不是互斥操作，可以同时进行）</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认大小为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建指定大小为capacity的阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">     last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建大小默认值为Integer.MAX_VALUE的阻塞队列并添加c中的元素到阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">     putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">             <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">             <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">             enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">             ++n;</span><br><span class="line">         &#125;</span><br><span class="line">         count.set(n);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         putLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从源码看，有三种方式可以构造LinkedBlockingQueue，通常情况下，我们建议创建指定大小的LinkedBlockingQueue阻塞队列。LinkedBlockingQueue队列也是按 FIFO（先进先出）排序元素。队列的头部是在队列中时间最长的元素，队列的尾部 是在队列中时间最短的元素，新元素插入到队列的尾部，而队列执行获取操作会获得位于队列头部的元素。在正常情况下，链接队列的吞吐量要高于基于数组的队列（ArrayBlockingQueue），因为其内部实现添加和删除操作使用的两个ReenterLock来控制并发执行，而ArrayBlockingQueue内部只是使用一个ReenterLock控制并发，因此LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue。注意LinkedBlockingQueue和ArrayBlockingQueue的API几乎是一样的，但它们的内部实现原理不太相同，这点稍后会分析。使用LinkedBlockingQueue，我们同样也能实现生产者消费者模式。只需把前面ArrayBlockingQueue案例中的阻塞队列对象换成LinkedBlockingQueue即可。这里限于篇幅就不贴重复代码了。接下来我们重点分析LinkedBlockingQueue的内部实现原理，最后我们将对ArrayBlockingQueue和LinkedBlockingQueue 做总结，阐明它们间的不同之处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点类，用于存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * One of:</span></span><br><span class="line"><span class="comment">         * - the real successor Node</span></span><br><span class="line"><span class="comment">         * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">         * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前阻塞队列中的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列的尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取并移除元素时使用的锁，如take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加元素时使用的锁如 put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述可看成，每个添加到LinkedBlockingQueue队列中的数据都将被封装成Node节点，添加的链表队列中，其中head和last分别指向队列的头结点和尾结点。与ArrayBlockingQueue不同的是，LinkedBlockingQueue内部分别使用了takeLock 和 putLock 对并发进行控制，也就是说，添加和删除操作并不是互斥操作，可以同时进行，这样也就可以大大提高吞吐量。这里再次强调如果没有给LinkedBlockingQueue指定容量大小，其默认值将是Integer.MAX_VALUE，如果存在添加速度大于删除速度时候，有可能会内存溢出，这点在使用前希望慎重考虑。至于LinkedBlockingQueue的实现原理图与ArrayBlockingQueue是类似的，除了对添加和移除方法使用单独的锁控制外，两者都使用了不同的Condition条件对象作为等待队列，用于挂起take线程和put线程。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><h5 id="add、offer、put-1"><a href="#add、offer、put-1" class="headerlink" title="add、offer、put"></a>add、offer、put</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">add方法间接调用的是offer方法，如果add方法添加失败将抛出IllegalStateException异常，添加成功则返回true</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (offer(e))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//添加元素为null直接抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">//获取队列的个数</span></span><br><span class="line">      <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">      <span class="comment">//判断队列是否已满</span></span><br><span class="line">      <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//构建节点</span></span><br><span class="line">      Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">      putLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//再次判断队列是否已满，考虑并发情况</span></span><br><span class="line">          <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">              enqueue(node);<span class="comment">//添加元素</span></span><br><span class="line">              c = count.getAndIncrement();<span class="comment">//拿到当前未添加新元素时的队列长度</span></span><br><span class="line">              <span class="comment">//如果容量还没满</span></span><br><span class="line">              <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                  notFull.signal();<span class="comment">//唤醒下一个添加线程，执行添加操作</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          putLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 由于存在添加锁和消费锁，而消费锁和添加锁都会持续唤醒等到线程，因此count肯定会变化。</span></span><br><span class="line">      <span class="comment">//这里的if条件表示如果队列中还有1条数据</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) </span><br><span class="line">        signalNotEmpty();<span class="comment">//如果还存在数据那么就唤醒消费锁</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>; <span class="comment">// 添加成功返回true，否则返回false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//队列尾节点指向新的node节点</span></span><br><span class="line">     last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signalNotEmpty方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">      takeLock.lock();</span><br><span class="line">          <span class="comment">//唤醒获取并删除元素的线程</span></span><br><span class="line">          notEmpty.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的Offer()方法做了两件事，第一件事是判断队列是否满，满了就直接释放锁，没满就将节点封装成Node入队，然后再次判断队列添加完成后是否已满，不满就继续唤醒等到在条件对象notFull上的添加线程。第二件事是，判断是否需要唤醒等到在notEmpty条件对象上的消费线程。这里我们可能会有点疑惑，为什么添加完成后是继续唤醒在条件对象notFull上的添加线程而不是像ArrayBlockingQueue那样直接唤醒notEmpty条件对象上的消费线程？而又为什么要当if (c == 0)时才去唤醒消费线程呢？</p><ul><li>唤醒添加线程的原因，在添加新元素完成后，会判断队列是否已满，不满就继续唤醒在条件对象notFull上的添加线程，这点与前面分析的ArrayBlockingQueue很不相同，在ArrayBlockingQueue内部完成添加操作后，会直接唤醒消费线程对元素进行获取，这是因为ArrayBlockingQueue只用了一个ReenterLock同时对添加线程和消费线程进行控制，这样如果在添加完成后再次唤醒添加线程的话，消费线程可能永远无法执行，而对于LinkedBlockingQueue来说就不一样了，其内部对添加线程和消费线程分别使用了各自的ReenterLock锁对并发进行控制，也就是说添加线程和消费线程是不会互斥的，所以添加锁只要管好自己的添加线程即可，添加线程自己直接唤醒自己的其他添加线程，如果没有等待的添加线程，直接结束了。如果有就直到队列元素已满才结束挂起，当然offer方法并不会挂起，而是直接结束，只有put方法才会当队列满时才执行挂起操作。注意消费线程的执行过程也是如此。这也是为什么LinkedBlockingQueue的吞吐量要相对大些的原因。</li><li>为什么要判断if (c == 0)时才去唤醒消费线程呢，这是因为消费线程一旦被唤醒是一直在消费的（前提是有数据），所以c值是一直在变化的，c值是添加完元素前队列的大小，此时c只可能是0或c&gt;0，如果是c=0，那么说明之前消费线程已停止，条件对象上可能存在等待的消费线程，添加完数据后应该是c+1，那么有数据就直接唤醒等待消费线程，如果没有就结束啦，等待下一次的消费操作。如果c&gt;0那么消费线程就不会被唤醒，只能等待下一个消费操作（poll、take、remove）的调用，那为什么不是条件c&gt;0才去唤醒呢？我们要明白的是消费线程一旦被唤醒会和添加线程一样，一直不断唤醒其他消费线程，如果添加前c&gt;0，那么很可能上一次调用的消费线程后，数据并没有被消费完，条件队列上也就不存在等待的消费线程了，所以c&gt;0唤醒消费线程得意义不是很大，当然如果添加线程一直添加元素，那么一直c&gt;0，消费线程执行的换就要等待下一次调用消费操作了（poll、take、remove）。</li></ul><h4 id="移除元素-1"><a href="#移除元素-1" class="headerlink" title="移除元素"></a>移除元素</h4><h5 id="remove、poll、take"><a href="#remove、poll、take" class="headerlink" title="remove、poll、take"></a>remove、poll、take</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">remove方法删除指定的对象，这里我们可能会诧异，为什么同时对putLock和takeLock加锁？这是因为remove方法删除的数据的位置不确定，为了避免造成并非安全问题，所以需要对2个锁同时加锁。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     fullyLock();<span class="comment">//同时对putLock和takeLock加锁</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//循环查找要删除的元素</span></span><br><span class="line">         <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">              p != <span class="keyword">null</span>;</span><br><span class="line">              trail = p, p = p.next) &#123;</span><br><span class="line">             <span class="keyword">if</span> (o.equals(p.item)) &#123;<span class="comment">//找到要删除的节点</span></span><br><span class="line">                 unlink(p, trail);<span class="comment">//直接删除</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         fullyUnlock();<span class="comment">//解锁</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个同时加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       putLock.lock();</span><br><span class="line">       takeLock.lock();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      takeLock.unlock();</span><br><span class="line">      putLock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">poll方法也比较简单，如果队列没有数据就返回null，如果队列有数据，那么就取出来，如果队列还有数据那么唤醒等待在条件对象notEmpty上的消费线程。然后判断if (c == capacity)为true就唤醒添加线程，这点与前面分析if(c==0)是一样的道理。因为只有可能队列满了，notFull条件对象上才可能存在等待的添加线程。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//获取当前队列的大小</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">if</span> (count.get() == <span class="number">0</span>)<span class="comment">//如果没有元素直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        E x = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断队列是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果有，直接删除并获取该元素值</span></span><br><span class="line">                x = dequeue();</span><br><span class="line">                <span class="comment">//当前队列大小减一</span></span><br><span class="line">                c = count.getAndDecrement();</span><br><span class="line">                <span class="comment">//如果队列未空，继续唤醒等待在条件对象notEmpty上的消费线程</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断c是否等于capacity，这是因为如果满说明NotFull条件对象上</span></span><br><span class="line">        <span class="comment">//可能存在等待的添加线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;<span class="comment">//获取头结点</span></span><br><span class="line">        Node&lt;E&gt; first = h.next; 获取头结的下一个节点（要删除的节点）</span><br><span class="line">        h.next = h; <span class="comment">// help GC//自己next指向自己，即被删除</span></span><br><span class="line">        head = first;<span class="comment">//更新头结点</span></span><br><span class="line">        E x = first.item;<span class="comment">//获取删除节点的值</span></span><br><span class="line">        first.item = <span class="keyword">null</span>;<span class="comment">//清空数据，因为first变成头结点是不能带数据的，这样也就删除队列的带数据的第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">take方法是一个可阻塞可中断的移除方法，主要做了两件事，一是，如果队列没有数据就挂起当前线程到 notEmpty条件对象的等待队列中一直等待，如果有数据就删除节点并返回数据项，同时唤醒后续消费线程，二是尝试唤醒条件对象notFull上等待队列中的添加线程。 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取当前队列大小</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();<span class="comment">//可中断</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果队列没有数据，挂机当前线程到条件对象的等待队列中</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果存在数据直接删除并返回该数据</span></span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();<span class="comment">//队列大小减1</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();<span class="comment">//还有数据就唤醒后续的消费线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//满足条件，唤醒条件对象上等待队列中的添加线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="peek、element"><a href="#peek、element" class="headerlink" title="peek、element"></a>peek、element</h6><p>到此关于remove、poll、take的实现也分析完了，其中只有take方法具备阻塞功能。remove方法则是成功返回true失败返回false，poll方法成功返回被移除的值，失败或没数据返回null。下面再看看两个检查方法，即peek和element</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，head 节点不存放数据</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">       last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E x = peek();<span class="comment">//直接调用peek</span></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();<span class="comment">//没数据抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取头结节点的下一个节点</span></span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//为null就返回null</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> first.item;<span class="comment">//返回值</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码来看，head头结节点在初始化时是本身不带数据的，仅仅作为头部head方便我们执行链表的相关操作。peek返回直接获取头结点的下一个节点返回其值，如果没有值就返回null，有值就返回节点对应的值。element方法内部调用的是peek，有数据就返回，没数据就抛异常。下面我们最后来看两个根据时间阻塞的方法，比较有意思，利用的Conditin来实现的。</p><p>offer(E e, long timeout, TimeUnit unit)方法内部正是利用这样的Codition的超时等待awaitNanos方法实现添加方法的超时阻塞操作。同样对于poll(long timeout, TimeUnit unit)方法也是一样的道理。</p><h3 id="LinkedBlockingQueue和ArrayBlockingQueue的异同"><a href="#LinkedBlockingQueue和ArrayBlockingQueue的异同" class="headerlink" title="LinkedBlockingQueue和ArrayBlockingQueue的异同"></a>LinkedBlockingQueue和ArrayBlockingQueue的异同</h3><p>1.队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</p><p>2.数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</p><p>3.由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。</p><p>4.两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://blog.csdn.net/javazejian/article/details/77410889?locationNum=1&amp;fps=1" target="_blank" rel="noopener">深入剖析java并发之阻塞队列LinkedBlockingQueue与ArrayBlockingQueue</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;阻塞队列概要&quot;&gt;&lt;a href=&quot;#阻塞队列概要&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列概
      
    
    </summary>
    
      <category term="多线程" scheme="http://www.fufan.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.fufan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程系列（八）——执行器Executor并发框架</title>
    <link href="http://www.fufan.me/2018/12/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E5%99%A8Executor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.fufan.me/2018/12/04/java多线程系列（八）——执行器Executor并发框架/</id>
    <published>2018-12-04T03:53:00.000Z</published>
    <updated>2018-12-05T03:54:22.143Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>线程池的架构图如下：<br><img src="/image/thread-8-0.jpg" alt=""></p><h3 id="1-Executor"><a href="#1-Executor" class="headerlink" title="1. Executor"></a>1. Executor</h3><p>它是”执行者”接口，它是来执行任务的。准确的说，Executor提供了execute()接口来执行已提交的 Runnable 任务的对象。Executor存在的目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。<br>它只包含一个函数接口：</p><h3 id="2-ExecutorService"><a href="#2-ExecutorService" class="headerlink" title="2. ExecutorService"></a>2. ExecutorService</h3><p>xecutorService继承于Executor。它是”执行者服务”接口，它是为”执行者接口Executor”服务而存在的；准确的话，ExecutorService提供了”将任务提交给执行者的接口(submit方法)”，”让执行者执行任务(invokeAll, invokeAny方法)”的接口等等。</p><h3 id="3-AbstractExecutorService"><a href="#3-AbstractExecutorService" class="headerlink" title="3. AbstractExecutorService"></a>3. AbstractExecutorService</h3><p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。<br>AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。其实基本上抽象方法的作用一般也就是为了提供默认的实现，不过我们在jdk1.8开始，可以使用接口的默认方法，即default关键字。</p><h3 id="4-ThreadPoolExecutor"><a href="#4-ThreadPoolExecutor" class="headerlink" title="4. ThreadPoolExecutor"></a>4. ThreadPoolExecutor</h3><p>ThreadPoolExecutor就是大名鼎鼎的”线程池”。它继承于AbstractExecutorService抽象类。</p><h4 id="构造方法的核心参数"><a href="#构造方法的核心参数" class="headerlink" title="构造方法的核心参数"></a>构造方法的核心参数</h4><ul><li>corePoolSize：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：<ul><li>如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li><li>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；</li><li>如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li><li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；</li></ul></li><li>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</li><li>maximumPoolSize：最大线程数量；</li><li>workQueue：等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</li><li>workQueue：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul><li>直接切换：这种方式常用的队列是SynchronousQueue，但现在还没有研究过该队列，这里暂时还没法介绍；</li><li>使用无界队列：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li><li>使用有界队列：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。<ul><li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li><li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量。</li><li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li></ul></li></ul></li><li>keepAliveTime：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</li><li>threadFactory：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</li><li>handler：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul><li>AbortPolicy：直接抛出异常，这是默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ul></li></ul><h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><p>execute()方法用来提交任务，代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * clt记录着runState和workerCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">     * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">        <span class="comment">// 这时需要移除该command</span></span><br><span class="line">        <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">         * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">     * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">     * 如果失败则拒绝该任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p><p>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；<br>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。<br>这里要注意一下addWorker(null, false);，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在workerCountOf(recheck) == 0时执行addWorker(null, false);也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p><p>execute方法执行流程如下：</p><p><img src="/image/thread-8-1.png" alt=""></p><h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个if判断</span></span><br><span class="line"><span class="comment">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">         * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">         * 2. firsTask为空</span></span><br><span class="line"><span class="comment">         * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">         * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意一下这里的t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p><h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果task为空，则通过getTask来获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里说明一下第一个if判断，目的是：</p><ul><li>如果线程池正在停止，那么要保证当前线程是中断状态；</li><li>如果不是的话，则要保证当前线程不是中断状态；</li></ul><p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p><pre><code>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</code></pre><p>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环不断地通过getTask()方法获取任务；</li><li>getTask()方法从阻塞队列中取任务；</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法；</li><li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li></ol><p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p><p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p><h5 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h5><p>getTask方法用来从阻塞队列中取任务，代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">         * 1. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">         * 2. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">         * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class="line"><span class="comment">             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</li><li>什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</li><li>getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</li></ul><h5 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。 </span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：</p><p><img src="/image/thread-8-2.png" alt=""></p><h5 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h5><p>tryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前线程池的状态为以下几种情况时，直接返回：</span></span><br><span class="line"><span class="comment">         * 1. RUNNING，因为还在运行中，不能停止；</span></span><br><span class="line"><span class="comment">         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；</span></span><br><span class="line"><span class="comment">         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果线程数量不为0，则中断一个空闲的工作线程，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// terminated方法默认什么都不做，留给子类实现</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interruptIdleWorkers(ONLY_ONE);的作用是因为在getTask方法中执行workQueue.take()时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用workQueue.take()时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。</p><h5 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h5><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 安全策略判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 切换状态为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？</p><p>下面仔细分析一下：</p><ul><li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li><li>shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；</li><li>在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用workQueue.take()进行阻塞；</li><li>如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了workQueue.take()后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；</li><li>由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；</li><li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用workQueue.take()时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；</li><li>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</li><li>所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。</li></ul><h5 id="interruptIdleWorkers方法"><a href="#interruptIdleWorkers方法" class="headerlink" title="interruptIdleWorkers方法"></a>interruptIdleWorkers方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nterruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。</p><p>为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。</p><h5 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shutdownNow方法与shutdown方法类似，不同的地方在于：</p><ul><li>设置状态为STOP；</li><li>中断所有工作线程，无论是否是空闲的；</li><li>取出阻塞队列中没有被执行的任务并返回。</li></ul><p>shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</p><h4 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h4><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li>getTaskCount：线程池已经执行的和未执行的任务总数；</li><li>getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li><li>getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li><li>getPoolSize：线程池当前的线程数量；</li><li>getActiveCount：当前线程池中正在执行任务的线程数量。</li></ul><p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p><h3 id="5-ScheduledExecutorService"><a href="#5-ScheduledExecutorService" class="headerlink" title="5. ScheduledExecutorService"></a>5. ScheduledExecutorService</h3><p>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。<br>ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p><h3 id="6-ScheduledThreadPoolExecutor"><a href="#6-ScheduledThreadPoolExecutor" class="headerlink" title="6. ScheduledThreadPoolExecutor"></a>6. ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ScheduledExecutorService。<br>ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p><h3 id="7-Executors"><a href="#7-Executors" class="headerlink" title="7. Executors"></a>7. Executors</h3><p>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p><p>这里要注意，虽然Executors可以用静态方法来创建很多方便的线程池，但是我们在实际工作中发现，因为如果使用像newFixedThreadPool这种方式创建的线程池，会因为队列无限大，导致无法控制而出现内存溢出的问题，所以，我们创建线程池最优雅的方式是通过继承ThreadPoolExecutor，并重写相应的方法来处理。</p><p><strong><em>talk is cheap, let me show the code:</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 任务处理线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">WorkerPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">int</span> maxSize, <span class="keyword">long</span> keepAlive, TimeUnit timeUnit, BlockingQueue&lt;Runnable&gt; queue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(coreSize, maxSize, keepAlive, timeUnit, queue, threadFactory);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable runnable, Throwable throwable)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.afterExecute(runnable, throwable);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是我在项目中用到的手动构建线程池的简单示例，通过这种方式可以调用对应的构造方法，来构建你需要的线程池，包括参数的配置和策略的更换，只要你理解他是如何运行的，就可以轻松驾驭线程池，并发处理业务代码。</p><h2 id="博文参考"><a href="#博文参考" class="headerlink" title="博文参考"></a>博文参考</h2><p><a href="https://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">Java多线程系列目录(共43篇)</a></p><p><a href="https://www.cnblogs.com/liuzhihu/p/8177371.html" target="_blank" rel="noopener">深入理解Java线程池：ThreadPoolExecutor</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;线程池的架构图如下：&lt;br&gt;&lt;img src=&quot;/image/thread-8-0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;h3 
      
    
    </summary>
    
      <category term="多线程" scheme="http://www.fufan.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.fufan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python分布式爬虫利器——Scrapy+Scrapy-redis+Scrapyd+ScrapyWeb</title>
    <link href="http://www.fufan.me/2018/12/03/python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8%E2%80%94%E2%80%94Scrapy-Scrapy-redis-Scrapyd-ScrapyWeb/"/>
    <id>http://www.fufan.me/2018/12/03/python分布式爬虫利器——Scrapy-Scrapy-redis-Scrapyd-ScrapyWeb/</id>
    <published>2018-12-03T09:28:08.000Z</published>
    <updated>2018-12-03T09:54:18.295Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>由于最近公司海外项目需要接一个泰国二手车平台的报价信息的客户需求，公网爬虫的话用python来做是最方便的，因此技术选型用Scrapy+Scrapy-redis+Scrapyd+Gerapy。</p><p>优势如下：</p><pre><code>* 简单、易维护* 分布式爬虫，更快（由于海外代理少且贵）* scrapy文档内容丰富* 等等。。</code></pre><ol><li><p>Scrapy：是一个基于Twisted的异步IO框架，有了这个框架，我们就不需要等待当前URL抓取完毕之后在进行下一个URL的抓取，抓取效率可以提高很多。</p></li><li><p>Scrapy-redis：虽然Scrapy框架是异步加多线程的，但是我们只能在一台主机上运行，爬取效率还是有限的，Scrapy-redis库为我们提供了Scrapy分布式的队列，调度器，去重等等功能，有了它，我们就可以将多台主机组合起来，共同完成一个爬取任务，抓取的效率又提高了。</p></li><li><p>Scrapyd：分布式爬虫完成之后，接下来就是代码部署，如果我们有很多主机，那就要逐个登录服务器进行部署，万一代码有所改动……….可以想象，这个过程是多么繁琐。Scrapyd是专门用来进行分布式部署的工具，它提供HTTP接口来帮助我们部署，启动，停止，删除爬虫程序，利用它我们可以很方便的完成Scrapy爬虫项目的部署。</p></li><li><p>ScrapyWeb：是一个基于Scrapyd，Scrapyd API，Django，nodejs搭建的分布式爬虫管理框架。简单点说，就是用上述的Scrapyd工具是在命令行进行操作，而Gerapy将命令行和图形界面进行了对接，我们只需要点击按钮就可完成部署，启动，停止，删除的操作。并且支持节点管理、爬虫监控，邮件发送等功能。</p></li></ol><h3 id="1-创建Scrapy项目"><a href="#1-创建Scrapy项目" class="headerlink" title="1. 创建Scrapy项目"></a>1. 创建Scrapy项目</h3><h3 id="2-添加Scrapy-redis配置"><a href="#2-添加Scrapy-redis配置" class="headerlink" title="2. 添加Scrapy-redis配置"></a>2. 添加Scrapy-redis配置</h3><h3 id="3-安装Scrapyd"><a href="#3-安装Scrapyd" class="headerlink" title="3. 安装Scrapyd"></a>3. 安装Scrapyd</h3><h3 id="4-强大的界面分布式管理scrapy进程——ScrapyWeb"><a href="#4-强大的界面分布式管理scrapy进程——ScrapyWeb" class="headerlink" title="4. 强大的界面分布式管理scrapy进程——ScrapyWeb"></a>4. 强大的界面分布式管理scrapy进程——ScrapyWeb</h3><h2 id="待续……"><a href="#待续……" class="headerlink" title="待续……"></a>待续……</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;由于最近公司海外项目需要接一个泰国二手车平台的报价信息的客户需求，公网爬虫的话用python来做是最方便的，因此技术选型用S
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学会写脚本系列（二）—— Python之dict(或对象)与json之间的互相转化</title>
    <link href="http://www.fufan.me/2018/11/22/%E5%AD%A6%E4%BC%9A%E5%86%99%E8%84%9A%E6%9C%AC%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-Python%E4%B9%8Bdict-%E6%88%96%E5%AF%B9%E8%B1%A1-%E4%B8%8Ejson%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96/"/>
    <id>http://www.fufan.me/2018/11/22/学会写脚本系列（二）——-Python之dict-或对象-与json之间的互相转化/</id>
    <published>2018-11-22T09:52:00.000Z</published>
    <updated>2018-11-22T09:52:30.480Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。</p><p>在Python中自带json库。通过import json导入。</p><p>在json模块有2个方法，</p><ul><li>loads()：将json数据转化成dict数据</li><li>dumps()：将dict数据转化成json数据</li><li>load()：读取json文件数据，转成dict数据</li><li>dump()：将dict数据转化成json数据后写入json文件</li></ul><p>示例如下：</p><h3 id="1-dict字典转json数据"><a href="#1-dict字典转json数据" class="headerlink" title="1. dict字典转json数据"></a>1. dict字典转json数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dict_to_json():</span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    dict[&apos;name&apos;] = &apos;fufan&apos;</span><br><span class="line">    dict[&apos;age&apos;] = 25</span><br><span class="line">    dict[&apos;sex&apos;] = &apos;male&apos;</span><br><span class="line">    print(dict)  # 输出：&#123;&apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 25, &apos;sex&apos;: &apos;male&apos;&#125;</span><br><span class="line">    j = json.dumps(dict)</span><br><span class="line">    print(j)  # 输出：&#123;&quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 25, &quot;sex&quot;: &quot;male&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    dict_to_json()</span><br></pre></td></tr></table></figure><h3 id="2-对象转json数据"><a href="#2-对象转json数据" class="headerlink" title="2. 对象转json数据"></a>2. 对象转json数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    id = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    gender = &apos;&apos;</span><br><span class="line">    phone = &apos;&apos;</span><br><span class="line">    email = &apos;&apos;</span><br><span class="line">    def __init__(self, id, name, age, gender, phone, email):</span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.phone = phone</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def obj_to_json():</span><br><span class="line">    stu = Student(&apos;fufan&apos;, &apos;fufan&apos;, 28, &apos;male&apos;, &apos;13000000000&apos;, &apos;fufan@51dojo.com&apos;)</span><br><span class="line">    print(type(stu))  # &lt;class &apos;json_test.student.Student&apos;&gt;</span><br><span class="line">    stu = stu.__dict__  # 将对象转成dict字典</span><br><span class="line">    print(type(stu))  # &lt;class &apos;dict&apos;&gt;</span><br><span class="line">    print(stu)  # &#123;&apos;id&apos;: &apos;fufan&apos;, &apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 28, &apos;gender&apos;: &apos;male&apos;, &apos;phone&apos;: &apos;13000000000&apos;, &apos;email&apos;: &apos;fufan@51dojo.com&apos;&#125;</span><br><span class="line">    j = json.dumps(obj=stu)</span><br><span class="line">    print(j)  # &#123;&quot;id&quot;: &quot;fufan&quot;, &quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 28, &quot;gender&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;fufan@51dojo.com&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    obj_to_json()</span><br></pre></td></tr></table></figure><h3 id="3-json数据转成dict字典"><a href="#3-json数据转成dict字典" class="headerlink" title="3. json数据转成dict字典"></a>3. json数据转成dict字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">def json_to_dict():</span><br><span class="line">    j = &apos;&#123;&quot;id&quot;: &quot;fufan&quot;, &quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 28, &quot;gender&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;fufan@51dojo.com&quot;&#125;&apos;</span><br><span class="line">    dict = json.loads(s=j)</span><br><span class="line">    print(dict)  # &#123;&apos;id&apos;: &apos;fufan&apos;, &apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 28, &apos;gender&apos;: &apos;male&apos;, &apos;phone&apos;: &apos;13000000000&apos;, &apos;email&apos;: &apos;fufan@51dojo.com&apos;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    json_to_dict()</span><br></pre></td></tr></table></figure><h3 id="4-json数据转成对象"><a href="#4-json数据转成对象" class="headerlink" title="4. json数据转成对象"></a>4. json数据转成对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    id = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    gender = &apos;&apos;</span><br><span class="line">    phone = &apos;&apos;</span><br><span class="line">    email = &apos;&apos;</span><br><span class="line"></span><br><span class="line">def json_to_obj():</span><br><span class="line">    j = &apos;&#123;&quot;id&quot;: &quot;fufan&quot;, &quot;name&quot;: &quot;fufan&quot;, &quot;age&quot;: 28, &quot;gender&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;fufan@51dojo.com&quot;&#125;&apos;</span><br><span class="line">    dict = json.loads(s=j)</span><br><span class="line">    stu = Student()</span><br><span class="line">    stu.__dict__ = dict</span><br><span class="line">    print(&apos;id: &apos; + stu.id + &apos; name: &apos; + stu.name + &apos; age: &apos; + str(stu.age) + &apos; gender: &apos; + str(</span><br><span class="line">        stu.gender) + &apos; phone: &apos; + stu.phone + &apos; email: &apos; + stu.email)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    json_to_obj()</span><br></pre></td></tr></table></figure><h3 id="5-dump-方法的使用"><a href="#5-dump-方法的使用" class="headerlink" title="5. dump()方法的使用"></a>5. dump()方法的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">def dict_to_json_write_file():</span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    dict[&apos;name&apos;] = &apos;fufan&apos;</span><br><span class="line">    dict[&apos;age&apos;] = 26</span><br><span class="line">    dict[&apos;gender&apos;] = &apos;male&apos;</span><br><span class="line">    print(dict)  # &#123;&apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 26, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line">    with open(&apos;test.json&apos;, &apos;w&apos;) as f:</span><br><span class="line">        json.dump(dict, f)  # 会在目录下生成一个test.json的文件，文件内容是dict数据转成的json数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    dict_to_json_write_file()</span><br></pre></td></tr></table></figure><h3 id="6-load-的使用"><a href="#6-load-的使用" class="headerlink" title="6. load()的使用"></a>6. load()的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">def json_file_to_dict():</span><br><span class="line">    with open(&apos;test.json&apos;, &apos;r&apos;) as f:</span><br><span class="line">        dict = json.load(fp=f)</span><br><span class="line">        print(dict)  # &#123;&apos;name&apos;: &apos;fufan&apos;, &apos;age&apos;: 26, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    json_file_to_dict()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。&lt;/p&gt;&lt;p&gt;在Python中自带js
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring获取bean的几种方式</title>
    <link href="http://www.fufan.me/2018/11/21/Spring%E8%8E%B7%E5%8F%96bean%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.fufan.me/2018/11/21/Spring获取bean的几种方式/</id>
    <published>2018-11-21T07:08:42.000Z</published>
    <updated>2018-11-21T07:09:22.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>Spring获取bean的几种方式</p><ol><li>在初始化时保存ApplicationContext对象</li><li>通过Spring提供的utils类获取ApplicationContext对象</li><li>继承自抽象类ApplicationObjectSupport</li><li>继承自抽象类WebApplicationObjectSupport</li><li>实现接口ApplicationContextAware （推荐）</li><li>通过Spring提供的ContextLoader</li></ol><h4 id="在初始化时保存ApplicationContext对象"><a href="#在初始化时保存ApplicationContext对象" class="headerlink" title="在初始化时保存ApplicationContext对象"></a>在初始化时保存ApplicationContext对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;applicationContext.xml&quot;); </span><br><span class="line">ac.getBean(&quot;userService&quot;);//比如：&lt;bean id=&quot;userService&quot; class=&quot;com.cloud.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>这样的方式适用于採用Spring框架的独立应用程序，须要程序通过配置文件手工初始化Spring的情况。</p><h4 id="通过Spring提供的工具类获取ApplicationContext对象"><a href="#通过Spring提供的工具类获取ApplicationContext对象" class="headerlink" title="通过Spring提供的工具类获取ApplicationContext对象"></a>通过Spring提供的工具类获取ApplicationContext对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac1 = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc); </span><br><span class="line">ApplicationContext ac2 = WebApplicationContextUtils.getWebApplicationContext(ServletContext sc); </span><br><span class="line">ac1.getBean(&quot;beanId&quot;); </span><br><span class="line">ac2.getBean(&quot;beanId&quot;);</span><br></pre></td></tr></table></figure><p>这样的方式适合于採用Spring框架的B/S系统，通过ServletContext对象获取ApplicationContext对象。然后在通过它获取须要的类实例。上面两个工具方式的差别是，前者在获取失败时抛出异常。后者返回null。</p><h4 id="继承自抽象类ApplicationObjectSupport"><a href="#继承自抽象类ApplicationObjectSupport" class="headerlink" title="继承自抽象类ApplicationObjectSupport"></a>继承自抽象类ApplicationObjectSupport</h4><p>抽象类ApplicationObjectSupport提供getApplicationContext()方法。能够方便的获取ApplicationContext。</p><p>Spring初始化时。会通过该抽象类的setApplicationContext(ApplicationContext context)方法将ApplicationContext 对象注入。</p><h4 id="继承自抽象类WebApplicationObjectSupport"><a href="#继承自抽象类WebApplicationObjectSupport" class="headerlink" title="继承自抽象类WebApplicationObjectSupport"></a>继承自抽象类WebApplicationObjectSupport</h4><p>类似上面方法。调用getWebApplicationContext()获取WebApplicationContext</p><h4 id="实现接口ApplicationContextAware"><a href="#实现接口ApplicationContextAware" class="headerlink" title="实现接口ApplicationContextAware"></a>实现接口ApplicationContextAware</h4><p>实现该接口的setApplicationContext(ApplicationContext context)方法，并保存ApplicationContext 对象。Spring初始化时，会通过该方法将ApplicationContext对象注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ApplicationContextProvider implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上下文对象实例</span><br><span class="line">     */</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过name获取 Bean.</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过class获取Bean.</span><br><span class="line">     * @param clazz</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过name,以及Clazz返回指定的Bean</span><br><span class="line">     * @param name</span><br><span class="line">     * @param clazz</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法在工作中用的比较多，也是比较好的一种方法</p><h4 id="通过Spring提供的ContextLoader"><a href="#通过Spring提供的ContextLoader" class="headerlink" title="通过Spring提供的ContextLoader"></a>通过Spring提供的ContextLoader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext wac = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">wac.getBean(beanID);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;Spring获取bean的几种方式&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在初始化时保存ApplicationContext对象&lt;/li&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学会写脚本系列（一）—— Python Requests包的使用</title>
    <link href="http://www.fufan.me/2018/11/19/%E5%AD%A6%E4%BC%9A%E5%86%99%E8%84%9A%E6%9C%AC%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-Python-Requests%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.fufan.me/2018/11/19/学会写脚本系列（一）——-Python-Requests包的使用/</id>
    <published>2018-11-19T09:39:00.000Z</published>
    <updated>2018-11-22T09:40:11.818Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>由于公司的需求，平时需要测试一些公网爬虫，不过java在写小demo的时候太重的，所以必须要学点python、js、shell等语言来写一些脚本。所以平时抽空需要准备一些工具脚本，来支持临时测试。</p><p>今天我介绍用python来做批量跑http请求的脚本，刚好搜到了requests这个包，感觉用起来还挺方便的，具体的文档的话可以参考<a href="http://docs.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">中文官方文档</a>和<a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">英文官方文档</a></p><p>requests是python的一个HTTP客户端库，跟urllib，urllib2类似，那为什么要用requests而不用urllib2呢？官方文档中是这样说明的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python的标准库urllib2提供了大部分需要的HTTP功能，但是API太逆天了，一个简单的功能就需要一大堆代码。</span><br></pre></td></tr></table></figure><p>官方网站设计的原则如下：</p><ul><li>Beautiful is better than ugly.(美丽优于丑陋)</li><li>Explicit is better than implicit.(清楚优于含糊)</li><li>Simple is better than complex.(简单优于复杂)</li><li>Complex is better than complicated.(复杂优于繁琐)</li><li>Readability counts.(重要的是可读性)</li></ul><h3 id="1-安装Request"><a href="#1-安装Request" class="headerlink" title="1. 安装Request"></a>1. 安装Request</h3><ul><li>pip安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></li></ul><ul><li>源码安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone     git://github.com/kennethreitz/requests.git</span><br><span class="line">$ cd requests</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure></li></ul><ul><li>pycharm安装</li></ul><h3 id="2-快速上手"><a href="#2-快速上手" class="headerlink" title="2. 快速上手"></a>2. 快速上手</h3><p>既然官网的文档写的那么详细了，我这里就直接上例子了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def do_http_test():</span><br><span class="line"></span><br><span class="line"># 请求url</span><br><span class="line">    url = &apos;https://s.weibo.com/ajax_User/follow&apos;</span><br><span class="line">    # header头，Cookie可以放在这里</span><br><span class="line">    headers = &#123;&apos;content-type&apos;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">               &apos;Referer&apos;: &apos;https://s.weibo.com/user?q=%E6%B8%B8%E6%88%8F&apos;,</span><br><span class="line">               &apos;Cookie&apos;: &apos;SUB=_2A2528mffDeRhGeBJ4lUR9S3EyzyIHXVVht4XrDV8PUNbmtBeLUfekW9NRjmhG0VwLiyjpeOPdOk01GeypRYWWaEf&apos;&#125;</span><br><span class="line"></span><br><span class="line">    # post请求的请求data</span><br><span class="line">    payload = &#123;&apos;uid&apos;: &apos;5126161537&apos;, &apos;type&apos;: &apos;followed&apos;, &apos;action_code&apos;: &apos;71&apos;&#125;</span><br><span class="line"></span><br><span class="line">    # 具体调用的.post方法</span><br><span class="line">    r = requests.post(url, data = payload, headers = headers)</span><br><span class="line"></span><br><span class="line">    # 打印结果</span><br><span class="line">    print(r.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    do_http_test()</span><br></pre></td></tr></table></figure><h3 id="3-高级用法"><a href="#3-高级用法" class="headerlink" title="3. 高级用法"></a>3. 高级用法</h3><p>未完待续……</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;由于公司的需求，平时需要测试一些公网爬虫，不过java在写小demo的时候太重的，所以必须要学点python、js、shel
      
    
    </summary>
    
      <category term="python" scheme="http://www.fufan.me/categories/python/"/>
    
    
      <category term="python" scheme="http://www.fufan.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>聚簇索引和非聚簇索引</title>
    <link href="http://www.fufan.me/2018/11/16/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.fufan.me/2018/11/16/聚簇索引和非聚簇索引/</id>
    <published>2018-11-16T09:37:00.000Z</published>
    <updated>2018-11-16T09:37:40.595Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>1、大多数表都应该有聚簇索引或使用分区来降低对表尾页的竞争，在一个高事务的环境中，对最后一页的封锁严重影响系统的吞吐量。<br>2、在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查 (between、&lt;、&lt;=、&gt;、&gt;=)或使用group by或orderby的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大 大提高查询速度。<br>3、在一个频繁发生插入操作的表上建立聚簇索引时，不要建在具有单调上升值的列(如IDENTITY)上，否则会经常引起封锁冲突。<br>4、在聚簇索引中不要包含经常修改的列，因为码值修改后，数据行必须移动到新的位置。<br>5、选择聚簇索引应基于where子句和连接操作的类型。</p><p>不知从什么角度来对比，只能说说各自的特点，希望对你有用。</p><h4 id="1、聚簇索引"><a href="#1、聚簇索引" class="headerlink" title="1、聚簇索引"></a>1、聚簇索引</h4><p>a) 一个索引项直接对应实际数据记录的存储页，可谓“直达”<br>b) 主键缺省使用它<br>c) 索引项的排序和数据行的存储排序完全一致，利用这一点，想修改数据的存储顺序，可以通过改变主键的方法（撤销原有主键，另找也能满足主键要求的一个字段或一组字段，重建主键）<br>d) 一个表只能有一个聚簇索引（理由：数据一旦存储，顺序只能有一种）</p><h4 id="2、非聚簇索引"><a href="#2、非聚簇索引" class="headerlink" title="2、非聚簇索引"></a>2、非聚簇索引</h4><p>a) 不能“直达”，可能链式地访问多级页表后，才能定位到数据页<br>b) 一个表可以有多个非聚簇索引</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;1、大多数表都应该有聚簇索引或使用分区来降低对表尾页的竞争，在一个高事务的环境中，对最后一页的封锁严重影响系统的吞吐量。&lt;b
      
    
    </summary>
    
      <category term="数据库" scheme="http://www.fufan.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://www.fufan.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>从session到token</title>
    <link href="http://www.fufan.me/2018/11/14/%E4%BB%8Esession%E5%88%B0token/"/>
    <id>http://www.fufan.me/2018/11/14/从session到token/</id>
    <published>2018-11-14T06:15:00.000Z</published>
    <updated>2018-11-14T07:34:31.747Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h3 id="很久以前"><a href="#很久以前" class="headerlink" title="很久以前"></a>很久以前</h3><p>30年前，互联网刚起步的时候，大部分的web请求基本都是在浏览网页，既然是浏览，作为一个服务器， 为什么要记住谁在一段时间里都浏览了什么文档呢？</p><h3 id="开始记录session"><a href="#开始记录session" class="headerlink" title="开始记录session"></a>开始记录session</h3><p>但是好日子没持续多久， 很快大家就不满足于静态的Html 文档了， 交互式的Web应用开始兴起， 尤其是论坛， 在线购物等网站。那么必须记住哪些人登录系统， 哪些人往自己的购物车中放了商品， 也就是说必须把每个人区分开。</p><p>由于HTTP协议的无状态特性， 我必须加点小手段，才能完成会话管理。</p><p>所以在这个时候，服务器端一般会使用sessionId（会话标识）来标识该用户在一段时间内的请求，其实就是一个随机的字符串。这样每次请求过来，服务器端需要区分谁是谁。</p><h3 id="沉重的负担"><a href="#沉重的负担" class="headerlink" title="沉重的负担"></a>沉重的负担</h3><p>由于互联网的飞速发展，web请求量剧增，导致服务器压力增大，同时开销也增大。比如每个人只需要保存自己的session id，而服务器需要保存所有人的session id 。</p><p>虽然可以通过分布式集群扩展服务能力，但是这里又会出现session分布的问题。比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？ 机器B可没有小F的 session id啊。</p><p>虽然session sticky、缓存可以在一定程度上解决该问题，但是都会存在单点故障、机器宕机的问题。导致可靠性降低，同时增大了服务器的架构复杂度，不便于后期的扩展和维护。</p><h3 id="时间换空间"><a href="#时间换空间" class="headerlink" title="时间换空间"></a>时间换空间</h3><p>同时，session的安全性也是一个隐患，不怀好意的人可以通过伪造sessionId来请求。</p><p>渐渐地，很多网站开始使用JWT、UUID的方式登录或者保存用户状态信息。</p><p><a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a>是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。</p><ul><li>优点是在分布式系统中，很好地解决了单点登录问题，很容易解决了session共享的问题。</li><li>缺点是无法作废已颁布的令牌/不易应对数据过期。</li></ul><p>这样的话，就无状态的用token来替代了session，用CPU的计算时间来替换session的存储空间</p><p>JWT 的实践其实还是挺简单。安全性也是得到了保证，后端只需要保存着密匙，其他数据可以保存在token，由前端携带，这样可以减低后端的内心消耗。<br>虽然token是加密的，但是携带的验证数据还是不要是敏感数据.</p><h3 id="思想的迁移"><a href="#思想的迁移" class="headerlink" title="思想的迁移"></a>思想的迁移</h3><p>目前公司爬虫业务也有类似的问题，我们每一个任务的taskId是通过生成一个UUID来绑定和溯源的，这样可以保证全局唯一性，是很好的对分布式系统任务分离的一个实践。UUID生成的规则:</p><p><img src="/image/session-token-0.png" alt=""></p><p>如图所示，这里第1位不可用，前41位表示时间，中间10位用来表示工作机器的id，后12位的序列号.<br>其中时间比较好理解，工作机器id则是机器标识，序列号是一个自增序列。有多少位表示在这一个单位时间内，此机器最多可以支持2^12个并发。在进入下一个时间单位后，序列号归0。</p><p>虽然这种模式再生产上单日百万量级的服务已经实践了一年多，微服务的切分也是达到了40-50个之多，但是会发现有一个问题，就是token里未带任何任务相关的信息，而随着我们的业务量的增长，遇到的单点故障及其他复杂问题也增加（特别是aliyun中redis中间件常常会出现闪断等问题，包括db、oss、ots等都会有类似的情况）。所以要完全解决这种方式的话，就必须要有主备环境，随时切换，以应对单点故障带来对服务的影响（毕竟是24*7的服务，出一次事故对客户带来损失巨大）。</p><p>而切换环境的瞬间，情况复杂度也是非常复杂的，因为你首先要保证之前的任务是正常在老环境里跑的，而新的任务也要按比例分流到新环境中来，但是需要让用户是无感知切换的话，入口是不能变的。所以我们就会考虑后端其他的微服务如何去将gateway中生成的taskId分配到哪个环境中。</p><p>因为环境完全是两套，假设我们分为C区任务和D区任务，而如果能够在taskId中添加一位来表示是哪个区的话，就可以路由到哪个环境中去正常的执行下去。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;很久以前&quot;&gt;&lt;a href=&quot;#很久以前&quot; class=&quot;headerlink&quot; title=&quot;很久以前&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="分布式" scheme="http://www.fufan.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="jwt" scheme="http://www.fufan.me/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>JVM专题（八）---强、软、弱、虚的知识点总结</title>
    <link href="http://www.fufan.me/2018/11/13/Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8-%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://www.fufan.me/2018/11/13/Java四种引用-强、软、弱、虚的知识点总结/</id>
    <published>2018-11-13T09:47:00.000Z</published>
    <updated>2018-11-14T03:27:48.331Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><p>本文会按照以下思路进行：<br><a href="#1">（1）Java的四种对象引用的基本概念</a><br><br><a href="#2">（2）四种对象引用的差异对比</a><br><br><a href="#3">（3）对象可及性的判断以及与垃圾回收机制的关系</a><br><br><a href="#4">（4）引用队列ReferenceQueue的介绍</a><br><br><a href="#5">（5）WeakHashMap的相关介绍</a><br></p><h3 id="1">Java的四种对象引用的基本概念</h3><p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><h4 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj =new Object();</span><br></pre></td></tr></table></figure><p>上述Object这类对象就具有强引用，属于不可回收的资源，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收具有强引用的对象，来解决内存不足的问题。</p><p>值得注意的是：如果想中断或者回收强引用对象，可以显式地将引用赋值为null，这样的话JVM就会在合适的时间，进行垃圾回收。</p><p>下图是堆区的内存示意图，分为新生代，老生代，而垃圾回收主要也是在这部分区域中进行。</p><p><img src="/image/java_reference-0.png" alt=""></p><h4 id="2、软引用（SoftReference）"><a href="#2、软引用（SoftReference）" class="headerlink" title="2、软引用（SoftReference）"></a>2、软引用（SoftReference）</h4><p>如果一个对象只具有软引用，那么它的性质属于可有可无的那种。如果此时内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p><p>软引用可用来实现内存敏感的告诉缓存。软引用可以和一个引用队列联合使用，如果软件用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">       ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">       SoftReference reference = new SoftReference(obj, queue);</span><br><span class="line">       //强引用对象滞空，保留软引用</span><br><span class="line">       obj = null;</span><br></pre></td></tr></table></figure><p>当内存不足时，软引用对象被回收时，reference.get()为null，此时软引用对象的作用已经发挥完毕，这时将其添加进ReferenceQueue 队列中</p><p>如果要判断哪些软引用对象已经被清理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SoftReference ref = null;</span><br><span class="line">        while ((ref = (SoftReference) queue.poll()) != null) &#123;</span><br><span class="line">            //清除软引用对象</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="3、弱引用-WeakReference"><a href="#3、弱引用-WeakReference" class="headerlink" title="3、弱引用(WeakReference)"></a>3、弱引用(WeakReference)</h4><p>如果一个对象具有弱引用，那其的性质也是可有可无的状态。</p><p>而弱引用和软引用的区别在于：弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间充足与否，都会回收它的内存。</p><p>同样的弱引用也可以和引用队列一起使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">        ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">        WeakReference reference = new WeakReference(obj, queue);</span><br><span class="line">        //强引用对象滞空，保留软引用</span><br><span class="line">        obj = null;</span><br></pre></td></tr></table></figure><h4 id="4、虚引用（PhantomReference）"><a href="#4、虚引用（PhantomReference）" class="headerlink" title="4、虚引用（PhantomReference）"></a>4、虚引用（PhantomReference）</h4><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p><p>注意：虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。</p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">        ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">        PhantomReference reference = new PhantomReference(obj, queue);</span><br><span class="line">        //强引用对象滞空，保留软引用</span><br><span class="line">        obj = null;</span><br></pre></td></tr></table></figure><p>引用总结</p><p>1.对于强引用，平时在编写代码时会经常使用。</p><p>2.而其他三种类型的引用，使用得最多就是软引用和弱引用，这两种既有相似之处又有区别，他们都来描述非必须对象。</p><p>3.被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p><p><img src="/image/java_reference-1.png" alt=""></p><h3 id="2">四种对象引用的差异对比</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</span><br></pre></td></tr></table></figure><p><img src="/image/java_reference-2.png" alt=""></p><p>最后总结成一张表格：</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td>软引用</td><td>在内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>在垃圾回收时</td><td>对象缓存</td><td>垃圾回收时终止</td></tr><tr><td>虚引用</td><td>Unkonwn</td><td>Unkonwn</td><td>Unkonwn</td></tr></tbody></table><h3 id="3">对象可及性的判断</h3><p>在很多的时候，一个对象并不是从根集直接引用的，而是一个对象被其他对象引用，甚至同时被几个对象所引用，从而构成一个以根集为顶的树形结构。</p><p><img src="/image/java_reference-3.png" alt=""></p><p>在这个树形的引用链中，箭头的方向代表了引用的方向，所指向的对象是被引用对象。由图可以看出，从根集到一个对象可以由很多条路径。</p><p>比如到达对象5的路径就有① -&gt; ⑤，③ -&gt;⑦两条路径。由此带来了一个问题，那就是某个对象的可及性如何判断：</p><p>（1）单条引用路径可及性判断：</p><p>在这条路径中，最弱的一个引用决定对象的可及性。</p><p>（2）多条引用路径可及性判断：</p><p>几条路径中，最强的一条的引用决定对象的可及性。</p><p>比如，我们假设图2中引用①和③为强引用，⑤为软引用，⑦为弱引用，对于对象5按照这两个判断原则，路径①-⑤取最弱的引用⑤，因此该路径对对象5的引用为软引用。同样，③-⑦为弱引用。在这两条路径之间取最强的引用，于是对象5是一个软可及对象。</p><p>另外两个重要的点：</p><p>**1. 强可达的对象一定不会被清理</p><ol start="2"><li>JVM保证抛出out of memory之前，清理所有的软引用对象**</li></ol><h3 id="4">引用队列ReferenceQueue的介绍</h3><p>引用队列配合Reference的子类等使用,当引用对象所指向的对象被垃圾回收后,该Reference则被追加到引用队列的末尾.</p><h3 id="5">WeakHashMap的相关介绍</h3><p>在Java集合中有一种特殊的Map类型即WeakHashMap,在这种Map中存放了键对象的弱引用,当一个键对象被垃圾回收器回收时,那么相应的值对象的引用会从Map中删除.</p><p>WeakHashMap能够节约储存空间,可用来缓存那些非必须存在的数据.</p><p>而WeakHashMap是主要通过expungeStaleEntries()这个方法来实现的,而WeakHashMap也内置了一个ReferenceQueue,来获取键对象的引用情况.</p><p>这个方法,相当于遍历ReferenceQueue然后,将已经被回收的键对象,对应的值对象滞空.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">        for (Object x; (x = queue.poll()) != null; ) &#123;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">                int i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">                Entry&lt;K,V&gt; p = prev;</span><br><span class="line">                while (p != null) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                    if (p == e) &#123;</span><br><span class="line">                        if (prev == e)</span><br><span class="line">                            table[i] = next;</span><br><span class="line">                        else</span><br><span class="line">                            prev.next = next;</span><br><span class="line">                        // Must not null out e.next;</span><br><span class="line">                        // stale entries may be in use by a HashIterator</span><br><span class="line">                        //通过滞空,来帮助垃圾回收</span><br><span class="line">                        e.value = null; </span><br><span class="line">                        size--;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而且需要注意的是:</p><p>expungeStaleEntries()并不是自动调用的,需要外部对WeakHashMap对象进行查询或者操作,才会进行自动释放的操作</p><p>来一张总结图:</p><p><img src="/image/java_reference-4.png" alt=""></p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://blog.csdn.net/l540675759/article/details/73733763" target="_blank" rel="noopener">Java四种引用—强、软、弱、虚的知识点总结</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文会按照以下思路进行：&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;（1）Java的四种对象引用的基本概念&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a
      
    
    </summary>
    
      <category term="jvm" scheme="http://www.fufan.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.fufan.me/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>QPS/TPS/并发量/系统吞吐量的概念</title>
    <link href="http://www.fufan.me/2018/11/11/QPS-TPS-%E5%B9%B6%E5%8F%91%E9%87%8F-%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.fufan.me/2018/11/11/QPS-TPS-并发量-系统吞吐量的概念/</id>
    <published>2018-11-11T07:52:32.000Z</published>
    <updated>2018-11-11T07:53:00.332Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h3 id="系统吞吐量的关键参数"><a href="#系统吞吐量的关键参数" class="headerlink" title="系统吞吐量的关键参数"></a>系统吞吐量的关键参数</h3><p>一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢。系统吞吐能力越低，反之越高。</p><ul><li><p>QPS: 每秒钟处理完请求的次数；注意这里是处理完。具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。</p></li><li><p>TPS：每秒钟处理完的事务次数，一般TPS是对整个系统来讲的。一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较多。</p></li><li><p>并发量：系统能同时处理的请求数</p></li><li><p>RT：响应时间，处理一次请求所需要的平均处理时间</p></li></ul><p>计算关系：</p><ul><li><p>QPS = 并发量 / 平均响应时间</p></li><li><p>并发量 = QPS * 平均响应时间</p></li></ul><p>一个典型的上班签到系统，早上8点上班。7点半到8点这30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每一个员上登录签到系统的时长为5分钟。能够用以下的方法计算：</p><p>QPS = 1000/(30<em>60) 事务/秒<br>平均响应时间为 = 5 </em>60 秒<br>并发数= QPS<em>平均响应时间 = 1000/(30 </em>60) <em>(5 </em>60)=166.7</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;系统吞吐量的关键参数&quot;&gt;&lt;a href=&quot;#系统吞吐量的关键参数&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>centos安装python3.6（亲测爬坑）</title>
    <link href="http://www.fufan.me/2018/11/03/centos%E5%AE%89%E8%A3%85python3-6%EF%BC%88%E4%BA%B2%E6%B5%8B%E7%88%AC%E5%9D%91%EF%BC%89/"/>
    <id>http://www.fufan.me/2018/11/03/centos安装python3-6（亲测爬坑）/</id>
    <published>2018-11-03T09:26:00.000Z</published>
    <updated>2018-12-03T09:27:35.374Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h4 id="1-安装可能用到的依赖"><a href="#1-安装可能用到的依赖" class="headerlink" title="1. 安装可能用到的依赖"></a>1. 安装可能用到的依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel zlib-devel</span><br></pre></td></tr></table></figure><h4 id="2-下载Python3-6-5源码"><a href="#2-下载Python3-6-5源码" class="headerlink" title="2. 下载Python3.6.5源码"></a>2. 下载Python3.6.5源码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br></pre></td></tr></table></figure><h4 id="3-解压到当前目录"><a href="#3-解压到当前目录" class="headerlink" title="3. 解压到当前目录"></a>3. 解压到当前目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzvf Python-3.6.5.tgz</span><br></pre></td></tr></table></figure><h4 id="4-进入解压后的目录"><a href="#4-进入解压后的目录" class="headerlink" title="4. 进入解压后的目录"></a>4. 进入解压后的目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Python-3.6.5</span><br></pre></td></tr></table></figure><h4 id="5-安装到-usr-local-python目录，不用事先创建python目录"><a href="#5-安装到-usr-local-python目录，不用事先创建python目录" class="headerlink" title="5. 安装到/usr/local/python目录，不用事先创建python目录"></a>5. 安装到/usr/local/python目录，不用事先创建python目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/python</span><br></pre></td></tr></table></figure><h4 id="6-编译"><a href="#6-编译" class="headerlink" title="6. 编译"></a>6. 编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure><h4 id="7-安装"><a href="#7-安装" class="headerlink" title="7. 安装"></a>7. 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make altinstall</span><br></pre></td></tr></table></figure><h4 id="8-进入-usr-bin目录"><a href="#8-进入-usr-bin目录" class="headerlink" title="8. 进入/usr/bin目录"></a>8. 进入/usr/bin目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/bin</span><br></pre></td></tr></table></figure><h4 id="9-重命名python2的快捷方式"><a href="#9-重命名python2的快捷方式" class="headerlink" title="9. 重命名python2的快捷方式"></a>9. 重命名python2的快捷方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mv python python.bak</span><br><span class="line">$ mv pip pip.bak</span><br></pre></td></tr></table></figure><h4 id="10-创建python3与pip3软连接"><a href="#10-创建python3与pip3软连接" class="headerlink" title="10. 创建python3与pip3软连接"></a>10. 创建python3与pip3软连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /usr/<span class="built_in">local</span>/python/bin/python3.6 /usr/bin/python</span><br><span class="line">$ ln -s /usr/<span class="built_in">local</span>/python/bin/pip3.6 /usr/bin/pip</span><br></pre></td></tr></table></figure><h4 id="10-修改环境变量"><a href="#10-修改环境变量" class="headerlink" title="10. 修改环境变量"></a>10. 修改环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bash_profile</span><br><span class="line"><span class="comment"># 然后在.bash_profile中添加一行 export PATH=$PATH:/usr/local/python/bin，保存</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h4 id="11-测试是否安装成功"><a href="#11-测试是否安装成功" class="headerlink" title="11. 测试是否安装成功"></a>11. 测试是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server83 ~]<span class="comment"># python -V</span></span><br><span class="line">Python 3.6.5</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server83 ~]<span class="comment"># pip -V</span></span><br><span class="line">pip 18.1 from /usr/<span class="built_in">local</span>/python/lib/python3.6/site-packages/pip (python 3.6)</span><br></pre></td></tr></table></figure><h4 id="12-修改yum的配置"><a href="#12-修改yum的配置" class="headerlink" title="12. 修改yum的配置"></a>12. 修改yum的配置</h4><p>由于通过此方法来安装会导致yum的执行命令有问题，需要修改yum的python版本配置</p><ul><li>问题出现原因：<br>yum包管理是使用python2.x写的，将python2.x升级到python3.1.3以后，由于python版本语法兼容性导致问题出现</li></ul><ul><li>解决办法：</li></ul><ol><li>修改yum配置文件，将python版本指向以前的旧版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/bin/yum</span><br><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改urlgrabber-ext-down文件，更改python版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /usr/libexec/urlgrabber-ext-down</span><br><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br></pre></td></tr></table></figure><h4 id="13-升级pip"><a href="#13-升级pip" class="headerlink" title="13. 升级pip"></a>13. 升级pip</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install --upgrade pip</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h4 id=&quot;1-安装可能用到的依赖&quot;&gt;&lt;a href=&quot;#1-安装可能用到的依赖&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="python" scheme="http://www.fufan.me/categories/python/"/>
    
    
      <category term="python" scheme="http://www.fufan.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Java常用集合源码分析之map遍历效率比较（六）</title>
    <link href="http://www.fufan.me/2018/06/19/Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bmap%E9%81%8D%E5%8E%86%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://www.fufan.me/2018/06/19/Java常用集合源码分析之map遍历效率比较（六）/</id>
    <published>2018-06-19T14:21:00.000Z</published>
    <updated>2018-11-11T14:21:41.799Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><h4 id="1-遍历key"><a href="#1-遍历key" class="headerlink" title="1. 遍历key"></a>1. 遍历key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-遍历value"><a href="#2-遍历value" class="headerlink" title="2. 遍历value"></a>2. 遍历value</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String value : map.values()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-遍历key-value"><a href="#3-遍历key-value" class="headerlink" title="3. 遍历key+value"></a>3. 遍历key+value</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;String, String&gt; entry: map.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">    key = entry.getKey();</span><br><span class="line"></span><br><span class="line">    value = entry.getValue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果你使用HashMap"><a href="#如果你使用HashMap" class="headerlink" title="如果你使用HashMap"></a>如果你使用HashMap</h3><ol><li>同时遍历key和value时，keySet与entrySet方法的性能差异取决于key的复杂度，总体来说还是推荐使用entrySet。换言之，取决于HashMap查找value的开销。entrySet一次性取出所有key和value的操作是有性能开销的，当这个损失小于HashMap查找value的开销时，entrySet的性能优势就会体现出来。例如上述对比测试中，当key是最简单的数值字符串时，keySet可能反而会更高效，耗时比entrySet少10%。总体来说还是推荐使用entrySet。因为当key很简单时，其性能或许会略低于keySet，但却是可控的；而随着key的复杂化，entrySet的优势将会明显体现出来。当然，我们可以根据实际情况进行选择</li><li>只遍历key时，keySet方法更为合适，因为entrySet将无用的value也给取出来了，浪费了性能和空间。在上述测试结果中，keySet比entrySet方法耗时少23%。</li><li>只遍历value时，使用vlaues方法是最佳选择，entrySet会略好于keySet方法。</li></ol><h3 id="如果你使用TreeMap"><a href="#如果你使用TreeMap" class="headerlink" title="如果你使用TreeMap"></a>如果你使用TreeMap</h3><ol><li>同时遍历key和value时，entrySet的性能远远高于keySet。这是由TreeMap的查询效率决定的，也就是说，TreeMap查找value的开销较大，明显高于entrySet一次性取出所有key和value的开销。因此，遍历TreeMap时强烈推荐使用entrySet方法。</li><li>只遍历key时，keySet方法更为合适，因为entrySet将无用的value也给取出来了，浪费了性能和空间。在上述测试结果中，keySet比entrySet方法耗时少24%。</li><li>只遍历value时，使用vlaues方法是最佳选择，entrySet也明显优于keySet方法。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Mar 09 2019 13:29:19 GMT+0800 (China Standard Time) --&gt;&lt;h3 id=&quot;遍历方式&quot;&gt;&lt;a href=&quot;#遍历方式&quot; class=&quot;headerlink&quot; title=&quot;遍历方式&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="集合" scheme="http://www.fufan.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
