<!-- build time:Tue Nov 13 2018 17:50:35 GMT+0800 (China Standard Time) --><!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="jvm,面试,"><link rel="alternate" href="/atom.xml" title="A Gemini Boy" type="application/atom+xml"><meta name="description" content="一. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。GC流程当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；首先会判断eden是否有内存空间，如果此时有内存空间，则直接将新对象保存在eden；但是如果此时eden的内存空间不足，那么会自动执行一个MinorGC操作，将eden的无用内存空间进行清理，清理之后"><meta name="keywords" content="jvm,面试"><meta property="og:type" content="article"><meta property="og:title" content="Java面试总结积累（基础篇）之JVM问题(二)"><meta property="og:url" content="http://www.fufan.me/2017/11/10/Java面试总结积累（基础篇）之JVM问题-二/index.html"><meta property="og:site_name" content="A Gemini Boy"><meta property="og:description" content="一. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。GC流程当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；首先会判断eden是否有内存空间，如果此时有内存空间，则直接将新对象保存在eden；但是如果此时eden的内存空间不足，那么会自动执行一个MinorGC操作，将eden的无用内存空间进行清理，清理之后"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://www.fufan.me/image/base-jvm-1.jpg"><meta property="og:image" content="http://www.fufan.me/image/base-jvm-1.jpg"><meta property="og:updated_time" content="2018-11-06T11:44:21.407Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java面试总结积累（基础篇）之JVM问题(二)"><meta name="twitter:description" content="一. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。GC流程当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；首先会判断eden是否有内存空间，如果此时有内存空间，则直接将新对象保存在eden；但是如果此时eden的内存空间不足，那么会自动执行一个MinorGC操作，将eden的无用内存空间进行清理，清理之后"><meta name="twitter:image" content="http://www.fufan.me/image/base-jvm-1.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.fufan.me/2017/11/10/Java面试总结积累（基础篇）之JVM问题-二/"><title>Java面试总结积累（基础篇）之JVM问题(二) | A Gemini Boy</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/fae88"><img style="position:absolute;top:0;left:0;border:0" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">A Gemini Boy</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">welcome to my site</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.fufan.me/2017/11/10/Java面试总结积累（基础篇）之JVM问题-二/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="fae88"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="A Gemini Boy"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java面试总结积累（基础篇）之JVM问题(二)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T10:41:00+08:00">2017-11-10 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/11/10/Java面试总结积累（基础篇）之JVM问题-二/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/10/Java面试总结积累（基础篇）之JVM问题-二/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4.7k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">17 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="一-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"><a href="#一-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。" class="headerlink" title="一. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"></a>一. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。</h3><h4 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h4><p><img src="/image/base-jvm-1.jpg" alt=""></p><ol><li>当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；</li><li>首先会判断eden是否有内存空间，如果此时有内存空间，则直接将新对象保存在eden；</li><li>但是如果此时eden的内存空间不足，那么会自动执行一个MinorGC操作，将eden的无用内存空间进行清理，清理之后会继续判断eden的内存空间是否充足？如果内存空间充足，则将新的对象直接在eden进行空间分配；</li><li>如果执行了MinorGC之后发现eden的内存依然不足，那么这个时候会进行survivor判断，如果survivor有剩余空间，则将eden的部分活跃对象保存在survivor，那么随后继续判断eden的内存空间是否充足，如果充足，则在eden进行新对象的空间分配；</li><li>如果此时survivor也已经没有内存空间了，则继续判断老年区，如果此时老年区空间充足，则将survivor中的活跃对象保存到老年代，而后survivor就会存现有空余空间，随后eden将活跃对象保存在survivor之中，而后在eden里为新对象开辟空间；</li><li>如果这个时候老年代也满了，那么这个时候将产生M ajor GC（FullGC），进行老年代的内存清理。</li><li>如果老年代执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”</li></ol><h4 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h4><ol><li>-Xmx3550m：设置JVM最大堆内存为3550M。</li><li>-Xms3550m：设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。</li><li>-Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</li><li>-XX:NewSize=1024m：设置年轻代初始值为1024M。</li><li>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。</li><li>-XX:PermSize=256m：设置持久代初始值为256M。</li><li>-XX:MaxPermSize=256m：设置持久代最大值为256M。</li><li>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</li><li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</li><li>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li></ol><p>疑问解答<br>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？<br>如下：</p><ul><li>高优先级：-XX:NewSize/-XX:MaxNewSize</li><li>中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?）</li><li>低优先级：-XX:NewRatio</li><li>推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。</li><li>-Xmn参数是在JDK 1.4 开始支持。</li></ul><h3 id="二-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#二-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="二. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>二. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h3><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现，它的运作过程如下：</p><p>1）初始标记</p><p>2）并发标记</p><p>3）重新标记</p><p>4）并发清除</p><p>初始标记、从新标记这两个步骤仍然需要“stop the world”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，熟读很快，并发标记阶段就是进行GC Roots Tracing，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长点，但远比并发标记的时间短。</p><p>CMS是一款优秀的收集器，主要优点：并发收集、低停顿。</p><p>缺点：</p><p>1）CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p><p>2）CMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致Full GC产生。</p><p>浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC中再清理。这些垃圾就是“浮动垃圾”。</p><p>3）CMS是一款“标记–清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1是一款面向服务端应用的垃圾收集器。</p><ul><li>1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>2、分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。</li><li>3、空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>4、可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，</li><li><p>5、G1运作步骤：</p><pre><code>1、初始标记；
2、并发标记；
3、最终标记；
4、筛选回收；
</code></pre><p>上面几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p></li></ul><h3 id="三-GC策略是如何的，有哪些"><a href="#三-GC策略是如何的，有哪些" class="headerlink" title="三. GC策略是如何的，有哪些"></a>三. GC策略是如何的，有哪些</h3><p><img src="/image/base-jvm-1.jpg" alt=""></p><h4 id="New-Generation的GC策略"><a href="#New-Generation的GC策略" class="headerlink" title="New Generation的GC策略"></a>New Generation的GC策略</h4><ol><li>Serial GC。采用单线程方式，用Copying算法。到这里我们再来说说为什么New Generation会再次被划分成Eden Space和S0、S1，相信聪明的你一定已经想到Copying算法所需要的额外内存空间了吧，S0和S1又称为From Space和To Space。具体细节自己好好想想。</li><li>Parallel Scavenge。将内存空间分段来使用多线程，也是用Copying算法。</li><li>ParNew。比Parallel Scavenge多做了与Old Generation使用CMS GC一起发生时的特殊处理。</li></ol><h4 id="Old-Generation的GC策略"><a href="#Old-Generation的GC策略" class="headerlink" title="Old Generation的GC策略"></a>Old Generation的GC策略</h4><ol><li>Serial GC。当然也是单线程方式，但是实现是将Mark-Sweep和Mark-Compact结合了下，做了点改进。</li><li>Parallel Mark-Sweep、Parallel Mark-Compact。同样也是把Old Generation空间进行划分成regions，只是粒度更细了。为什么用这两个算法，不用我赘述了吧。</li><li>CMS（Concurrent Mark-Sweep） GC。我承认这个GC我真的没怎么看懂，目的是为了实现并发，结果就造成具体实现太麻烦了。有兴趣的朋友去看书吧，文末我说了是哪本书。这里有个地方可以说一下，就是算法使用的还是Mark-Sweep，对于内存碎片的问题，CMS提供了一个内存碎片的整理功能，会在执行几次Full GC以后执行一次。</li></ol><h3 id="4-JVM的垃圾收集器"><a href="#4-JVM的垃圾收集器" class="headerlink" title="4. JVM的垃圾收集器"></a>4. JVM的垃圾收集器</h3><p>JVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。</p><p>默认情况下JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。</p><h4 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h4><p>-XX:+UseSerialGC：设置串行收集器。</p><h4 id="并行收集器（吞吐量优先）"><a href="#并行收集器（吞吐量优先）" class="headerlink" title="并行收集器（吞吐量优先）"></a>并行收集器（吞吐量优先）</h4><ol><li>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li><li>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</li></ol><h4 id="并发收集器（响应时间优先）"><a href="#并发收集器（响应时间优先）" class="headerlink" title="并发收集器（响应时间优先）"></a>并发收集器（响应时间优先）</h4><ol><li>XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li><li>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li><li>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li><li>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</li><li>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li></ol><h4 id="其它垃圾回收参数"><a href="#其它垃圾回收参数" class="headerlink" title="其它垃圾回收参数"></a>其它垃圾回收参数</h4><ol><li>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。</li><li>-XX:-DisableExplicitGC：不响应 System.gc() 代码。</li><li>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li><li>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</li></ol><h4 id="辅助信息参数设置"><a href="#辅助信息参数设置" class="headerlink" title="辅助信息参数设置"></a>辅助信息参数设置</h4><ol><li>-XX:-CITime：打印消耗在JIT编译的时间。</li><li>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。</li><li>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。</li><li>-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。</li><li>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。</li><li>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。</li><li>-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li><li>-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li><li>-XX:-PrintCompilation：当一个方法被编译时打印相关信息。</li><li>-XX:-PrintGC：每次GC时打印相关信息。</li><li>-XX:-PrintGCDetails：每次GC时打印详细信息。</li><li>-XX:-PrintGCTimeStamps：打印每次GC的时间戳。</li><li>-XX:-TraceClassLoading：跟踪类的加载信息。</li><li>-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。</li><li>-XX:-TraceClassResolution：跟踪常量池。</li><li>-XX:-TraceClassUnloading：跟踪类的卸载信息。</li></ol><h4 id="调优实战"><a href="#调优实战" class="headerlink" title="调优实战"></a>调优实战</h4><h5 id="1-大型网站服务器案例"><a href="#1-大型网站服务器案例" class="headerlink" title="1. 大型网站服务器案例"></a>1. 大型网站服务器案例</h5><p>承受海量访问的动态Web应用<br>服务器配置：8 CPU, 8G MEM, JDK 1.6.X</p><ol><li><p>参数方案：<br>-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC</p></li><li><p>调优说明：</p></li></ol><ul><li>-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。</li><li>-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。</li><li>-Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。</li><li>-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。</li><li>-XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。</li><li>-XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。</li><li>-XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。</li></ul><h5 id="内部集成构建服务器案例"><a href="#内部集成构建服务器案例" class="headerlink" title="内部集成构建服务器案例"></a>内部集成构建服务器案例</h5><p>高性能数据处理的工具应用<br>服务器配置：1 CPU, 4G MEM, JDK 1.6.X</p><ol><li>参数方案：<br>-server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m</li><li>调优说明：</li></ol><ul><li>-XX:PermSize=196m -XX:MaxPermSize=196m 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。</li><li>-Xmn320m 遵循年轻代大小为整个堆的3/8原则。</li><li>-Xms768m -Xmx1024m 根据系统大致能够承受的堆内存大小设置即可。</li></ul><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/marcotan/p/4256885.html" target="_blank" rel="noopener">jvm参数设置大全</a></p><p><a href="https://blog.csdn.net/linhu007/article/details/48897597" target="_blank" rel="noopener">浅谈CMS垃圾收集器与G1收集器</a></p><p><a href="https://blog.csdn.net/u014421556/article/details/52396706" target="_blank" rel="noopener">JVM的GC策略</a></p><p><a href="https://www.cnblogs.com/yang-hao/p/5939487.html" target="_blank" rel="noopener">java jvm内存管理/gc策略/参数设置</a></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpayimg.png" alt="fae88 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipayimg.png" alt="fae88 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> fae88</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://www.fufan.me/2017/11/10/Java面试总结积累（基础篇）之JVM问题-二/" title="Java面试总结积累（基础篇）之JVM问题(二)">http://www.fufan.me/2017/11/10/Java面试总结积累（基础篇）之JVM问题-二/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/jvm/" rel="tag"><i class="fa fa-tag"></i> jvm</a> <a href="/tags/面试/" rel="tag"><i class="fa fa-tag"></i> 面试</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/11/06/Java面试总结积累（基础篇）之JVM问题-一/" rel="next" title="Java面试总结积累（基础篇）之JVM问题(一)"><i class="fa fa-chevron-left"></i> Java面试总结积累（基础篇）之JVM问题(一)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/11/13/Java面试总结积累（基础篇）之JVM问题-三/" rel="prev" title="Java面试总结积累（基础篇）之JVM问题(三)">Java面试总结积累（基础篇）之JVM问题(三) <i class="fa fa-chevron-right"></i></a></div></div></footer></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">fae88</p><p class="site-description motion-element" itemprop="description">fae88的生活工作，兴趣，爱好记录</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">47</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">19</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/fae88" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.im/user/57c2e5c3128fe1005fcc8ca9" target="_blank" title="JueJin"><i class="fa fa-fw fa-juejin"></i>JueJin</a> </span><span class="links-of-author-item"><a href="https://twitter.com/f654282262" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"><span class="nav-number">1.</span> <span class="nav-text">一. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC流程"><span class="nav-number">1.1.</span> <span class="nav-text">GC流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jvm参数"><span class="nav-number">1.2.</span> <span class="nav-text">jvm参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><span class="nav-number">2.</span> <span class="nav-text">二. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS收集器"><span class="nav-number">2.1.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1收集器"><span class="nav-number">2.2.</span> <span class="nav-text">G1收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-GC策略是如何的，有哪些"><span class="nav-number">3.</span> <span class="nav-text">三. GC策略是如何的，有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#New-Generation的GC策略"><span class="nav-number">3.1.</span> <span class="nav-text">New Generation的GC策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Old-Generation的GC策略"><span class="nav-number">3.2.</span> <span class="nav-text">Old Generation的GC策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-JVM的垃圾收集器"><span class="nav-number">4.</span> <span class="nav-text">4. JVM的垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#串行收集器"><span class="nav-number">4.1.</span> <span class="nav-text">串行收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行收集器（吞吐量优先）"><span class="nav-number">4.2.</span> <span class="nav-text">并行收集器（吞吐量优先）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发收集器（响应时间优先）"><span class="nav-number">4.3.</span> <span class="nav-text">并发收集器（响应时间优先）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它垃圾回收参数"><span class="nav-number">4.4.</span> <span class="nav-text">其它垃圾回收参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助信息参数设置"><span class="nav-number">4.5.</span> <span class="nav-text">辅助信息参数设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调优实战"><span class="nav-number">4.6.</span> <span class="nav-text">调优实战</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-大型网站服务器案例"><span class="nav-number">4.6.1.</span> <span class="nav-text">1. 大型网站服务器案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内部集成构建服务器案例"><span class="nav-number">4.6.2.</span> <span class="nav-text">内部集成构建服务器案例</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#参考博文"><span class="nav-number"></span> <span class="nav-text">参考博文</span></a></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">fae88</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">98.4k</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'joxd3M9p6djeWy5Ad4r3LbSM-gzGzoHsz',
        appKey: 'O9p4GKP5lHxHVddWdik96dr5',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script></body></html><!-- rebuild by neat -->